<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Random Stuff from GlacJAY]]></title>
  <link href="http://glacjay.github.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://glacjay.github.com/"/>
  <updated>2012-12-31T14:43:47+08:00</updated>
  <id>http://glacjay.github.com/</id>
  <author>
    <name><![CDATA[GlacJAY]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在 Haskell 中实现 Generic zip 函数]]></title>
    <link href="http://glacjay.github.com/blog/2009-07-14/%E5%9C%A8-haskell-%E4%B8%AD%E5%AE%9E%E7%8E%B0-generic-zip-%E5%87%BD%E6%95%B0.html"/>
    <updated>2009-07-14T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2009-07-14/在-haskell-中实现-generic-zip-函数</id>
    <content type="html"><![CDATA[<p>其实嗫，这个问题已经有标准和其他的解决方案了。标准解决方案参见 <code>Control.Applicative</code> 中的 <code>ZipList</code> ，不过这东东用起来蛮麻烦的说；其他解决方案见 bff 库的 <code>Data.Zippable</code> 模块，嗯，我还没搞明白这玩意怎么用，不过总感觉杀鸡用牛刀了有点（Template Haskell ，以及其他依赖）。</p>

<p>所以，如果你只是跟我一样，看 <code>Data.List</code> 中的那一砣 <code>zipn</code> 不顺眼的话（其实也只是看着不顺哈，用着还是蛮顺的，反正实现不用我写），一个更简单的方案在此：</p>

<p>``` haskell</p>

<blockquote><p>z :: [a -> b] -> [a] -> [b]
z = zipWith ($)
```</p></blockquote>

<p>吼吼，够简单的吧。其实这跟 <code>Control.Monad</code> 中的 <code>ap</code> 和 <code>Control.Applicative</code> 中的是一类东东啦，只不过是针对列表的 <code>zip</code> 功能滴。</p>

<p>那要怎么用嗫，也不是很麻烦啦，像这样就可以了：</p>

<p><code>
*Main&gt; (,) `map` [1,2,3] `z` "abc"
[(1,'a'),(2,'b'),(3,'c')]
*Main&gt; (,,) `map` [1,2,3] `z` "abc" `z` [Nothing, Just False, Just True]
[(1,'a',Nothing),(2,'b',Just False),(3,'c',Just True)]
</code></p>

<p>这里的 <code>map</code> 所对应的自然就是 <code>Control.Applicative</code> 中的啦。</p>

<p>还有更好玩的哦，如果再加上<a href="/blog/2009-05-06/haskell-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8.html">上一篇博</a>中的不定参函数
的话呢：</p>

<p><code>
*Main&gt; buildList `map` [1,2,3] `z` [4,5,6] :: [[Int]]
[[1,4],[2,5],[3,6]]
*Main&gt; buildList `map` [1,2,3] `z` [4,5,6] `z` [7,8,9] :: [[Int]]
[[1,4,7],[2,5,8],[3,6,9]]
</code></p>

<p>那我这次要说得就这么多啦，至于怎么用，就请大家尽情地发挥你们的想象力吧（其实是我
想象力不够 :-(）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell 中的可变长参数列表]]></title>
    <link href="http://glacjay.github.com/blog/2009-05-06/haskell-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8.html"/>
    <updated>2009-05-06T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2009-05-06/haskell-中的可变长参数列表</id>
    <content type="html"><![CDATA[<p>说实话，我之前有就这个题目很有激情地写了很长很罗嗦的一篇草稿的，哦，确切来说是大半篇，直到被打断，激情不再，这篇草稿也就此躺了两个多月。好吧，其实是我还不是八卦那块料，就不卖弄了，直接总结。</p>

<p>要在 Haskell 中实现可变长参数列表，就是利用其 Typeclass 系统，对函数进行最终结果类型和中间函数类型之间的重载，然后利用 Haskell 的类型推导机制为我们自动调用合适的重载版本。嗯，就这么简单。下面是一个最简单的例子：</p>

<p>``` haskell
class BuildList a r | r -> a where</p>

<pre><code>buildList' :: [a] -&gt; r
</code></pre>

<p>instance BuildList a [a] where</p>

<pre><code>buildList' = id
</code></pre>

<p>instance BuildList a r => BuildList a (a -> r) where</p>

<pre><code>buildList' as = \a -&gt; buildList' $ as ++ [a]
</code></pre>

<p>buildList :: BuildList a r => r
buildList = buildList' []
```</p>

<p>好吧，这个例子我是从<a href="http://okmij.org/ftp/Haskell/vararg-fn.lhs">这里</a>看到的，或者说我就是从这里学到这个东东的。在此友情提醒那些和我一样不怎么有耐心的家伙一句，原理解释在后面。</p>

<p>按照我的想法，上面这个例子应该还可以进一步简化以去掉对两个语言扩展的依赖的，就是写一个 <code>buildIntList</code> 的特化版本，结果不幸地失败了。有知道的大大告诉我一声，在下洗耳恭听。</p>

<p><strong>Update</strong>: 不需要大大们来告诉我了，我已经知道该怎么简化上面的这个 <code>buildList</code> 了，不过简化后的版本是 <code>buildCharList</code> ，也就是 <code>buildString</code> 啦，而不是原先说的 <code>buildIntList</code> 。先看实现：</p>

<p>``` haskell
class BuildString r where</p>

<pre><code>buildString' :: String -&gt; r
</code></pre>

<p>instance BuildString [Char] where</p>

<pre><code>buildString' = id             -- or whatever you want
</code></pre>

<p>instance BuildString r => BuildString (Char -> r) where</p>

<pre><code>buildString' cs = \c -&gt; buildString' $ cs ++ [c]
</code></pre>

<p>buildString :: BuildString r => r
buildString = buildString' []
```</p>

<p>这样就把对 <code>MultiParameterTypeClass</code> 和 <code>FunctionalDependency</code> 的依赖给简化掉了，可是又同时增加了对 <code>-XFlexibleInstances</code> 选项的需要（因为 <code>instance BuildString [Char] where</code> 这一行；如果你想把 <code>[Char]</code> 写成 <code>String</code> 的话，就还要再加上个 <code>-XTypeSynonymInstances</code>），暂时想不到更好的办法了。</p>

<p>另外，关于我在这里为什么要用 <code>Char</code> 而不是 <code>Int</code> 呢，是因为 <code>'a'</code> 的类型很明确，就是 <code>Char</code> ，而 <code>5</code> 的类型就不明确了，因此，你可以这样调用 <code>buildString</code> ：</p>

<p><code>
*TestVarargs&gt; buildString 'a' 'b' 'c' :: String
"abc"
</code></p>

<p>可是却必须这样调用 <code>buildIntList</code> ：</p>

<p><code>
*TestVarargs&gt; buildIntList (1::Int) (2::Int) (3::Int) :: [Int]
[1,2,3]
</code></p>

<p>虽然在我看来，GHC 应该可以倒推出每个参数的类型的，可他就是不认，我暂时也没什么办法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有关 C/C++ 中的 do { ... } while (0) 惯用法]]></title>
    <link href="http://glacjay.github.com/blog/2009-04-08/%E6%9C%89%E5%85%B3-cc-%E4%B8%AD%E7%9A%84-do-while-0-%E6%83%AF%E7%94%A8%E6%B3%95.html"/>
    <updated>2009-04-08T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2009-04-08/有关-cc-中的-do-while-0-惯用法</id>
    <content type="html"><![CDATA[<p>C/C++ 中的宏是个让人又爱又恨的家伙（感觉这句话好俗啊），在带给我们很强大的 Power 的同时，却也需要我们绝对的细心，而这也是在宏定义中诸多惯用法的由来。</p>

<p>当我们要把一组语句定义成一个宏，并希望像用一条语句那样来使用它的时候，我们就可以这样做：</p>

<p>``` cpp</p>

<h1>define MACROX \</h1>

<pre><code>do { \
    statement1 \
    statement2 \
    ... \
} while (0)
</code></pre>

<p>```</p>

<p>之后，我们只要在调用方写 <code>MACROX;</code> 就可以了。之所以不能简单的用花括号把这一组语句括起来，是为了防止扰乱 <code>if</code> 语句中的 <code>else</code> 子句的匹配问题。嗯，确实是个不错的主意啊，直到我遇到了一个，嗯，也许只有我才会遇到的问题。那就是，我在这组语句中，不能用 <code>break</code> 和 <code>continue</code> 。是不是觉得这需求蛮诡异的，呵呵，连我自己都觉得，不过这是我在重构一些相似的循环体时遇到的。但总之，我是找到了另外的一种包装方法啦，自己想想也没什么问题，大概，就像下面这样：</p>

<p>``` cpp</p>

<h1>define MACROX \</h1>

<pre><code>if (true) { \
    statement1 \
    statement2 \
    ... \
} else
</code></pre>

<p>```</p>

<p>嗯，看起来是不是要比大家都知道的那个诡异很多啊。不管了，以后发现问题了再说吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ 中的纯虚析构函数与抽象类]]></title>
    <link href="http://glacjay.github.com/blog/2009-03-22/c-%E4%B8%AD%E7%9A%84%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB.html"/>
    <updated>2009-03-22T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2009-03-22/c-中的纯虚析构函数与抽象类</id>
    <content type="html"><![CDATA[<p>我以前只知道，在 C++ 中，如果要表示一个类是抽象基类，只要为它定义一个纯虚析构函数就可以了，没想到今天用到的时候才发现，连接的时候通不过，说没有找到那个函数的定义。到网上一搜才知道，原来纯虚函数也是可以有定义的啊。在实现文件中加上它的空定义之后，一切就 OK 了。</p>

<p>不过，因为我那个基类里面已经有了一个纯虚函数，所以貌似没必要把析构函数也定义成纯虚的。</p>

<p>PS. 在 C++ 里面要实现 AST 还真是一件麻烦的体力劳动，要写那么多类，每个类还得写那么一砣的样板代码。幸好不是那种长期运行的服务器程序，不需要太考虑 memory leak 的问题，就不用写析构函数和 delete 了（实际上是懒得写），不然样板代码还要更大砣。不知道有什么更好的方法没。</p>
]]></content>
  </entry>
  
</feed>
