<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Database | Random Stuff from GlacJAY]]></title>
  <link href="http://glacjay.info/blog/categories/database/atom.xml" rel="self"/>
  <link href="http://glacjay.info/"/>
  <updated>2014-03-30T00:23:29+08:00</updated>
  <id>http://glacjay.info/</id>
  <author>
    <name><![CDATA[GlacJAY]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[通过 ODBC 接口访问 Oracle 数据库 -- Linux 篇]]></title>
    <link href="http://glacjay.info/blog/2010-03-03/%E9%80%9A%E8%BF%87-odbc-%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE-oracle-%E6%95%B0%E6%8D%AE%E5%BA%93-linux-%E7%AF%87.html"/>
    <updated>2010-03-03T00:00:00+08:00</updated>
    <id>http://glacjay.info/blog/2010-03-03/通过-odbc-接口访问-oracle-数据库-linux-篇</id>
    <content type="html"><![CDATA[<p>首先，你要安装好 UnixODBC 软件包，这个就不多说了。</p>

<p>然后，安装 Oracle 官方客户端，因为我的使用环境为 Fedora 12 ，所以我下载安装的是 <code>oracle-xe-client-10.2.0.1-1.0.i386.rpm</code> 。</p>

<p>装好之后，要设置一些环境变量，我是用的一个 Shell 脚本来完成这项工作的，你可以把它放在 <code>/etc/profile.d/</code> 目录下并加上可执行权限来让其在系统启动时自动执行，也可以直接运行这个脚本来使其立即生效。脚本如下：</p>

<p>``` bash</p>

<h1>File: oracle.sh</h1>

<p>export ORACLE_HOME=/usr/lib/oracle/xe/app/oracle/product/10.2.0/client
export PATH=$PATH:$ORACLE_HOME/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib
export TNS_ADMIN=$ORACLE_HOME/network/admin
export TWO_TASK=test
export NLS_LANG=”Simplified Chinese_china.UTF8”
export NLS_DATE_FORMAT=&ldquo;YYYY-MM-DD HH24:MI:SS&rdquo;
```</p>

<p>其中 <code>TWO_TASK</code> 变量的值应设为 <code>tnsnames.ora</code> 文件中的那个键名（下面再讲）， <code>NLS_LANG</code> 是为了 UTF-8 编码，而 <code>NLS_DATE_FORMAT</code> 设的是 <code>DATE</code> 类型的数据在插入和显示时所用的格式，这里设的是我比较习惯的一种。</p>

<p>然后在 <code>$ORACLE_HOME</code> 目录中建一个子目录 <code>network/admin</code> ，并在其中新建两个文本文件如下：</p>

<p>``` plain</p>

<h1>File: sqlnet.ora</h1>

<p>SQLNET.AUTHENTICATION_SERVICES = (NTS)
NAMES.DIRECTORY_PATH = (TNSNAMES, EZCONNECT)
```</p>

<p>这个文件中的都是一些固定的配置，其中 <code>TNSNAMES</code> 和 <code>EZCONNECT</code> 分别为我所用到的两种指定连接目标的方式。另一个文件：</p>

<p>``` plain</p>

<h1>File: tnsnames.ora</h1>

<p>test =
  (DESCRIPTION =</p>

<pre><code>(ADDRESS =
  (PROTOCOL = TCP)
  (HOST = 192.168.0.2)
  (PORT = 1521)
)
(CONNECT_DATA =
  (SID = test)
)
</code></pre>

<p>  )
```</p>

<p>第二行中的 <code>test</code> 就是 <code>TWO_TASK</code> 环境变量的值， <code>SID</code> 就是数据库名，其它的就不需要说明了。当然，在这个文件中可以配置多个数据库连接，用不同的名称来标识（ <code>TWO_TASK</code> 就是用来选择的），这个例子中只有一个配置。</p>

<p>以上的步骤主要是 Oracle 相关，都完成了之后，可以先测一下 Oracle 客户端是不是能正常使用了：</p>

<p><code>plain
$ sqlplus username/password@test
</code></p>

<p>这个命令可以连接数据库。这种参数格式就是上面提到的 <code>TNSNAMES</code> 方式，而 <code>EZCONNECT</code> 方式则是下面的样子（这种方式就不需要在 <code>tnsnames.ora</code> 文件中进行配置了）：</p>

<p><code>
$ sqlplus username/password@192.168.0.2:1521/test
</code></p>

<p>成功之后可以试试下面的 SQL 语句：</p>

<p>```</p>

<blockquote><p>select * from some_table;
```</p></blockquote>

<p>接下来就是配置 UnixODBC 了。首先是 <code>odbcinst.ini</code> 文件：</p>

<p><code>ini
[oracle]
Driver = /usr/lib/oracle/xe/app/oracle/product/10.2.0/client/lib/libsqora.so.10.1
</code></p>

<p>然后是 <code>odbc.ini</code> 文件：</p>

<p><code>ini
[oracle]
Driver = oracle
</code></p>

<p>都没什么可配的。</p>

<p>最后就是程序了，跟其它的 ODBC 程序没什么不同，除了连接字符串，需要写成这个样子：</p>

<p><code>plain
"DSN=oracle;UID=username;PWD=password"
</code></p>

<p><code>DSN</code> 就是 ODBC Data Source 名，也就是上面 <code>odbc.ini</code> 文件中方括号内的名字； <code>UID</code> 就是用户名， <code>PWD</code> 就是密码。</p>

<p>好了，就这么多。</p>

<p>PS. 我和另一位同事分别碰到过一次一个特别令人头痛的问题，就是在连接时， UnixODBC 说 <code>libsqora.so.10.1</code> （就是在 <code>odbcinst.ini</code> 文件中指定的那个）找不到，虽然这个文件明明就在那边；用 <code>ldd</code> 命令查看该文件的结果是说“这不是一个动态可执行文件”。更不幸的是，我不知怎么在我的机器上把这个问题给莫名其妙地解决了，却想破头都不知道是怎么解决的。太失败了。</p>

<hr />

<p><strong>Update:</strong> 问题解决了，出问题的都是新装的 Fedora 12 机器，后来做了次全系统的更新，再建个链接，就好了。只是不知道倒底是哪个软件包的版本太老，试了 <code>glibc</code> 、 <code>libtool</code> 、 <code>kernel</code> 都不是。</p>

<p><strong>Update 2012-12-31:</strong> 找到问题的原因了，都是 SELinux 惹的祸，关之即可，或者配下相关的策略啥的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle 建库 SQL 脚本]]></title>
    <link href="http://glacjay.info/blog/2010-03-02/oracle-%E5%BB%BA%E5%BA%93-sql-%E8%84%9A%E6%9C%AC.html"/>
    <updated>2010-03-02T00:00:00+08:00</updated>
    <id>http://glacjay.info/blog/2010-03-02/oracle-建库-sql-脚本</id>
    <content type="html"><![CDATA[<p>``` sql
&mdash; 首先是删除该数据库中该用户名下的所有表、序列与触发器，
&mdash; 其中触发器是通过表格级联删除的。
declare
  cursor usertables is</p>

<pre><code>select *
from user_tables
where table_name not like 'BIN$%';
</code></pre>

<p>  cursor usersequences is</p>

<pre><code>select *
from user_sequences;
</code></pre>

<p>begin
  for next_row in usertables loop</p>

<pre><code>execute immediate
  'drop table ' || next_row.table_name ||
  ' cascade constraints';
</code></pre>

<p>  end loop;
  for next_row in usersequences loop</p>

<pre><code>execute immediate
  'drop sequence ' || next_row.sequence_name;
</code></pre>

<p>  end loop;
end;
/</p>

<p>&mdash; 然后，就是一砣……的建表语句啦，
&mdash; 比方说下面就是两个含外键的表。
create table &ldquo;A&rdquo; (
  &ldquo;ID&rdquo; integer primary key,
  &ldquo;NAME&rdquo; nvarchar2(64) not null         &mdash; nvarchar2类型支持UTF8
);
&mdash; Oracle中的表名与字段名最好写成这样引号加全大写的形式。</p>

<p>create table &ldquo;B&rdquo; (
  &ldquo;ID&rdquo; integer primary key,
  &ldquo;A&rdquo; integer not null references &ldquo;B&rdquo; on delete cascade,
  &ldquo;VALUE&rdquo; nvarchar2(64) not null
);</p>

<p>&mdash; 接下来是第三部分，为所有的表创建对应的序列和触发器，以实现自增主键。
declare
  cursor usertables is</p>

<pre><code>select cols.table_name, cols.column_name
from all_constraints cons, all_cons_columns cols
where cols.owner = (
  select sys_context('USERENV', 'SESSION_USER')
  from dual)
and cols.table_name not like 'BIN$%'
and cons.constraint_type = 'P'
and cons.constraint_name = cols.constraint_name
and cons.owner = cols.owner
</code></pre>

<p>begin
  for nextrow in usertables loop</p>

<pre><code>-- 1000以下的留作初始测试数据用，见下
execute immediate
  'create sequence "' || nextrow.table_name ||
  '_PK_SEQ" start with 1000';
execute immediate
  'create or replace trigger "' || nextrow.table_name ||
  '_PK_TRG" before insert on "' || nextrow.table_name ||
  '" for each row begin if :new."' || nextrow.column_name ||
  '" is null then select "' || nextrow.table_name ||
  '_PK_SEQ".nextval into :new."' || nextrow.column_name ||
  '" from dual; end if; end;';
</code></pre>

<p>  end loop;
end;
/</p>

<p>&mdash; 最后当然就是测试数据啦。
insert into &ldquo;A&rdquo; (ID, NAME) values (1, &lsquo;first name&rsquo;);
insert into &ldquo;B&rdquo; (ID, AID, VALUE) values (1, 1, &lsquo;Jay&rsquo;);
insert into &ldquo;B&rdquo; (ID, AID, VALUE) values (2, 1, &lsquo;杰&rsquo;);
```</p>
]]></content>
  </entry>
  
</feed>
