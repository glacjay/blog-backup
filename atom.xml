<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Random Stuff from GlacJAY]]></title>
  <link href="http://glacjay.github.com/atom.xml" rel="self"/>
  <link href="http://glacjay.github.com/"/>
  <updated>2012-12-31T21:43:15+08:00</updated>
  <id>http://glacjay.github.com/</id>
  <author>
    <name><![CDATA[GlacJAY]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[修改 OpenVPN 实现加密算法的自动协商]]></title>
    <link href="http://glacjay.github.com/blog/2011-09-17/%E4%BF%AE%E6%94%B9-openvpn-%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8D%8F%E5%95%86.html"/>
    <updated>2011-09-17T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-09-17/修改-openvpn-实现加密算法的自动协商</id>
    <content type="html"><![CDATA[<p>由<a href="http://glacjay.github.com/blog/2011-01-18/openvpn-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.html">另一篇博</a>中的分析可知，OpenVPN 中有两个加解密通道。一条是标准的 SSL 协议通道，被 OpenVPN 用于协商自己所用的密钥。这个通道的加密算法当然也是通过 SSL 协议来进行协商的，可以通过 <code>--tls-cipher</code> 选项来进行配置。另一条是 OpenVPN 自己的加解密通道，用于交换实际的数据，也就是虚拟网卡抓到的 IP 报文。这个通道的加密算法则是通过 <code>--cipher</code> 和 <code>--auth</code> 两个选项，分别在通调两端指定的。</p>

<p>对于第二条通道的加密算法，必须要同时在两端分别指定一致的选项，有时候不是很方便（当然，我研究的还是 2.1.1 版本的 OpenVPN ，不知道最新的版本还是不是这样）。比如说，我想通过在服务端修改配置，指定加密算法，然后让连接我的客户端自动用同一个算法。最简单的修改思路，就是借用第一条通道中的算法协商机制，从 SSL 对象中取得协商出来的算法。</p>

<p>具体做法就是：</p>

<p>首先，在函数 <code>do_init_crypto_tls_c1()</code> 中，去掉对函数 <code>init_key_type()</code> 的调用。这个调用就是根据 <code>--cipher</code> 和 <code>--auth</code> 选项进行算法配置的地方，我们要动态协商，自然是不需要这个了。</p>

<p>但同时，这会引起接下来一个步骤的错误。在函数 <code>crypto_adjust_frame_parameters()</code> 中，会根据之前配置的算法进行报文中密钥空间的分配。现在还不知道算法，怎么知道要分配多少空间呢？就只能改成最大值了。分别改为 <code>MAX_CIPHER_KEY_LENGTH</code> 和 <code>MAX_HMAC_KEY_LENGTH</code> 就行了。当然，这样改不仅浪费空间，而且也不够严谨，因为 key length 和 IV length 不是一回事，却只能都用 <code>MAX_CIPHER_KEY_LENGTH</code> 来初始化。</p>

<p>最后就是在 SSL 协商好之后，从里面取加密算法了。具体位置在 <code>key_method_2_write()</code> 和 <code>key_method_2_read()</code> 两个函数中，对 <code>generate_key_expansion()</code> 函数的调用之处了。在调用之前，初始化一下 <code>key_type</code> 就行了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">key_type</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">key_type</span> <span class="o">*</span><span class="p">)</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">key_type</span><span class="p">;</span>
</span><span class='line'><span class="n">key_type</span><span class="o">-&gt;</span><span class="n">cipher</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">enc_read_ctx</span><span class="o">-&gt;</span><span class="n">cipher</span><span class="p">;</span>
</span><span class='line'><span class="n">key_type</span><span class="o">-&gt;</span><span class="n">cipher_length</span> <span class="o">=</span> <span class="n">EVP_CIPHER_key_length</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">key_type</span><span class="o">-&gt;</span><span class="n">cipher</span><span class="p">);</span>
</span><span class='line'><span class="cp">#if OPENSSL_VERSION_NUMBER &gt;= 0x010000000L</span>
</span><span class='line'><span class="n">key_type</span><span class="o">-&gt;</span><span class="n">digest</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">read_hash</span><span class="o">-&gt;</span><span class="n">digest</span><span class="p">;</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'><span class="n">key_type</span><span class="o">-&gt;</span><span class="n">digest</span> <span class="o">=</span> <span class="n">ks</span><span class="o">-&gt;</span><span class="n">ssl</span><span class="o">-&gt;</span><span class="n">read_hash</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="n">key_type</span><span class="o">-&gt;</span><span class="n">hmac_length</span> <span class="o">=</span> <span class="n">EVP_MD_size</span> <span class="p">(</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">key_type</span><span class="o">-&gt;</span><span class="n">digest</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样就行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写自己的 Web 版 Google Reader 客户端]]></title>
    <link href="http://glacjay.github.com/blog/2011-08-11/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84-web-%E7%89%88-google-reader-%E5%AE%A2%E6%88%B7%E7%AB%AF.html"/>
    <updated>2011-08-11T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-08-11/编写自己的-web-版-google-reader-客户端</id>
    <content type="html"><![CDATA[<p>最近花在路上的时间明显变多了，手机就成了我打发这些路上时间的利器。小说神马的看太多也会腻，正好 Google Reader 中也积累了大量的未读文章，因此用手机看看订阅文章就成了一个比较好的选择。</p>

<p>但多次使用下来，却也发现了很多 Google 原版 Web 界面的不方便之处。Google 提供了两个版本的 Reader 界面给手机，一个是苹果风格的 <code>/i/</code> 界面，设计得很漂亮，功能也很全，用 Nokia 手机也能看，但太费流量（未证实，只是感觉，大概是因为一次加载了很多的文章吧），而且在网络状况不好的时候，体验不太好。另一个是 <code>/m/</code> 界面，很简洁，选项不多，但也总有些这样那样的细节另我不太满意，下面详述。然后又去找 Nokia 的 S60v3 客户端软件，总之是没一个喜欢啦。作为一个 Geek （至少是自称），在这种情况下，最佳选择自然就是打造一个自己专属的解决方案啦。</p>

<p>正好蹭着同学的一个 PHP 空间（其实也有 Python 和 Ruby 可选啦，但总觉得会很折腾，还是 PHP 好点，虽然折腾也少不了，见下），于是花了几天时间，连复习 PHP （以前只学过没用过，主要还是看 w3schools 的教程和查 php.net 的函数文档）、研究 OAuth （参见<a href="http://www.ioncannon.net/programming/1443/google-oauth-for-installed-apps-php-example/">这篇文章</a>，不过 Web 应用稍有不同）、研究 Google Reader API （参见<a href="http://blog.martindoms.com/2009/08/15/using-the-google-reader-api-part-1/">这系列文章</a>）、编写代码，终于搞定了一个很阳春的 Google Reader Mobile 版，刚刚满足我的手机阅读需要。</p>

<p>以下就是我针对 Google 原版所做的，针对我个人的改进：</p>

<ul>
<li><strong>保存期限的问题</strong>：以前也有感觉，这次趁着做这个东东，又确认了一下：Google 只会保存 30 天内的未读文章，超过 30 天的就自动标记成已读了。我希望能保存下来慢慢看，所以就搞了一个简单的 SQLite 数据库，定时把曾经是未读文章的 <code>id</code> 号都给保存下来，直到我通过这个界面读过之后再删除。嗯，这个功能是最重要的。</li>
<li><strong>先看最老的文章</strong>：当然，通过这两天对 API 的研究，我已经知道怎么在 Google 的 <code>/m/</code> 界面中实现这个功能了，不过为了上一个功能，打造自己的界面还是必要的。</li>
<li><strong>重复载入的问题</strong>：当我要给一篇文章加星的时候，我一般都希望能直接看到下一篇文章，而不是再看一次被加星的这篇。这也是一个很小的改进啦，不过用起来很舒服，既节省了流量，也节省了时间。</li>
<li><strong>加载文章的时候先不要标记为已读</strong>：由于手机的网络状况通常不太好，当我浏览完一篇，想加个星标的时候，结果页面却打不开了，这种情况经常发生。所以，我就把标记为已读的这个步骤，挪到了看一下篇之前，或者加星标之后。这样，就比再去已读文章里面找要来得方便。</li>
<li><strong>去掉 <code>/m/</code> 的所有其他功能</strong>：当然，这不是一个改进啦，只是我不需要而已。既然是用手机来看，当然就没有那么多需要啦，只要能实现浏览与加星标就好了。需要细看的，就加个标，等有电脑的时候再慢慢看。本来， Google Reader 的星标功能，除了作为 ToRead 列表外，就没什么其他用处了（当然，以后也许会跟搜索整合，然后优先显示神马的，那就不管了）。不过话说回来，功能的简化其实也是一种改进啦，最近刚好看到 InstaPaper 的作者也这么说来着。</li>
<li><strong>功×夫×网</strong>：不过其实 Google Reader 并没有被封的很严，倒是我自己的实现招来了这个问题，见下。</li>
</ul>


<p>简单来说，就是按顺序，对所有文章，看，（可选地）加星标，然后下一篇。需求往往就这么简单啊。</p>

<p>当然，在做的时候，还是遇到过各种稀奇古怪的问题（ Neta ：编程好难啊），这里也一并记录下。</p>

<p>先是在自己机器上 OK 了，等部署到空间的时候却报错： an error occured while processing this directive 。同样的脚本，放到其他目录就没事，还以为是 Apache 的权限问题，也没找到有什么特别的配置。直到有机会查看 Apache 的错误日志，才发现原来就是因为新加的这个目录有组的写权限，而 Apache 不允许这样，真是吐血。话说加上组的写权限，也是为了 SQLite 来着，因为 SQLite 会在数据库所在目录中写事务日志文件。</p>

<p>然后就是发现，我用的 SQLite3 的 PHP 接口，在空间的 PHP 5.2 版本中还没有呢。真是悲剧。然后又吭哧吭哧地用 PDO 接口重写了数据库的代码。</p>

<p>等到好不容易改好啦，用电脑访问也一切正常，结果用手机访问的时候，看不了两个页面，就会出现“连接被远程服务器关闭”的错误。一开始还没有往功×夫×网的方向想，只以为又是服务器的权限问题（我为什么要加“又”？），来回地看日志，切换测试，不停地折腾。直到在电脑上偶然看到，该网页需要翻×墙的标志，再一看 URL 才恍然，原来是我传的一个 GET 参数，是该文章的订阅源 URL ，而有些文章是从 Feed×Burner 订阅的，这才触发了功×夫×网。真是躺着也中枪啊，赶急加一个 Base64 编码搞定。</p>

<p>不管怎样，一个简陋的阅读器就这样被实现出来了。鉴于我近期还不想烧钱换手机，这个东东应该还是很有用武之地的吧。不知道 Google 出的 Android 客户端有没有 30 天的限制。</p>

<p>最后的最后，该版本仅限我个人使用，因为我没有实现多用户的功能，所以大家（如果有的话）也就不要去尝试访问了。我之后会把代码给开源的，到时随你（如果有的话，嗯）折腾。</p>

<hr />

<p><strong>Update:</strong> 代码已<a href="https://github.com/glacjay/mreader">上传</a>。</p>

<p><strong>Update 2012-12-31:</strong> 现在有了 Android 手机，已经开始用 gReader 这个客户端了，除了“延迟标记已读”这个功能还没有之外，其他所需功能已经都有了，而且还是离线阅读哦（我自己的版本就没有实现离线阅读这个功能，因为太麻烦）。不过我的数据库里面已经存了 7000 多篇文章没看了……囧</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转载] Compilers: what are you thinking about?]]></title>
    <link href="http://glacjay.github.com/blog/2011-07-26/%E8%BD%AC%E8%BD%BD-compilers-what-are-you-thinking-about.html"/>
    <updated>2011-07-26T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-07-26/转载-compilers-what-are-you-thinking-about</id>
    <content type="html"><![CDATA[<p>最近在翻看以前加星的 Google Reader 文章，把有用的整理出来打标签，然后就看到了这篇。原文作者的博客现在不知道被丢到哪边去了，搜也搜不到，转到这里，权当保存一下吧。</p>

<p>原文链接：<a href="http://www.onebadseed.com/blog/?p=119">Compilers: what are you thinking about?</a>。当然，已经打不开了。</p>

<hr />

<h2>Compilers: what are you thinking about?</h2>

<p>Author: Rotten Cotton</p>

<p>My recent post <a href="http://www.onebadseed.com/blog/?p=103">Compiler bibliography</a>, a motley list of compiler papers that had been sitting in a box in my attic, generated a surprising amount of traffic: over a thousand unique visitors. But no comments. For those of you interested in compiler design, I ask, what are you trying to understand? What are you trying to do?</p>

<p>I imagine some of you are interested in understanding how compilers work and, more importantly, how to build them. The first step in learning to design compilers is to build one. (Tautologous, no?) To start, I recommend following the syllabus of a compiler design course. Googling “<a href="http://www.google.com/search?hl=en&amp;q=compiler+syllabus&amp;aq=f&amp;oq=&amp;aqi=g1">compiler syllabus</a>” returns a massive list of syllabi for compiler for compiler classes. The first link, a <a href="http://web.cecs.pdx.edu/~harry/compilers/syllabus.html">compiler design</a> class, at Portand State University, follows Louden’s book <a href="http://www.amazon.com/gp/product/0534939724?ie=UTF8&amp;tag=wwwonebadseec-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0534939724">Compiler Construction</a> to build a SPARC compiler for a toy programming language, <a href="http://web.cecs.pdx.edu/~harry/compilers/PCATLangSpec.pdf">PCAT</a> (pdf). MIT’s compiler design class, <a href="http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-035Fall-2005/CourseHome/">6.035</a>, is on <a href="http://ocw.mit.edu/">OCW</a>. Following one of these classes will teach you the basic challenges involved in designing a compiler and the organizational principles that have emerged to solve these problems. If you’re ambitious, start with a free C front end and build a C compiler for your favorite architecture. There is <a href="http://www.smlnj.org/doc/ckit/index.html">ckit</a> for ML, <a href="http://www.sivity.net/projects/language.c/">Language.C</a> for Haskell or <a href="http://clang.llvm.org/">clang</a> (part of the <a href="http://llvm.org/">LLVM</a> project) written in, I think, C++. There are others, no doubt. This way, you won’t have to write a front-end and you will have a huge source of potential examples on which to test your compiler and, when your start to design optimizations (the fun part), explore your compiler’s performance.</p>

<p>For a few years after I first took 6.035, whenever the course was taught again and the project (toy language) for that semester was announced, I would spend a long caffeine-fueled weekend hacking out a new compiler. I must have build three or four compilers this way, targeting different architectures and exploring various design choices. This was a very valuable experience.</p>

<p>Once you understand the basics of compiler design, what’s next? There are a number of directions you can go.</p>

<p>You can study programming language features and their implementation in a compiler and runtime. For this, I recommend a book like Scott’s <a href="http://www.amazon.com/gp/product/0123745144?ie=UTF8&amp;tag=wwwonebadseec-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0123745144">Programming Language Pragmatics</a> or Turbak and Gifford’s <a href="http://www.amazon.com/gp/product/0262201755?ie=UTF8&amp;tag=wwwonebadseec-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0262201755">Design Concepts in Programming Languages</a>. I used a draft version of the latter in MIT’s Programming Languages class, 6.821. This will move beyond compiling the standard C- or Pascal-like toy languages standard in most first-year compiler courses. Learn about semantics: denotational, operational and axiomatic. This is important if you (a) want to build a correct compiler, and (b) as a theoretical foundation for program analysis.</p>

<p>At the other end of the spectrum are computer architectures. Go learn about computer architecture: instruction set architectures and micro-architectures, their implementation. There are many interesting architectures out there to study. Write assembly language programs by hand. Learn to extract maximal performance form an architecture on small examples. Pay attention to the techniques used to extract performance when hand-coding. These will be the basis for compiler optimizations. The standard text for computer architecture is probably Hennessy and Patterson’s text, <a href="http://www.amazon.com/gp/product/0123704901?ie=UTF8&amp;tag=wwwonebadseec-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0123704901">Computer Architecture: A Quantitative Approach</a>.</p>

<p>A deep understanding of both the semantics of your input programming language and your target (micro-)architectures is essential to building a compiler that generates high-performance code. Program analysis and optimization is the bridge between the input program and assembly language. Start with a book on advanced compiler design like Muchnick’s <a href="http://www.amazon.com/gp/product/1558603204?ie=UTF8&amp;tag=wwwonebadseec-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1558603204">Advanced Compiler Design and Implementation</a> (or maybe the new dragon book, I haven’t looked at it) or start diving into the literature or program analysis and optimization.</p>

<p>What are you trying to understand about compilers?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译] 用 Ruby 写编译器之六：匿名函数 lambda]]></title>
    <link href="http://glacjay.github.com/blog/2011-05-21/%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%85%AD%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-lambda.html"/>
    <updated>2011-05-21T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-05-21/用-ruby-写编译器之六：匿名函数-lambda</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html">http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html</a></p>

<p>既然上次已经提到说，我们其实是在从 Lisp、Scheme 还有类似的其他语言中借鉴各种要实现的功能（我没想过要把这个项目做成原创的⋯⋯或者至少也要等到以后再说吧），那么现在也<strong>是时候</strong>实现一些更加强大的功能了。</p>

<h2>那就来做延迟求值以及匿名函数吧</h2>

<p>Lambda ，又名匿名函数，可以像普通的数值或者字符串类型那样被当作函数参数来到处传递，也可以在需要的时候才调用（当然不调也可以）。同时，外层函数（也就是定义匿名函数的函数）作为它们的运行环境，在其中定义的局部变量可以被这些匿名函数所访问。这就形成了<a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">一个闭包</a>。我们这次<strong>并不是</strong>要实现完整的闭包功能，只是开头的一小步而已，完整的实现要等到再后面了。</p>

<p>其实说到底，正如编程语言中的其他很多功能一样，闭包也只是又一种语法糖而已。比如说，你可以认为这样其实是定义了一个类，这个类中有唯一一个需要被调用的方法，还有一些作为运行环境的成员变量（或者你也可以反过来<a href="http://strlen.com/bla/index.html">用闭包来实现面向对象系统</a> &#8211; 这是由 <a href="http://strlen.com/">Wouter van Oortmerssen</a> 所提出来的观点。自从我发现 <a href="http://strlen.com/e/index.html">Amiga E</a> 这个项目之后，作为作者的他就成了我的偶像。如果你是一个编程语言方面的极客的话，那你就一定要去看看 Wouter 所做过的东西） &#8211; 有很多功能其实都是相互正交的。</p>

<p>（ blah blah blah ⋯⋯这个人在说自己很啰嗦之类的，就不翻了）</p>

<p>那么，为了避免定义很多具名小函数的麻烦，同时降低函数重名的概率， lambda 允许你在任何需要它们的地方进行定义，并且返回一个表示所定义函数的值。</p>

<p>我们现在所要增加的是像下面这样的东西：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">args</span><span class="p">)</span> <span class="nv">body</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nv">call</span> <span class="nv">f</span> <span class="p">(</span><span class="nv">args</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个表达式会返回所定义的函数（目前来说，其实就是这个函数的起始地址），而不是去执行这个函数。而 <code>call</code> ，当然就是以指定的参数列表，来调用传给它的那个函数地址。</p>

<p>那么，这跟“真正”的闭包又有什么区别呢？</p>

<p>最重要的一点就是，当你在 lambda 中引用了外层作用域中的某个变量后，那么，当以后对同一个 lambda 进行调用时，这个变量还是可以访问的。这样的变量与 lambda 绑定在了一起。当然，只是得到一个函数的地址的话，肯定是实现不了这个功能的。让我们来看一种实现闭包的技术吧，这样你就能够了解大概所要做的工作了（工作量不大，但也不小）：</p>

<ul>
<li>我们可以创建一个“环境”，一个存放那些被引用到的外部变量的地方，以使得当外层函数返回之后，它们也可以继续存在。这个环境必须是在堆中，而且每次对外层函数的调用，都需要创建一个新的环境。</li>
<li>我们必须返回一个可以用来访问这个环境的东西。你可以返回一个对象，其中的成员变量就是被 lambda 引用到的那些变量。或者你也可以用一个 thunk （中文叫啥呢？），也就是自动生成出来的一个包含有指向这个对象指针的小函数，它会在调用我们的 lambda 之前将这个对象加载到预先指定的地方。或者你也可以用什么其他的办法。</li>
<li>你必须决定有哪些变量需要放入这个环境中。可以是外层函数中的所有局部变量，当然也可以只是那些被引用到的变量。后一种作法可以节省一定的内存空间，但是需要作更多的工作。</li>
</ul>


<p>好吧，还是让我们先来把匿名函数本身给弄出来吧。就像以前一样，我会一步一步地说明所要做的修改，但我同时也会对之前的代码做一些整理。这些整理的部分我就不一一说明了。</p>

<p>首先是对 lambda 表达式本身进行处理的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">compile_lambda</span> <span class="n">args</span><span class="p">,</span> <span class="n">body</span>
</span><span class='line'>    <span class="nb">name</span> <span class="o">=</span> <span class="s2">&quot;lambda__</span><span class="si">#{</span><span class="vi">@seq</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="vi">@seq</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">compile_defun</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span><span class="n">body</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">movl</span><span class="se">\t</span><span class="s2">$</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">,%eax&quot;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">[</span><span class="ss">:subexpr</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个实现应该是很容易理解的吧。我们在这里做的，就是给要定义的匿名函数，生成一个形如 <code>lambda__[number]</code> 的函数名，然后就把它当作一个普通函数来处理了。虽然你也可以就把它生成到外层函数的函数体中，但我发现那样做的话，就会显得很乱的样子，所以我现在还是就把它作为单独的函数来处理了。然后我们调用 <code>#compile_defun</code> 方法来处理这个函数，这样的话，这个函数其实也就只有对用户来说，才是真正匿名的了。然后我们把这个函数的地址保存在寄存器 <code>%eax</code> 中，这里同时也是我们存放子表达式结果的地方。当然，这是一种很懒的作法啦，我们迟早需要为复杂的表达式，实现更加强大的处理机制的。但寄存器分配果然还是很麻烦的一件事情，所以现在就先这样吧（将所有的中间结果压入栈中也是一种可行的作法啦，不过那样比较慢）。</p>

<p>最后，我们返回一个 <code>[:subexpr]</code> ，来告拆调用者到哪边可以得到这个 lambda 的值。</p>

<p>之后是一些重构。你也许已经注意到了， <code>#compile_exp</code> 中的代码有点乱，因为要处理不同类型的参数。让我们把这部分代码给提取出来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">compile_eval_arg</span> <span class="n">arg</span>
</span><span class='line'>    <span class="n">atype</span><span class="p">,</span> <span class="n">aparam</span> <span class="o">=</span> <span class="n">get_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">&quot;$.LC</span><span class="si">#{</span><span class="n">aparam</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">atype</span> <span class="o">==</span> <span class="ss">:strconst</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">&quot;$</span><span class="si">#{</span><span class="n">aparam</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">atype</span> <span class="o">==</span> <span class="ss">:int</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">aparam</span><span class="o">.</span><span class="n">to_s</span> <span class="k">if</span> <span class="n">atype</span> <span class="o">==</span> <span class="ss">:atom</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">&quot;%eax&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>要注意的是，这里又出现了一个新的 <code>:atom</code> 类型。借助于此，我们就可以把一个 C 函数的地址传给 <code>:call</code> 指令了。反正实现起来也很简单。当然，我们还要在 <code>#get_arg</code> 方法中加上如下代码，以使其生效：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">return</span> <span class="o">[</span><span class="ss">:atom</span><span class="p">,</span> <span class="n">a</span><span class="o">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Symbol</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，作为重构的一部分，对 <code>:call</code> 的处理被分离了出来，成为一个单独的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">compile_call</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span>
</span><span class='line'>    <span class="n">stack_adjustment</span> <span class="o">=</span> <span class="no">PTR_SIZE</span> <span class="o">+</span> <span class="p">(((</span><span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">+</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">.</span><span class="mi">0</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="p">))</span><span class="o">.</span><span class="n">round</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">subl</span><span class="se">\t</span><span class="s2">$</span><span class="si">#{</span><span class="n">stack_adjustment</span><span class="si">}</span><span class="s2">, %esp&quot;</span>
</span><span class='line'>    <span class="n">args</span><span class="o">.</span><span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>      <span class="n">param</span> <span class="o">=</span> <span class="n">compile_eval_arg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">movl</span><span class="se">\t</span><span class="si">#{</span><span class="n">param</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">?</span> <span class="n">i</span><span class="o">*</span><span class="mi">4</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="si">}</span><span class="s2">(%esp)&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">res</span> <span class="o">=</span> <span class="n">compile_eval_arg</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</span><span class='line'>    <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;*%eax&quot;</span> <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="s2">&quot;%eax&quot;</span> <span class="c1"># Ugly. Would be nicer if retain some knowledge of what res contains.</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">call</span><span class="se">\t</span><span class="si">#{</span><span class="n">res</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">addl</span><span class="se">\t</span><span class="si">#{</span><span class="n">stack_adjustment</span><span class="si">}</span><span class="s2">, %esp&quot;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">[</span><span class="ss">:subexpr</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来很熟悉对不对？因为它就是原来的 <code>#compile_exp</code> 方法，只不过是用 <code>#compile_eval_arg</code> 替换掉了其中的一些代码。另外有改动的地方，就是同时也用 <code>#compile_eval_arg</code> 方法来得到要调用的函数，并对可能得到的 <code>%eax</code> 做了些手脚，在前面加了个星号。</p>

<p>如果你知道这是怎么回事的话，你也许已经开始寻思其他的点子了，而不管那是真正的好事，还只是开枪打自己的脚。上面的代码其实就相当于，你把任意一个表达式的值当作指向一段代码的指针，然后也不做任何的检查，就直接跳过去执行它。如果是往一个随机的地址进行跳转的话，你最有可能得到的就是一个段错误了。当然，你也可以很容易地通过这项技术，来实现面向对象系统中的虚函数跳转表，或者其他的什么东西。因此，安全性将会是以后必须要考虑的东西。还有就是，要实现对一个地址（而不是函数名）的间接调用，你必须要在这个地址前面加上星号。</p>

<p>那么，现在的 <code>#compile_exp</code> 方法变成什么样子了呢？简单来说就是，变得整齐多了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">compile_do</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="p">)</span>
</span><span class='line'>    <span class="n">exp</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">compile_exp</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">[</span><span class="ss">:subexpr</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">compile_exp</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">if</span> <span class="o">!</span><span class="n">exp</span> <span class="o">||</span> <span class="n">exp</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">compile_do</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:do</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">compile_defun</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:defun</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">compile_ifelse</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:if</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">compile_lambda</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:lambda</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">compile_call</span><span class="p">(</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">,</span> <span class="n">exp</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:call</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">compile_call</span><span class="p">(</span><span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">,</span> <span class="o">*</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来很不错，不是吗？<code>#compile_call</code> 几乎跟之前的 <code>#compile_exp</code> 一模一样，只不过是把一些代码给提取出来，成为了辅助方法而已。</p>

<p>那么就来简单地测试一下吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">prog</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:do</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:call</span><span class="p">,</span> <span class="o">[</span><span class="ss">:lambda</span><span class="p">,</span> <span class="o">[]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;Test&quot;</span><span class="o">]]</span><span class="p">,</span> <span class="o">[]</span> <span class="o">]</span>
</span><span class='line'><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>（看起来也没那么糟不是吗？）</p>

<p>编译运行之：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ruby step6.rb &gt;step6.s
</span><span class='line'>$ make step6
</span><span class='line'>cc      step6.s  -o step6
</span><span class='line'>$ ./step6
</span><span class='line'>Test
</span><span class='line'>$</span></code></pre></td></tr></table></div></figure>


<p>这篇的代码在<a href="http://www.hokstad.com/static/compiler/step6.rb">这里</a>。</p>

<h2>之后的部分</h2>

<p>因为我合并了几篇文章，下面就列一下更新过后的，“已经写完但还需要整理的”文章列表。因为我肯定还会合并下面的某些部分的，所以我想我需要找时间开始写一些新的部分了（为了完成我所定下的 30 篇的计划）。</p>

<ul>
<li>步骤七：再看用匿名函数实现循环，以及对函数参数的访问</li>
<li>步骤八：实现赋值语句以及简单的四则运算</li>
<li>步骤九：一个更简洁的 <code>while</code> 循环语句</li>
<li>步骤十：测试这个语言：实现一个简单的输入转换模块</li>
<li>步骤十一：重构代码生成器，分离架构相关的部分</li>
<li>步骤十二：对某些功能点的讨论，以及未来的前进方向</li>
<li>步骤十三：实现数组</li>
<li>步骤十四：局部变量以及多重作用域</li>
<li>步骤十五：访问变长参数列表</li>
<li>步骤十六：再看输入转换模块，重构以支持新功能，并用其解析它自己</li>
<li>步骤十七：总结实现自举所需要的功能点</li>
<li>步骤十八：开始实现真正的解析器</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译] 用 Ruby 写编译器之五：整数常量，以及 if 语句]]></title>
    <link href="http://glacjay.github.com/blog/2011-05-17/%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%EF%BC%9A%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5.html"/>
    <updated>2011-05-17T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-05-17/用-ruby-写编译器之五：整数常量，以及-if-语句</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-5.html">http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-5.html</a></p>

<p>上次我承诺会发布的更快一些，不过还是失败了⋯⋯作为补偿，这章的内容将会是原计划中的第 5，6，7 章内容的合并，因为这三章确实都很短。闲话少叙：</p>

<h2>处理数字常量</h2>

<p>到目前为止，我们只处理了一些实现所必须的数字常量，也就是当一个外部函数的返回值是数字的情况，而且没有做任何形式的类型检查。</p>

<p>那么，就让我们来看一下 gcc 在 C 语言中是怎样处理各种类型（包括 <code>long long</code> 等）的整数的吧。当然，这次还是针对 32 位的 x86 架构：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">foo1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo2</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">short</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo3</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo4</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo5</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo6</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo7</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo8</span><span class="p">(</span><span class="kt">signed</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">foo1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="n">foo2</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="n">foo3</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>  <span class="n">foo4</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span><span class='line'>  <span class="n">foo5</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>  <span class="n">foo6</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
</span><span class='line'>  <span class="n">foo7</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我略掉了大部分 gcc 所生成的代码，如果愿意，你可以自己执行 <code>gcc -S</code> 命令来看。有趣的部分是对各个函数的调用，其生成的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">foo1</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">foo2</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">foo3</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">foo4</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">foo5</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">foo6</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">foo7</span>
</span></code></pre></td></tr></table></div></figure>


<p>换句话说，至少在处理函数调用的时候，gcc 都会把各种整数类型统一作为 32 位的整型来处理，除了 <code>long long</code> 类型之外。因此，我们可以暂时忘掉 <code>long long</code> 类型，而只处理 32 位以内的整数值，这样我们就可以忽略类型处理相关的东西了。</p>

<p>懒惰还真是一种病啊。</p>

<p>我们同时也会略过浮点型。为什么呢？因为只要有整数运算，你就可以实现一个完整的编译器了，所以现在就加入对浮点型的支持完全只是浪费时间而已。当然这个东西以后总归是要做的。</p>

<p>另外，当<strong>我</strong>还年轻时，我们连 FPU 是啥都还不知道呢。尽管如此，我们依然可以用整数来模拟各种定点运算，一样可以完成很多事情。</p>

<p>那么，我们真正要做的修改有哪些呢？</p>

<p>在方法 <code>#get_arg</code> 中，在处理字符串常量之前，加入如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">return</span> <span class="o">[</span><span class="ss">:int</span><span class="p">,</span> <span class="n">a</span><span class="o">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Fixnum</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>在方法 <code>#compile_exp</code> 中，我们用如下代码来处理 <code>#get_arg</code> 的返回值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">elsif</span> <span class="n">atype</span> <span class="o">==</span> <span class="ss">:int</span> <span class="k">then</span> <span class="n">param</span> <span class="o">=</span> <span class="s2">&quot;$</span><span class="si">#{</span><span class="n">aparam</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，就完事了。就这么简单。</p>

<p>然后就是测试啦：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">prog</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:do</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:printf</span><span class="p">,</span><span class="s2">&quot;&#39;hello world&#39; takes %ld bytes</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="o">[</span><span class="ss">:strlen</span><span class="p">,</span> <span class="s2">&quot;hello world&quot;</span><span class="o">]]</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:printf</span><span class="p">,</span><span class="s2">&quot;The above should show _%ld_ bytes</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="mi">11</span><span class="o">]</span>
</span><span class='line'><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>插曲：针对原生数据类型的一些思考</h2>

<p>“纯”面向对象类型的语言很棒，但并不是对底层的代码生成器而言的，我想。不管你是否想要实现一个纯的面向对象语言，我仍然坚信，首先实现原生的数据类型和其操作，是非常有价值的。你可以在后面的阶段再来考虑是否要对用户隐藏它们，或者是让它们看起来像是对象，或者是透明地在它们和对象之间执行自动转换的操作，等等。</p>

<p>要注意的是，Matz 的 Ruby 解释器（Matz Ruby Interpreter，简称MRI）就是这样实现的：里面的数字就跟“真正的”对象神马的完全不一样，但是解释器本身却尽其所能的对用户隐藏这一事实。不过我个人认为 MRI 做的还是不够。</p>

<h2><code>If ... then ... else</code></h2>

<p>如果没有某种形式的条件逻辑支持的话，我们的语言是没有太大用处的。几乎所有有用的语言都支持某种形式的 <code>if .. then .. else</code> 构造。现在，我们要实现的是像 <code>[:if, condition, if-arm, else-arm]</code> 这样的构造，而且是以 C 语言的形式来实现。也就是说， <code>0</code> 和空指针都表示假，其他值则都为真。</p>

<p>仍然是一个简单的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">baz</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">foo</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">bar</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>相关的汇编输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'>    <span class="nf">call</span>    <span class="nv">baz</span>
</span><span class='line'>    <span class="nf">testl</span>   <span class="o">%</span><span class="nb">eax</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
</span><span class='line'>    <span class="nf">je</span>      <span class="nv">.L6</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">foo</span>
</span><span class='line'>    <span class="nf">jmp</span>     <span class="nv">.L10</span>
</span><span class='line'><span class="nl">.L6:</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">bar</span>
</span><span class='line'><span class="nl">.L10:</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于大多数的语言和架构来说，这都是一个编译 <code>if .. then .. else</code> 时会采用的通用模板：</p>

<ul>
<li>计算条件表达式。</li>
<li>对结果进行测试（这里用的是 <code>testl</code> 指令 &#8211; 在其他架构中比较通用的还有 <code>cmp</code> 指令，或者对寄存器进行自减）。 <code>testl</code> 指令比较它的左右两个操作数，并进行相应的标志位设置。</li>
<li>然后，条件跳转到 <strong><code>else</code> 语句处。这里，我们检查条件表达式的值是否不为真。在这种情况下我们用的是 <code>je</code> 指令，即“相等时跳转”（ jump on equal ），也就是当结果相等时跳转（要注意的是，在大多数的 CPU 架构中，很多指令都会设置条件码，而不仅仅是显示的测试指令）。</strong></li>
<li>然后执行 <code>then</code> 子句。</li>
<li>跳过 <code>else</code> 子句，继续执行整个 <code>if</code> 语句之后的部分。</li>
<li>生成 <code>else</code> 子句的标号，以及其中的指令序列。</li>
<li>生成 <code>if</code> 语句的结束标号。</li>
</ul>


<p>其他还有很多不同的变种，比如根据条件表达式取值的概率，或者某个架构中是否跳转的执行代价，进而调整两个子句的顺序等。不过就目前来说，上面的方法已经足够了。</p>

<p>总之，编译的方法还是很简单的，应该说就是以上所述流程的直译：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">ifelse</span> <span class="n">cond</span><span class="p">,</span> <span class="n">if_arg</span><span class="p">,</span><span class="n">else_arm</span>
</span><span class='line'>    <span class="n">compile_exp</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">testl</span><span class="se">\t</span><span class="s2">%eax, %eax&quot;</span>
</span><span class='line'>    <span class="vi">@seq</span> <span class="o">+=</span> <span class="mi">2</span>
</span><span class='line'>    <span class="n">else_arm_seq</span> <span class="o">=</span> <span class="vi">@seq</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">end_if_arm_seq</span> <span class="o">=</span> <span class="vi">@seq</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">je</span><span class="se">\t</span><span class="s2">.L</span><span class="si">#{</span><span class="n">else_arm_seq</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="n">compile_exp</span><span class="p">(</span><span class="n">if_arm</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">jmp</span><span class="se">\t</span><span class="s2">.L</span><span class="si">#{</span><span class="n">end_if_arm_seq</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;.L</span><span class="si">#{</span><span class="n">else_arm_seq</span><span class="si">}</span><span class="s2">:&quot;</span>
</span><span class='line'>    <span class="n">compile_exp</span><span class="p">(</span><span class="n">else_arm</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;.L</span><span class="si">#{</span><span class="n">end_if_arm_seq</span><span class="si">}</span><span class="s2">:&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码应该很易懂的，其实就是对所有子句 &#8211; 条件， <code>then</code> 子句，以及 <code>else</code> 子句 &#8211; 分别调用 <code>#compile_exp</code> 方法，并在其间插入所需的辅助指令，同时用 <code>@seq</code> 成员来生成所需的标号。</p>

<p>为了使其生效，我们在 <code>#compile_exp</code> 方法中的 <code>return defun ...</code> 之后插入如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">return</span> <span class="n">ifelse</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:if</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是一个简单的测试：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">prog</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:do</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:if</span><span class="p">,</span> <span class="o">[</span><span class="ss">:strlen</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;IF: The string was not empty&quot;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;ELSE: The string was empty&quot;</span><span class="o">]</span>
</span><span class='line'>  <span class="o">]</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:if</span><span class="p">,</span> <span class="o">[</span><span class="ss">:strlen</span><span class="p">,</span><span class="s2">&quot;Test&quot;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;Second IF: The string was not empty&quot;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;Second IF: The string was empty&quot;</span><span class="o">]</span>
</span><span class='line'>  <span class="o">]</span>
</span><span class='line'><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="http://www.hokstad.com/static/compiler/step5.rb">这里是最终结果</a>。</p>

<p>如往常般，执行的方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ruby step5.rb &gt;step5.s
</span><span class='line'>$ make step5
</span><span class='line'>cc   step5.s   -o step5
</span><span class='line'>$ ./step5
</span><span class='line'>ELSE: The string was empty
</span><span class='line'>Second IF: The string was not empty
</span><span class='line'>$</span></code></pre></td></tr></table></div></figure>


<h2>有关循环的一些思考</h2>

<p>非条件循环是很容易实现的，不过我们需要实现它吗？显然不需要。我们已经可以用递归来实现循环了，又何必要乱加东西呢？</p>

<p>不过，要令它工作良好，我们还需要实现尾递归优化，可是我现在还没有做好准备。尾递归优化，或者更一般的形式 &#8211; 尾调用优化 &#8211; 所说的情况是，在一个函数的末尾，调用了一个需要相同或者更少个数参数的函数，并返回它所返回的值。在这种情况下，你可以将当前函数的调用栈，复用给被调用的函数来使用，并且是通过 <code>jmp</code> 而不是 <code>call</code> 来调用这个函数。 <code>jmp</code> 指令不会在堆栈中压入一个新的返回地址，因此当这个被调用的函数返回，返回到的就是当前函数的调用者那里，而不是当前的这个函数。</p>

<p>这就同时完成了几件事情：首先，也是最重要的，就是堆栈不再会随着调用而增长了。其次，我们能够省掉几个指令周期。有了尾调用优化，再配合其他几个优化之后，你就可以这样来写循环，而不用担心堆栈溢出的问题了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="ss">:defun</span><span class="p">,</span> <span class="ss">:loop</span><span class="p">,</span> <span class="o">[]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:do</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;I am all loopy&quot;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:loop</span><span class="o">]</span>
</span><span class='line'><span class="o">]</span><span class="p">,</span>
</span><span class='line'><span class="o">[</span><span class="ss">:loop</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>换句话说，尾调用优化意味着，对任何形如 <code>(defun foo () (do bar foo))</code> 的函数来说，堆栈的使用率都会从原来的成比例增长减少为定值了。</p>

<p>当前的版本已经可以编译上面的代码了，不过它会很快用完堆栈并且崩溃掉的。不是很令人满意啊。</p>

<p>果然（原文： I sense a disturbance in the force ），两位读到这篇文章的极客都指出了堆栈增长的问题。</p>

<p>现在，让我们先忽略这个问题吧，同时注意下对堆栈空间的使用好了。之后，我们会实现一个专门的循环结构的。目前就这样吧 &#8211; 如果以后我实现了尾调用优化的话，我们还可以重新考虑在运行时库中实现一个循环构造的方案。</p>

<p>不管怎样，我们现在可以写出一个无限循环了⋯⋯不是太有用，不是吗？</p>

<p>当然，我们其实也已经可以写 <code>while</code> 循环了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cl'><span class='line'><span class="p">(</span><span class="nb">defun</span> <span class="nv">some-while-loop</span> <span class="p">()</span> <span class="p">(</span><span class="k">if</span> <span class="kt">condition</span> <span class="p">(</span><span class="nv">some-while-loop</span><span class="p">)</span> <span class="p">()))</span>
</span></code></pre></td></tr></table></div></figure>


<p>看起来不是太好，不过确实可以工作。但看起来总归还是太丑了，所以我们总归还是要实现一个正尔八经的 <code>while</code> 循环的。</p>

<p>我不是一个 Lisp 程序员。我没办法处理那么多的括号⋯⋯不过 Lisp 的语法确实很适合于一门还没有语法的语言。到了一定的阶段之后，我会实现一个完整的解析器的。也许是出于偶然，我已经实现的和将要实现的很多东西在某种程度上来说都是取自于 Lisp 的，至少看起来是这样的。如果你能适应 Lisp 的语法的话，这个语言还是非常强大的。就算你不打算用它来开发你的程序，好好地学一下这门语言也是非常值得的。</p>

<p>在我想来，很多看起来像是从 Lisp 中得来的点子，大概都是来自于我花在学习 Lisp 的有限经验。</p>

<p>下一篇：匿名函数，也许不止。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译] 用 Ruby 写编译器之四：自定义函数，以及运行时支持]]></title>
    <link href="http://glacjay.github.com/blog/2011-05-09/%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%9B%9B%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81.html"/>
    <updated>2011-05-09T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-05-09/用-ruby-写编译器之四：自定义函数，以及运行时支持</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-4.html">http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-4.html</a></p>

<p>抱歉，又拖了很长时间。要忙的事情实在很多。正如上一篇文章末尾提到的那样，这次要讲的是自定义函数，以及一个简单的“运行时库”。</p>

<h2>自定义函数</h2>

<p>一门编程语言如果连函数和方法都没有的话，那也就不能算是一门语言了。而且，实践表明，一门面向对象语言中的所有特性都可以通过过程式的语言要素来实现：一个方法也只不过是以一个对象为额外参数的函数而已。因此，增加对函数的支持就是实现一门语言的核心所在。</p>

<p>其实，这个东东也是很简单的啦。跟以前一样，还是让我们来看一下 C 语言中的函数是怎么实现的吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">puts</span><span class="p">(</span><span class="s">&quot;Hello world&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>gcc 生成的汇编代码是这个样子滴：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'><span class="nf">.globl</span> <span class="nv">foo</span>
</span><span class='line'>        <span class="nf">.type</span>   <span class="nv">foo</span><span class="p">,</span> <span class="err">@</span><span class="nv">function</span>
</span><span class='line'><span class="nl">foo:</span>
</span><span class='line'>        <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ebp</span>
</span><span class='line'>        <span class="nf">movl</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span>
</span><span class='line'>        <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">8</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
</span><span class='line'>        <span class="nf">movl</span>    <span class="kc">$</span><span class="nv">.LC0</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>        <span class="nf">call</span>    <span class="nv">puts</span>
</span><span class='line'>        <span class="nf">leave</span>
</span><span class='line'>        <span class="nf">ret</span>
</span><span class='line'>        <span class="nf">.size</span>   <span class="nv">foo</span><span class="p">,</span> <span class="nv">.</span><span class="o">-</span><span class="nv">foo</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中的函数调用现在应该很容易认了吧。剩下的就是简单的样板代码了：</p>

<p>在函数的开头，首先是将寄存器 <code>%ebp</code> 压入堆栈，然后拷贝寄存器 <code>%esp</code> 到 <code>%ebp</code> 。而在函数的最后， <code>leave</code> 指令就是前面两条指令的逆操作，而 <code>ret</code> 指令则是从堆栈中弹出要返回到的指令地址（也就是调用该函数的那条指令的下一条指令）并跳转。为什么在这里要将 <code>%esp</code> （也就是堆栈指针）拷到 <code>%ebp</code> 呢？嘛，一个很明显的好处就是你可以尽情的申请堆栈空间，然后在完事时简单地将 <code>%ebp</code> 拷回给 <code>%esp</code> 就行了。从上面就可以看到， GCC 已经充分利用了这一点，直接用 <code>leave</code> 指令来处理调用函数时对参数所申请的空间 &#8211; 反正手工释放也只是浪费时间而已。</p>

<p>这么说来的话，要做的事情应该就很简单了啊。</p>

<p>首先需要修改方法 <code>Compiler#initialize</code> ，创建一个用来保存所有函数定义的哈希：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span>
</span><span class='line'>    <span class="vi">@global_functions</span> <span class="o">=</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后增加一个输出所有函数定义的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">output_functions</span>
</span><span class='line'>    <span class="vi">@global_functions</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="p">,</span><span class="n">data</span><span class="o">|</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;.globl </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;.type   </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">, @function&quot;</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">:&quot;</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">pushl   %ebp&quot;</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">movl    %esp, %ebp&quot;</span>
</span><span class='line'>      <span class="n">compile_exp</span><span class="p">(</span><span class="n">data</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">leave&quot;</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">ret&quot;</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.size   </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">, .-</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>      <span class="nb">puts</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，这里也同时包括了 <code>.globl</code> 与 <code>.type</code> 与 <code>.size</code> 之类的东西。 <code>.globl</code> 的意思就是你想让这个函数也能够从其他文件（也就是编译单元）中调用，这在链接多个目标文件的时候是很重要的。我想 <code>.type</code> 和 <code>.size</code> 主要是用在调试的时候，分别用来表示一个符号对应的是一个函数，以及这个函数的大小。</p>

<p>除了这些之外，这个方法就很简单啦 &#8211; 它会通过调用 <code>#compile_exp</code> 方法来完成实际的工作。</p>

<p>我们再来增加一个用来定义函数的辅助方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">defun</span> <span class="nb">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">body</span>
</span><span class='line'>    <span class="vi">@global_functions</span><span class="o">[</span><span class="nb">name</span><span class="o">]</span> <span class="o">=</span> <span class="o">[</span><span class="n">args</span><span class="p">,</span> <span class="n">body</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在方法 <code>#compile_exp</code> 中增加如下的几行代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">return</span> <span class="k">if</span> <span class="o">!</span><span class="n">exp</span> <span class="o">||</span> <span class="n">exp</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'><span class="k">return</span> <span class="n">defun</span><span class="p">(</span><span class="o">*</span><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:defun</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以要增加第一行代码，一方面是出于健壮性的考虑，同时这也允许我们用 <code>nil</code> 和空数组来表示“啥也不做”的意思，当你要定义一个空函数的时候就会用到这一点了。这样一来，第二行代码就不需要去检查将要定义的是不是一个空函数了。</p>

<p>不知道你注意到了没有，我们其实已经实现了对函数的递归定义。像 <code>[:defun,:foo,[:defun, :bar, []]]</code> 这样的代码完全是合法的。同时你也许会注意到，这个实现会导致两个函数其实都是可以从别处调用的。好吧，现在是没关系的啦，我们以后会处理这个的（要么不允许编写这样的代码，要么就只允许外层函数来调用内层函数 &#8211; 我还没有决定到底要做哪个啦）。</p>

<p>剩下的事情就是输出这些函数的定义了，因此我们在方法 <code>#compile</code> 中对 <code>#output_constants</code> 的调用之前增加如下的一行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">output_functions</span>
</span></code></pre></td></tr></table></div></figure>


<h2>增加对一个运行时库的支持</h2>

<p>首先，让我们将现在的 <code>#compile</code> 方法重命名为 <code>#compile_main</code> ，然后重新定义 <code>#compile</code> 方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
</span><span class='line'>    <span class="n">compile_main</span><span class="p">(</span><span class="o">[</span><span class="ss">:do</span><span class="p">,</span> <span class="no">DO_BEFORE</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="no">DO_AFTER</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后是对常量 <code>DO_BEFORE</code> 和 <code>DO_AFTER</code> 的定义（如果愿意的话，你也可以把它们放在一个单独的文件中，我现在就直接把它们放在开头好了）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">DO_BEFORE</span><span class="o">=</span> <span class="o">[</span><span class="ss">:do</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:defun</span><span class="p">,</span> <span class="ss">:hello_world</span><span class="p">,</span><span class="o">[]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;Hello World&quot;</span><span class="o">]]</span>
</span><span class='line'><span class="o">]</span>
</span><span class='line'><span class="no">DO_AFTER</span><span class="o">=</span> <span class="o">[]</span>
</span></code></pre></td></tr></table></div></figure>


<p>你得承认，你想看到的应该是更加高级一些的东东，但那样就违背我们最初的目标了。上面的代码对于实现一个运行时库来说已经足够了。当然，你也可以用一些只能通过 C 或者汇编才能实现的东西，只要把包含那些函数实现的目标文件给链接进来就可以了，因为我们一直都是在按照 C 语言的调用规则来办事的嘛。</p>

<p>让我们来测试一下吧。在 <code>Compiler.new.compile(prog)</code> 的前面加入下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">prog</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:hello_world</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后编译运行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ruby step4.rb &gt;step4.s
</span><span class='line'>$ make step4
</span><span class='line'>cc    step4.s   -o step4
</span><span class='line'>$ ./step4
</span><span class='line'>Hello World
</span><span class='line'>$</span></code></pre></td></tr></table></div></figure>


<p>你可以在<a href="http://www.hokstad.com/static/compiler/step4.rb">这里</a>找到今天的成果。</p>

<h2>对函数参数的访问吗？</h2>

<p>今天还遗留了一个任务：实现对函数参数的访问。这个的工作量可是不小的。放心，我不会忘了这个的，这将会是第八篇文章的主题。我也不会让你等太久的啦，这次一定 :-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译] 用 Ruby 写编译器之三：语句序列，以及子表达式]]></title>
    <link href="http://glacjay.github.com/blog/2011-05-02/%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%89%EF%BC%9A%E8%AF%AD%E5%8F%A5%E5%BA%8F%E5%88%97%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <updated>2011-05-02T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-05-02/用-ruby-写编译器之三：语句序列，以及子表达式</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up---step-3.html">http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up&#8212;step-3.html</a></p>

<p><strong>我本来是想要早点发表的，可是我这周又不行了 &#8211; 虽然整理一篇旧文只需要半个小时。不管怎样，这是第三章，而且我会在末尾大概列一下之后的大纲。由于我会试着把一些小的步骤组合成更有内容的章节（下面就有个这样的例子），因此原来的 30 篇文章已经被我给减到了 20 篇左右（当然，这只是我已经完成了的，后面还有新的呢）。</strong></p>

<h2>用 do 语句将表达式给串起来</h2>

<p>到目前为止，<a href="http://www.hokstad.com/static/compiler/step2b.rb">上次的第二版程序</a>只能编译一个单独的表达式。只是这样的话，并不是非常的有用啊。因此我决定实现一种支持顺序执行的结构，就像函数体那样的。当然，如你所想，这是很简单的。我会增加一个关键字 <code>do</code> ，而其作用就是顺序执行传给它的每一个（个数不限哦，或者说，只受限于内存的大小）参数表达式。看起来就像这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">prog</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:do</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:printf</span><span class="p">,</span><span class="s2">&quot;Hello&quot;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:printf</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:printf</span><span class="p">,</span><span class="s2">&quot;World</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">]</span>
</span><span class='line'><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>要实现这个是非常简单的。我们只需要在函数 <code>#compile_exp</code> 的开头加入下列代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="ss">:do</span>
</span><span class='line'>  <span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">].</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">compile_exp</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>递归在这里的作用很重要哦 &#8211; 毕竟你是在处理一个树形结构，那也就需要在越来越深层的树结点之上调用实现编译的核心函数，而这当然也包括我们的下一个目标，即对子表达式的处理。</p>

<h2>子表达式，步骤一</h2>

<p>先来给出一个我们想要支持的用例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">prog</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:printf</span><span class="p">,</span><span class="s2">&quot;‘hello world’ takes %ld bytes</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="o">[</span><span class="ss">:strlen</span><span class="p">,</span> <span class="err">“</span><span class="n">hello</span> <span class="n">world</span><span class="s2">&quot;]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个需要改变的地方，在函数 <code>#get_arg</code> 中，我们在其开头加入如下的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Handle strings or subexpressions</span>
</span><span class='line'><span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="nb">Array</span><span class="p">)</span>
</span><span class='line'>  <span class="n">compile_exp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="kp">nil</span> <span class="c1"># What should we return?</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你这时已经试着用上面的代码来编译测试用例了的话，gcc 会报错给你的，因为我们现在只处理了 <code>#get_arg</code> 的返回值是一个字符串常量对应的序列号的情况，而这对子表达式来说显然是不适用的。</p>

<h2>子表达式，步骤二：返回值</h2>

<p>那么 gcc 是怎么处理这个的呢。让我们来看看下面这段代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;&#39;Hello world&#39; takes %ld bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">foo</span><span class="p">(</span><span class="s">&quot;Hello world&quot;</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所产生的汇编吧（只截取 <code>main</code> 中相关的部分）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'><span class="nf">subl</span>    <span class="kc">$</span><span class="mi">20</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
</span><span class='line'><span class="nf">movl</span>    <span class="kc">$</span><span class="nv">.LC0</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'><span class="nf">call</span>    <span class="nv">foo</span>
</span><span class='line'><span class="nf">movl</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'><span class="nf">movl</span>    <span class="kc">$</span><span class="nv">.LC1</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'><span class="nf">call</span>    <span class="nv">printf</span>
</span><span class='line'><span class="nf">addl</span>    <span class="kc">$</span><span class="mi">20</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
</span></code></pre></td></tr></table></div></figure>


<p>应该说还是很直观的吧。gcc 首先会去调用子表达式（ <code>foo</code> ），并且希望这个函数能够把它的返回值放入寄存器 <code>%eax</code> 中，然后就会把这个值作为参数拷到堆栈上，而不是什么字符串常量的地址。</p>

<p>首先是要调整 <code>#get_arg</code> 函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">get_arg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># Handle strings and subexpressions</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="nb">Array</span><span class="p">)</span>
</span><span class='line'>      <span class="n">compile_exp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">[</span><span class="ss">:subexpr</span><span class="o">]</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="n">seq</span> <span class="o">=</span> <span class="vi">@string_constants</span><span class="o">[</span><span class="n">a</span><span class="o">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">seq</span> <span class="k">if</span> <span class="n">seq</span>
</span><span class='line'>    <span class="n">seq</span> <span class="o">=</span> <span class="vi">@seq</span>
</span><span class='line'>    <span class="vi">@seq</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="vi">@string_constants</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">seq</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">[</span><span class="ss">:strconst</span><span class="p">,</span><span class="n">seq</span><span class="o">]</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>唯一需要改动的地方就是返回值了，我们增加了一个表示返回值类型的标识 &#8211; 以后还会加入其他类型的。</p>

<p>剩下的工作就是改写 <code>#compile_exp</code> 函数中的相关部分了。这时就不能直接收集 <code>#get_arg</code> 的返回值了，而是需要对每个参数都做相应的处理并直接输出（而这同时也是 <code>stack_adjustment</code> 需要修改的原因，因为已经没有 <code>args</code> 数组了）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">stack_adjustment</span> <span class="o">=</span> <span class="no">PTR_SIZE</span> <span class="o">+</span> <span class="p">(((</span><span class="n">exp</span><span class="o">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">.</span><span class="mi">0</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="p">))</span><span class="o">.</span><span class="n">round</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="p">)</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">subl</span><span class="se">\t</span><span class="s2">$</span><span class="si">#{</span><span class="n">stack_adjustment</span><span class="si">}</span><span class="s2">, %esp&quot;</span> <span class="k">if</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">!=</span> <span class="ss">:do</span>
</span><span class='line'>
</span><span class='line'><span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">].</span><span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>  <span class="n">atype</span><span class="p">,</span> <span class="n">aparam</span> <span class="o">=</span> <span class="n">get_arg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">!=</span> <span class="ss">:do</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">atype</span> <span class="o">==</span> <span class="ss">:strconst</span>
</span><span class='line'>      <span class="n">param</span> <span class="o">=</span> <span class="s2">&quot;$.LC</span><span class="si">#{</span><span class="n">aparam</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">param</span> <span class="o">=</span> <span class="s2">&quot;%eax&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">movl</span><span class="se">\t</span><span class="si">#{</span><span class="n">param</span><span class="si">}</span><span class="s2">,</span><span class="si">#{</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">?</span> <span class="n">i</span><span class="o">*</span><span class="mi">4</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="si">}</span><span class="s2">(%esp)&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>如你所见，并不是什么复杂的更改。我们只是检查了 <code>#get_arg</code> 所返回的类型信息，并相应的输出字符串常量或者寄存器 <code>%eax</code> 而已。随着我们加入更多要处理的情况，这个部分代码还会继续扩充的。</p>

<p><a href="http://www.hokstad.com/static/compiler/step3.rb">你可以在这里找到最新版本的代码</a>。</p>

<h2>之后的计划</h2>

<p>这里只列出的基本完成的部分。我的计划是，当我开始着手写新的部分时，我会将重心放在一个简单的解析器上，以尽快实现编译器的自举（即，编译它自己）。</p>

<ul>
<li>步骤四：运行时，以及函数的定义</li>
<li>步骤五：处理其他类型的常量值</li>
<li>步骤六：条件表达式 <code>if ... then ... else</code></li>
<li>步骤七：循环语句</li>
<li>步骤八：匿名函数（ <code>lambda</code> ）</li>
<li>步骤九：用匿名函数来实现循环，以及对函数参数的处理</li>
<li>步骤十：赋值，以及简单的代数运算</li>
<li>步骤十一：更简结的 <code>while</code> 循环</li>
<li>步骤十二：测试我们的语言：开发一个简单的输入转换模块</li>
<li>步骤十三：重构代码生成模块，并抽象出平台相关的部分</li>
<li>步骤十四：对一些概念的讨论，以及今后的前进方向</li>
<li>步骤十五：数组</li>
<li>步骤十六：局部变量以及多种作用域</li>
<li>步骤十七：可变长参数列表</li>
<li>步骤十八：再看输入转换模块：测试新的功能点，以及自我转换</li>
<li>步骤十九：确定自举所需要实现的功能</li>
<li>步骤二十：开始实现真正的解析器</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译] 用 Ruby 写编译器之二：函数调用，以及 Hello World]]></title>
    <link href="http://glacjay.github.com/blog/2011-04-29/%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%8C%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BB%A5%E5%8F%8A-hello-world.html"/>
    <updated>2011-04-29T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-04-29/用-ruby-写编译器之二：函数调用，以及-hello-world</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-2.html">http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-2.html</a></p>

<p>我会选择 Ruby 来作为我的实现语言并没有什么特别的理由。在现阶段，语言的选择并不重要；不过，我确实很喜欢 Ruby。</p>

<p>在这之后，我会采取一系列的步骤令所实现的语言向其实现语言靠拢。我的意思是，我想将编译器实现为可以<strong>自举</strong>的，即它应该能够编译自身。</p>

<p>而这也就意味着，要么我的编译器需要至少支持 Ruby 语言的一个子集，要么就需要一个中间的翻译步骤，来将编译器中的实现翻译成它自己可以编译的语言。</p>

<p>虽然这一点并没有限制你所用的实现语言，但那至少意味着你用来实现的语言跟你要实现的语言之间很相似，除非你对实现编译器的自举没有什么兴趣。</p>

<p>这也同时意味着，如果你想实现编译器的自举，那你最好不要用实现语言中的什么复杂的特性。要记住，你得实现所有你用过的那些语言特性，不然，当你要开始做自举的时候，你就得对整个编译器的架构做大的调整了。那一点都不好玩。</p>

<p>话说回来，使用 Ruby 来作为实现语言的一大优点（同样对于其他某些语言来说也是这样，比如说 Lisp ），就是你可以很容易地构建出一个树形的数据结构出来 &#8211; Ruby 的话就是用数组或者哈希， Lisp 的话就是用列表。</p>

<p>这也就是说，我可以用数组来手工构建抽象语法树，从而避免了实现一个语法分析器的工作。耶！代价就是很丑，不过也可以接受的语法啦。</p>

<h2>Hello World</h2>

<p>Hello World 的话看起来会是这个样子的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="ss">:puts</span><span class="p">,</span> <span class="s2">&quot;Hello World&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，我们需要处理的东西非常简单：我们需要将一个参数压入堆栈，然后调用一个函数。</p>

<p>那么就让我们来看一下怎样用 x86 汇编来做这件事吧。我用 <code>gcc -S</code> 编译了下面的这段 C 程序：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">puts</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后看看输出会是什么样子的。下面给出的是真正相关的部分，是与上一次的输出比较之后的结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'>    <span class="nf">.section</span>        <span class="nv">.rodata</span>
</span><span class='line'><span class="nl">.LC0:</span>
</span><span class='line'>    <span class="nf">.string</span> <span class="s">&quot;Hello World&quot;</span>
</span><span class='line'>    <span class="nf">.text</span>
</span><span class='line'><span class="nf">...</span>
</span><span class='line'>    <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="nv">.LC0</span><span class="p">,</span> <span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">puts</span>
</span><span class='line'>    <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
</span><span class='line'><span class="nf">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你懂一些汇编的话，就算以前没有写过 x86 的汇编程序，也应该可以很容易的看懂这段代码吧：</p>

<ul>
<li>这里首先定义了一个字符串常量。</li>
<li>通过对堆栈指针的减 <code>4</code> 操作，在堆栈上申请了一段 <code>4</code> 个字节大小的空间。</li>
<li>然后将之前定义的字符串常量的地址，放入刚刚申请的那 <code>4</code> 个字节的空间中。</li>
<li>接着，我们调用了由 glibc 提供的 <code>puts</code> 函数（在这个系列中，我会假设你已经有了 gcc/gas + glibc ；Linux 的话这些东东应该已经有了）。</li>
<li>最后，通过一个加 <code>4</code> 操作来释放堆栈空间。</li>
</ul>


<p>那么，我们要怎样在我们的编译器中实现这一切呢？首先，我们需要一种方法来处理那些字符串常量，通过在上次的 Compiler 类的实现中添加下面的代码（我的所有 Ruby 代码都在<a href="http://www.hokstad.com/static/compiler/step2.rb">这里</a>，这样你就知道该做什么了）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span>
</span><span class='line'>    <span class="vi">@string_constants</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>    <span class="vi">@seq</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">get_arg</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># For now we assume strings only</span>
</span><span class='line'>    <span class="n">seq</span> <span class="o">=</span> <span class="vi">@string_constants</span><span class="o">[</span><span class="n">a</span><span class="o">]</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">seq</span> <span class="k">if</span> <span class="n">seq</span>
</span><span class='line'>    <span class="n">seq</span> <span class="o">=</span> <span class="vi">@seq</span>
</span><span class='line'>    <span class="vi">@seq</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="vi">@string_constants</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">seq</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">seq</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码就是简单地将一个字符串常量映射到一个整数上，而这个整数则对应着一个标号。相同的字符串常量会对应到相同的整数上，因此也只会被输出一次。用哈希而不是数组来保证这种唯一性是一种很常用的优化手段，不过也不一定非要这样做。</p>

<p>下面这个函数是用来输出所有的字符串常量的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">output_constants</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.section</span><span class="se">\t</span><span class="s2">.rodata&quot;</span>
</span><span class='line'>    <span class="vi">@string_constants</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="p">,</span><span class="n">seq</span><span class="o">|</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;.LC</span><span class="si">#{</span><span class="n">seq</span><span class="si">}</span><span class="s2">:&quot;</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">.string </span><span class="se">\&quot;</span><span class="si">#{</span><span class="n">c</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后剩下的就是编译函数调用的代码了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">compile_exp</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
</span><span class='line'>    <span class="n">call</span> <span class="o">=</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_s</span>
</span><span class='line'>    <span class="n">args</span> <span class="o">=</span> <span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">].</span><span class="n">collect</span> <span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">get_arg</span><span class="p">(</span><span class="n">a</span><span class="p">)}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">subl</span><span class="se">\t</span><span class="s2">$4,%esp&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">args</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">movl</span><span class="se">\t</span><span class="s2">$.LC</span><span class="si">#{</span><span class="n">a</span><span class="si">}</span><span class="s2">,(%esp)&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">call</span><span class="se">\t</span><span class="si">#{</span><span class="n">call</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">addl</span><span class="se">\t</span><span class="s2">$4, %esp&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>也许你已经注意到这里的不一致性了：上面的代码虽然好像是可以处理多参数调用的样子，但却只从堆栈中减掉了一个 <code>4</code> ，而不是按照实际的参数个数而进行相应的调整，从而导致了不同参数间的相互覆盖。</p>

<p>我们马上就会处理这个问题的。对于我们简单的 Hello World 程序来说，目前这样已经足够了。</p>

<p>在这段代码中还有几点需要注意：</p>

<ul>
<li>我们甚至都还没有检查被调用的函数到底存不存在 &#8211; gcc/gas 会帮我们处理这个问题的，虽然这也意味着没啥帮助的错误信息。</li>
<li>我们可以调用任何一个可以连接的函数，只要这个函数只需一个字符串作为参数。</li>
<li>这段代码目前还有很多需要被抽像出去的地方，比如说得到被调函数地址的方法，还有所有那些硬编码进来的 x86 汇编等。相信我，我会（慢慢）解决这些问题的。</li>
</ul>


<p>现在我们可以来<a href="http://www.hokstad.com/static/compiler/step2.rb">试着运行一下这个编译器</a>了。你应该会得到下面这样的输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='nasm'><span class='line'>    <span class="nf">.text</span>
</span><span class='line'><span class="nf">.globl</span> <span class="nv">main</span>
</span><span class='line'>    <span class="nf">.type</span>   <span class="nv">main</span><span class="p">,</span> <span class="err">@</span><span class="nv">function</span>
</span><span class='line'><span class="nl">main:</span>
</span><span class='line'>    <span class="nf">leal</span>    <span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">esp</span><span class="p">),</span> <span class="o">%</span><span class="nb">ecx</span>
</span><span class='line'>    <span class="nf">andl</span>    <span class="kc">$</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
</span><span class='line'>    <span class="nf">pushl</span>   <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">ecx</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ebp</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="o">%</span><span class="nb">esp</span><span class="p">,</span> <span class="o">%</span><span class="nb">ebp</span>
</span><span class='line'>    <span class="nf">pushl</span>   <span class="o">%</span><span class="nb">ecx</span>
</span><span class='line'>    <span class="nf">subl</span>    <span class="kc">$</span><span class="mi">4</span><span class="p">,</span><span class="o">%</span><span class="nb">esp</span>
</span><span class='line'>    <span class="nf">movl</span>    <span class="kc">$</span><span class="nv">.LC0</span><span class="p">,(</span><span class="o">%</span><span class="nb">esp</span><span class="p">)</span>
</span><span class='line'>    <span class="nf">call</span>    <span class="nv">puts</span>
</span><span class='line'>    <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="nb">esp</span>
</span><span class='line'>    <span class="nf">popl</span>    <span class="o">%</span><span class="nb">ecx</span>
</span><span class='line'>    <span class="nf">popl</span>    <span class="o">%</span><span class="nb">ebp</span>
</span><span class='line'>    <span class="nf">leal</span>    <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">ecx</span><span class="p">),</span> <span class="o">%</span><span class="nb">esp</span>
</span><span class='line'>    <span class="nf">ret</span>
</span><span class='line'>    <span class="nf">.size</span>   <span class="nv">main</span><span class="p">,</span> <span class="nv">.</span><span class="o">-</span><span class="nv">main</span>
</span><span class='line'>    <span class="nf">.section</span>        <span class="nv">.rodata</span>
</span><span class='line'><span class="nl">.LC0:</span>
</span><span class='line'>    <span class="nf">.string</span> <span class="s">&quot;Hello World&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面来测试一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[vidarh@dev compiler]$ ruby step2.rb &gt;hello.s
</span><span class='line'>[vidarh@dev compiler]$ gcc -o hello hello.s
</span><span class='line'>[vidarh@dev compiler]$ ./hello
</span><span class='line'>Hello World
</span><span class='line'>[vidarh@dev compiler]$</span></code></pre></td></tr></table></div></figure>


<h2>那么，要怎么处理多个参数的情况呢？</h2>

<p>我不会再展示用来说明的 C 代码和对应的汇编代码了 &#8211; 进行不同参数个数的调用并查看其输出对你来说应该不难。相反，我就直接给出对 compile_exp 函数所做的修改了（完整的代码在<a href="http://www.hokstad.com/static/compiler/step2b.rb">这里</a>）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="no">PTR_SIZE</span><span class="o">=</span><span class="mi">4</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">compile_exp</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
</span><span class='line'>    <span class="n">call</span> <span class="o">=</span> <span class="n">exp</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_s</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">args</span> <span class="o">=</span> <span class="n">exp</span><span class="o">[</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="o">].</span><span class="n">collect</span> <span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">get_arg</span><span class="p">(</span><span class="n">a</span><span class="p">)}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># gcc on i386 does 4 bytes regardless of arguments, and then</span>
</span><span class='line'>    <span class="c1"># jumps up 16 at a time, We will blindly do the same.</span>
</span><span class='line'>    <span class="n">stack_adjustment</span> <span class="o">=</span> <span class="no">PTR_SIZE</span> <span class="o">+</span> <span class="p">(((</span><span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">+</span><span class="mi">0</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">.</span><span class="mi">0</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="p">))</span><span class="o">.</span><span class="n">round</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="no">PTR_SIZE</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">subl</span><span class="se">\t</span><span class="s2">$</span><span class="si">#{</span><span class="n">stack_adjustment</span><span class="si">}</span><span class="s2">, %esp&quot;</span>
</span><span class='line'>    <span class="n">args</span><span class="o">.</span><span class="n">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">|</span>
</span><span class='line'>      <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">movl</span><span class="se">\t</span><span class="s2">$.LC</span><span class="si">#{</span><span class="n">a</span><span class="si">}</span><span class="s2">,</span><span class="si">#{</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">?</span> <span class="n">i</span><span class="o">*</span><span class="no">PTR_SIZE</span> <span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="si">}</span><span class="s2">(%esp)&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">call</span><span class="se">\t</span><span class="si">#{</span><span class="n">call</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">addl</span><span class="se">\t</span><span class="s2">$</span><span class="si">#{</span><span class="n">stack_adjustment</span><span class="si">}</span><span class="s2">, %esp&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里做了什么呢？改动的地方没几个：</p>

<ul>
<li>这里不再是申请固定大小的堆栈空间了（上一个版本中是 <code>4</code> 个字节），而是根据实际参数的个数来相应的调整堆栈指针。我得承认，我不知道 gcc 为什么会做这样的调整 &#8211; 而且原因并不重要，虽然我猜这是为了堆栈的对齐。优化和清理<strong>以后</strong>再说，并且，当你不知道某事的运行机理时，那就不要去改变它。</li>
<li>这之后，如你所见，参数被一个一个地放到堆栈上了。我们还是假定它们全都是相同大小的指针（因此在 x86 上就是 <code>4</code> 个字节）。</li>
<li>同时你还可以看到，第一个参数是被放在堆栈中最靠下的位置的。如果你还没有写过汇编程序，并且无法想象出这是怎么回事的话，那就把它们画出来吧；还要记住，这里的堆栈是向下扩展的。当申请空间时，我们是将堆栈指针向下移动的，而拷贝参数时则是从下往上（用越来越大的索引来访问 <code>%esp</code> ，就像你访问数组时一样）。</li>
</ul>


<p>这个编译器现在已经可以编译下面这样的代码了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span><span class="ss">:printf</span><span class="p">,</span><span class="s2">&quot;Hello %s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">&quot;World&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>至于以后嘛</h2>

<p>这就是我们踏出的第一步，而且我保证之后的步骤会越来越实际的，因为只要实现很少的几个功能点，我们就可以编译实际的程序了。而且我会努力令这些步骤更加精炼，更多的说明这样做的原因，而不是仅仅解释做了什么。</p>

<p>下面我会处理多个参数的调用（译者：我们不是才处理过嘛），然后是语句序列、子表达式，以及对返回值的处理，等等。</p>

<p>大约十二个这样难度的步骤之后，我们就会完成函数定义、参数传递、条件判断、运行时库，甚至是一个用来实现匿名函数的简单的 lambda （真正的<a href="http://en.wikipedia.org/wiki/Closure_(computer_science)">闭包</a>就要到后面了）。</p>

<p>再之后，我们会实现一个简单的文本处理程序，来对一个比 Ruby 的数组和符号更好一点的语法提供支持（只是某种程度啦，真正的语法分析得再多等等）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译] 用 Ruby 写编译器之一：一个简单的 main 函数模板]]></title>
    <link href="http://glacjay.github.com/blog/2011-04-11/%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%80.html"/>
    <updated>2011-04-11T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-04-11/用-ruby-写编译器之一</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-1.html">http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-1.html</a></p>

<p>[译者抱怨：翻译好麻烦啊。]</p>

<p>我已经将这件事情搁置了很长时间了 &#8211; 这个系列中最早的文章甚至可以追溯到 2005 年的早期，而那时我还没有开始写这个博客呢。</p>

<p>我灰常喜欢编译器技术，而且我也已经写过好几个小型的编译器了。不久前我开始用 Ruby 语言写一个简单的编译器，而且我也以发表为目的记下了大量的笔记。问题在于，当我一步步地完成这个系列文章的时候，我的博客却渐渐地，没落了（？原文： Problem was I was that by the time I was finishing up the steps I have so far, my blog was languishing, and so it&#8217;s been just gathering dust. 啊，我的英文好渣）。</p>

<p>我已经写完了大概 30 篇文章，并形成了一个简单但是可以工作的编译器。我也许要花上一段时间来发表它们，因为这些文章均需要一定程度的整理，而且我能花在写作上的时间不是很多。不过根据具体的时间安排，我也有可能一周就发表好几篇。</p>

<p>闲话少叙，第一篇参上：</p>

<h2>有关一些背景，以及一小段代码</h2>

<p>通常，在开始尝试编写一个编译器时，我会选择自顶向下的开发方式。换句话说就是，我会采取常见的策略，从设计一个语法分析器开始，而不管这个分析器是手写的，还是通过分析器生成器来生成。然后我会通过一系列的树形结构转换程序将 <code>AST</code>（即 <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree，抽象语法树</a>）转化为符号表，同时进行错误检查，为树结点附加各类信息，并最终进行代码生成的步骤。在我转而使用 Linux 之后，我在这里就会选择生成 C 代码，前提是你的语言能够很好的契合 C 的语意。从这里也可以看出，C 是一门多么低层的语言了。</p>

<p>不过，我的第一个编译器是用 M68000 汇编语言写的，而且其输出也是 M68000 的汇编程序。</p>

<p>我是从允许内嵌的汇编代码片断开始<a href="http://en.wikipedia.org/wiki/Bootstrapping_(compilers)">自举</a>这个编译器的，并在此基础上逐步地增加所支持的语法结构。</p>

<p>首先我加入了对函数的定义以及调用的支持，并以此为基础构建我的整个编译器。然后我会增加基于寄存器的基本四则运算的支持，然后是局部变量，等等等等，但在同时也会解析汇编，以保证当遇到内嵌汇编代码片段中的寄存器时，还能够保持寄存器分配器的简洁（原文： but parse the assembly so that the register allocator would stay clear of registers used in the assembler that was interspersed. ）。</p>

<p>然后这个编译器就从编译汇编语言的语法，逐渐演变成编译我所设计的杂牌语言的语法，其中的汇编也越来越少。</p>

<p>我想再自举一个编译器出来。不过这次我就不打算用汇编来实现它了。这次我会<strong>从底层 &#8211; 也就是代码生成器 &#8211; 开始</strong>。并且我会完成如下几个目标：</p>

<ul>
<li><strong>实现的简洁性优先于其性能。</strong>要点在于，我希望能够将它重写为以其自身来实现。换句话说，我希望它能够实现自举（ self hosted ，跟 bootstrap 有啥区别呢？）。由于开始的代码最终会被替换掉，那么也就没有必要浪费时间在使它可以运行的更快上面。性能问题大可以以后再考虑。</li>
<li><strong>不要做限制性能的决定。</strong>虽然性能并不是我们最初的目标，但也不能太大意，而导致今后不好对此进行改进。 Ruby ，说的就是你（ Ruby 的运行时非常的动态）。</li>
<li><strong>实现的简洁性优先于惯例。</strong>不要仅仅因为一个特性很方便就去实现它，而仅实现那些可以帮助我们完成对编译器的自举的特性。而这就意味着，这些特性要能使我们的生活更加方便，而不仅仅是无谓地增加了实现编译器本身的难度。</li>
<li><strong>不要急着设计语言，我们要设计的是特性。</strong>我想首先实现一个灵活而强大的代码生成器，以及一个可以支持各种功能的简洁的 <code>AST</code> 。我的意思是像 Lisp 语言那样极富表达能力的语法结构，并尽量用 Ruby 来达到相似的目标（这段翻的太渣了，请参考原文）。</li>
<li><strong>我并不想深入学习 x86 的汇编语言，虽然我会以其作为我的目标语言。</strong>这样说有点夸张。我很熟悉 M68K 和 6510 的汇编语言，同时我也具备足够的知识来阅读 x86 的汇编程序。虽然我从来没有用它写过什么像样的代码，而且我也不打算这么做。我所需要知道的一切信息都来自于查看 gcc 产生的汇编输出。要善用 <code>gcc -S</code> 命令。虽然可能对 x86 的某些细节存在疑问，但我所具备的基础汇编知识已经足够我理解那些个汇编代码了。虽然在此过程中，我很可能会犯一些很愚蠢的错误，但我同时也可以从中学到很多知识（而且那些非常相信能够从我这里学到相关知识的人们也请注意了 - 我在这方面也只是个初学者哦）。</li>
</ul>


<p>听起来之后貌似会抄很多的小道，同时也会遇到很多痛苦的地方，不是吗？但这同时也会非常有趣哦！</p>

<p>不管怎样，我们先从一段没什么实际用处的代码开始吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#!/bin/env ruby</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Compiler</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># Taken from gcc -S output</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="o">&lt;&lt;</span><span class="no">PROLOG</span>
</span><span class='line'><span class="sh"> .file &quot;bootstrap.rb&quot;</span>
</span><span class='line'><span class="sh"> .text</span>
</span><span class='line'><span class="sh">.globl main</span>
</span><span class='line'><span class="sh"> .type main, @function</span>
</span><span class='line'><span class="sh">main:</span>
</span><span class='line'><span class="sh"> leal 4(%esp), %ecx</span>
</span><span class='line'><span class="sh"> andl $-16, %esp</span>
</span><span class='line'><span class="sh"> pushl -4(%ecx)</span>
</span><span class='line'><span class="sh"> pushl %ebp</span>
</span><span class='line'><span class="sh"> movl %esp, %ebp</span>
</span><span class='line'><span class="sh"> pushl %ecx</span>
</span><span class='line'><span class="no">PROLOG</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">puts</span> <span class="o">&lt;&lt;</span><span class="no">EPILOG</span>
</span><span class='line'><span class="sh"> popl %ecx</span>
</span><span class='line'><span class="sh"> popl %ebp</span>
</span><span class='line'><span class="sh"> leal -4(%ecx), %esp</span>
</span><span class='line'><span class="sh"> ret</span>
</span><span class='line'><span class="no">EPILOG</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">puts</span> <span class="o">&lt;&lt;</span><span class="no">GLOBAL_EPILOG</span>
</span><span class='line'><span class="sh"> .size main, .-main</span>
</span><span class='line'><span class="no">GLOBAL_EPILOG</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">prog</span> <span class="o">=</span> <span class="o">[</span><span class="ss">:puts</span><span class="p">,</span><span class="s2">&quot;Hello World&quot;</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="no">Compiler</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>说实话，这段代码嘛也没做。它只是把用 <code>gcc -S</code> 命令将下面这段代码编译出来的结果拆吧拆吧之后给打印出来了而已：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这可是一个完整可工作的编译器哟 &#8211; 某种程度上来说吧。不幸地是，不管用它编译什么程序，得到的都只是一段毫无用处的代码，因些可以说它本身也是同样毫无用处的。但我们总要踏出这最初的一步。</p>

<p>你可以认为这个系列的文章是我的“意识流”。我做这件事仅仅是因为好玩而已。我并没打算坐下来，好好地完成一个多么赞的设计。我甚至会因为一时兴起而把一段代码给丢掉，或者之后又把它给找回来。</p>

<p>你在这里将要看到的其实已经是我第二次的代码了：我所做的每一个 SVN 提交都对应于我的一篇文章，不过我会在文章中做很多额外的讲解。有时这些讲解会令我中途改变主意 &#8211; 但我不会对代码做太大的修改，除非我认为这个修改能令我的讲解更清晰，或者我一开始完全就想错掉了。就算是这样，我也多半不会做出修改，除了在那边标注一下我会在之后解决。有些时候，我也会把几个我做起来很麻烦，但解释起来又很简单的步骤合而为一。</p>

<p>我在这里欢迎大家涌跃发言。不过要记住，虽然我会十分留意您的发言，但我已经完成了这个系列中的很大一部分，我不会因为某些意见而完全重写这些文章。不过我会留下一些笔记，并同时记住我之前都写了些什么内容。</p>

<p>下次我会让这个编译器真正去处理它的输入的，我保证。</p>

<p>[译者再次抱怨：翻译好麻烦啊。]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[翻译] 用 Ruby 写编译器之零]]></title>
    <link href="http://glacjay.github.com/blog/2011-04-10/%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E9%9B%B6.html"/>
    <updated>2011-04-10T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-04-10/用-ruby-写编译器之零</id>
    <content type="html"><![CDATA[<p>这是一个国外的编译器达人写的一系列教程，内容为用 Ruby 语言，以自底向上的方式开发一个 Ruby 语言的编译器。这个教程非常适合于实战派的程序员。该教程的入口见<a href="http://www.hokstad.com/compiler">这里</a>，其代码见<a href="https://github.com/vidarh/writing-a-compiler-in-ruby">这里</a>。</p>

<p>我会试着翻译一下这个教程。由于这个项目之后又有了很大的进展，而教程本身却又已经很久没有更新了，所以之后我可能也会自己总结一下那些最新的开发工作。</p>

<p>使用版本管理软件的好处之一，就是你可以一步一步的学习一个软件的开发过程。不过这个项目用的是 Git，貌似不支持直接将 Working Tree 检出到历史上的某一个版本，所以我就新建了一个分支，然后将主干上的提交一个一个地 merge 到这个新的分支上，这样就可以一个提交一个提交的按顺序把玩这个编译器了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[总结一下学到的 LVS 相关知识（ DR 模式）]]></title>
    <link href="http://glacjay.github.com/blog/2011-03-13/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88-dr-%E6%A8%A1%E5%BC%8F%EF%BC%89.html"/>
    <updated>2011-03-13T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-03-13/总结一下学到的-lvs-相关知识（-dr-模式）</id>
    <content type="html"><![CDATA[<p>不喜欢看长的 Blog 文间，当然更不喜欢写，所以就分开写啦。另，因为 TUN 模式限制更多，实际很可能用不到，所以不一定会写。</p>

<p>所以这次要讲的是 DR 模式的负载均衡啦。 DR 模式，也就是 Direct Route ，其基本原理就是不对包做任何处理，直接转给所分配的真实服务；回包则由真实服务直接发给客户端而不走负载机。因为不像 NAT 模式那样有相似的架构可以参考，所以这次就上图来说明啦（注，该图偷自<a href="http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/LVS-HOWTO.LVS-DR.html">这里</a>）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>                           ________
</span><span class='line'>                          |        |
</span><span class='line'>                          | client |
</span><span class='line'>                          |________|
</span><span class='line'>                          CIP=192.168.1.254
</span><span class='line'>                              |
</span><span class='line'>                   CIP-&gt;VIP | |
</span><span class='line'>                            v |
</span><span class='line'>                              |
</span><span class='line'>                           ________
</span><span class='line'>                          |        |
</span><span class='line'>                          | router | advertises route to VIP
</span><span class='line'>                          |________|
</span><span class='line'>                              |
</span><span class='line'>                __________    |
</span><span class='line'>               |          |   |    VIP=192.168.1.110 (eth0:0, arps)
</span><span class='line'>               | director |---+     DIP=192.168.1.1 (eth0)
</span><span class='line'>               |__________|   |
</span><span class='line'>                              |  ^
</span><span class='line'>MAC_DIP-&gt;MAC_RIP1(CIP-&gt;VIP) | |  |  VIP-&gt;CIP
</span><span class='line'>                            v |
</span><span class='line'>                              |
</span><span class='line'>             +----------------+------------------+
</span><span class='line'>             |                |                  |
</span><span class='line'>             |                |                  |
</span><span class='line'>      RIP1=192.168.1.2  RIP2=192.168.1.3  RIP3=192.168.1.4 (eth0)
</span><span class='line'>      VIP=192.168.1.110 VIP=192.168.1.110 VIP=192.168.1.110 (all lo:0, non-arping)
</span><span class='line'>      _____________     _____________      _____________
</span><span class='line'>     |             |   |             |    |             |
</span><span class='line'>     |   CIP-&gt;VIP  |   |             |    |             |
</span><span class='line'>     |   VIP-&gt;CIP  |   |             |    |             |
</span><span class='line'>     | realserver  |   | realserver  |    | realserver  |
</span><span class='line'>     |_____________|   |_____________|    |_____________|
</span><span class='line'></span></code></pre></td></tr></table></div></figure>


<p>首先，负载机（即图中的 <code>director</code> ）需要将服务发布地址配置成网卡的从地址 <code>VIP</code>（我还不太清楚为什么不能直接配成第一地址），以便接收来自客户端的 IP 报文。然后，它会根据分配置策略选择一个真实服务器（即图中的 <code>realserver</code> ），并将这个 IP 报文直接转发过去，而这就需要真实服务器也有一个从地址配置成 <code>VIP</code> （一般都配到 <code>lo</code> 网口上）。可是，大家都是在一个网段的，如果没有什么措施的话，那一开始来自客户端的目的地址为 <code>VIP</code> 的 IP 报文就不知道要由谁来处理了。所以，在真实服务器上都要把 <code>lo</code> 这个网卡的 ARP 广播与响应功能给禁掉，让客户端不知道真实服务器也有 <code>VIP</code> 这个地址。而负载机则是通过真实服务器的真实地址（非 <code>VIP</code> ）得知它的 MAC 地址，进而进行转发的。</p>

<p>而当真实服务器需要往回发报文的时候，因为与客户端之间并不像 NAT 那样不在同一网段，也没有被负载机隔来，所以回应报文就通过正常途径直接到了客户端的手（网口？）中。</p>

<p>这样一来，相比 NAT 模式而言，其额外的配置工作主要就是 <code>VIP</code> 从地址的配置以及 ARP 相关功能的禁用了。让我们一步一步来吧。首先是负载机的 <code>VIP</code> 配置（真实地址的配置就跟正常的一样，不写了）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ifconfig eth0:0 192.168.1.110 broadcast 192.168.1.110 netmask 255.255.255.255
</span><span class='line'>$ sudo route add -host 192.168.1.110 eth0:0</span></code></pre></td></tr></table></div></figure>


<p>然后是真实服务器的 <code>VIP</code> 配置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ifconfig lo:0 192.168.1.110 broadcast 192.168.1.110 netmask 255.255.255.255
</span><span class='line'>$ sudo route add -host 192.168.1.110 eth0:0</span></code></pre></td></tr></table></div></figure>


<p>与负载机唯一不同的就是要把地址配到 <code>lo</code> 上。接下来是禁掉这个网卡的 ARP 相关的功能（这里就用不了 <code>sudo</code> 了，必须直接用 <code>root</code> 用户，不知道为嘛）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># echo 1 &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
</span><span class='line'># echo 2 &gt; /proc/sys/net/ipv4/conf/lo/arp_announce
</span><span class='line'># echo 1 &gt; /proc/sys/net/ipv4/conf/all/arp_ignore
</span><span class='line'># echo 2 &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span></code></pre></td></tr></table></div></figure>


<p>当然更好的办法是修改 <code>/etc/sysctl.conf</code> 文件，然后执行 <code>sysctl -p</code> 命令来使修改生效。这样做的好处是配置被保存下来了，下次开机还有效，而且也可以用 <code>sudo</code> 来做。</p>

<p>地址配完了，最后就是 ipvsadm 本身的配置了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ipvsadm -A -t 192.168.1.110:22 -s rr
</span><span class='line'>$ sudo ipvsadm -a -t 192.168.1.110:22 -r 192.168.1.2:22 -g
</span><span class='line'>$ sudo ipvsadm -a -t 192.168.1.110:22 -r 192.168.1.3:22 -g
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>嗯，跟 NAT 模式唯一的不同就是 <code>-g</code> 选项，表示 DR 模式。因为是默认选项，所以不写 <code>-g</code> 也可以。</p>

<p>TCP 服务的话这样就可以了，可是 UDP 服务却还有一些问题需要解决。正如上面所说，服务端发给客户端的回包是不经过负载的，这样的话，如果这个服务程序没有绑定到特定网卡的话，这个回包的源地址默认就是服务器本身的真实地址（如 <code>192.168.1.2</code> ）了，而这样的回包一般是不会被客户端所接受的，因为客户端当初可是往 <code>VIP</code> 这个地址发的请求包。而最通用的解决方法就是将该服务显式绑定到 <code>VIP</code> 这个地址上，强迫其回包的源地址为 <code>VIP</code> ，而这正是客户端所希望看到的。</p>

<p>由上可知，DR 模式相对 NAT 模式而言，对真实服务器来说就是侵入式的配置方式，增加了不少配置工作和限制，而其性能方面的优势据说在现在也大大降低了。因此一般应用的话，直接用 NAT 模式就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[总结一下学到的 LVS 相关知识（ NAT 模式）]]></title>
    <link href="http://glacjay.github.com/blog/2011-03-12/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88-nat-%E6%A8%A1%E5%BC%8F%EF%BC%89.html"/>
    <updated>2011-03-12T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-03-12/总结一下学到的-lvs-相关知识（-nat-模式）</id>
    <content type="html"><![CDATA[<p>LVS，即 Linux Virtual Server 的简称，是 Linux 下用来实现负载均衡的一个项目。它支持三种负载模式，分别为 NAT 、 DR 以及 TUN 。</p>

<p>注意，我这里讲的都是针对的 2.6 的内核， 2.4 、 2.2 、 2.0 版内核的实现方法和配置方法都各有不一样的地方。还好我不需要维护历史遗留系统（擦汗）。</p>

<p>首先是最简单的 NAT 模式。这种模式跟普通的 NAT 防火墙的原理差不多，只不过它会根据指定的分配策略，为每一个新的客户端连接选择一个不同的真实服务，而不是像 NAT 防火墙那样只映射到后台的同一个真实服务。</p>

<p>这种模式下最常用的部署方式为，负载均衡机器上分别启用两块网卡，一块外网，一块内网。当然一块网卡也可以，然后在这块网卡上配两个地址。这里假设外网地址为 <code>192.168.0.1</code> ，内网地址为 <code>192.168.1.1</code> 。两个真实服务器的地址分别为 <code>192.168.1.2</code> 以及 <code>192.168.1.3</code> 。</p>

<p>这样，要对两台服务器的 SSH 服务进行负载均衡的话，负载机器上要执行的命令如下（当然你得先安装 <code>ipvsadm</code> 这个命令才行。负载功能的实现还是在内核中做的，跟 <code>iptables</code> 一样）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ipvsadm -A -t 192.168.0.1:22 -s rr</span></code></pre></td></tr></table></div></figure>


<p><code>-A</code> 表示增加一个新的负载均衡服务，一台负载均衡器上可以同时对多个服务进行负载； <code>-t</code> 表示这是一个 TCP 服务； <code>-s rr</code> 表示选择 Round Robin 分配策略。 Round Robin 是最简单的一种分配策略，表示在每台真实服务器间进行轮流选择；其他还有最少连接等策略。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ipvsadm -a -t 192.168.0.1:22 -r 192.168.1.2:22 -m</span></code></pre></td></tr></table></div></figure>


<p><code>-a</code> 表示为指定的负载服务增加一个新的真实服务； <code>-t</code> 同上； <code>-r</code> 指定真实服务的地址和端口； <code>-m</code> 则表示这个真实服务采用的是 NAT 模式的负载均衡。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ipvsadm -a -t 192.168.0.1:22 -r 192.168.1.3:22 -m</span></code></pre></td></tr></table></div></figure>


<p>这样负载均衡服务就配置好了。当然，记得还要打开系统的 IP 转发功能，不管你用的是哪种负载均衡。真实服务器上则还需要配置路由规则，把回给客户端的路由通过 <code>192.168.1.1</code> 这个网关进行发送（不指定网关地址，只指定网口是不行的）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo route add -net 192.168.0.0/24 gw 192.168.1.1</span></code></pre></td></tr></table></div></figure>


<p>这种模式的优点，当然就在于配置简单啦，跟配置 NAT 防火墙基本相同，缺点是有对网络报文的额外处理（替换目的地址）的开销。不过据说 2.6 的内核其开销已经很小了。</p>

<p>用如下命令可以查看当前的负载状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo ipvsadm -l -n</span></code></pre></td></tr></table></div></figure>


<p>这里有一点要说的是，当负载的是 UDP 服务（如 OpenVPN ）时，建立起来的连接会显示在“非活动连接”那一栏，不知道为什么。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发布一个寻找局域网内主机的小工具]]></title>
    <link href="http://glacjay.github.com/blog/2011-03-05/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E5%AF%BB%E6%89%BE%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7.html"/>
    <updated>2011-03-05T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-03-05/发布一个寻找局域网内主机的小工具</id>
    <content type="html"><![CDATA[<p>在工作中，经常需要远程登录到机房中的设备上进行调试与开发，走的是工作局域网。由于这些设备的地址也是动态获取的，因此在遇到一些意外事故，如网线松了、网络不稳定之类的，这些地址可能就变了。每当这时，我们就得跑到机房，给设备连上显示器（我们连 KVM 都没有，命苦啊），查看 IP ，然后再跑回去重新连。太麻烦了。</p>

<p>我知道有支持动态地址的 DNS 服务，可是我们没权限操作 DNS 服务器，而且设备也都是不固定的，没必要惊动网络管理员（好吧，我甚至都不知道谁是网络管理员，作为三年的“老”员工，我面壁去了。好吧，其实我就是想写写程序练练手），所以我就写了个小程序，用来查找一台特定设备的 IP 地址。</p>

<p>原理其实很简单啦。客户端（也就是我的笔记本）发个 UDP 广播报文，里面有要找的主机的名字。服务端呢，启动时则指定一个主机名字。当服务端收到一个 UDP 广播报文，并且发现找的就是自己呢，就返回一个 <code>bingo</code> 报文。这样，客户端就知道这个主机的 IP 地址啦。</p>

<p>现在用的服务端口是 <code>5460</code> （取自某本网络小说 :-），应该没有哪个知名服务用这个端口吧。当然，因为这个工具确实太简单了，所以就没有考虑冲突的情况啦。请大家在使用的时候，给主机取个有个性的名字哟。</p>

<p>我通过这个程序学到的新知识就是，要发送 UDP 的广播报文，只是指定一个全 <code>1</code> 的地址是不够的，还要设置 socket 选项 <code>SO_BROADCAST</code> （我继续面壁去了）。</p>

<p>下面是代码（好撑篇幅啊，又没人给我稿费的说）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;errno.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;sys/socket.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;netinet/in.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;pthread.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;arpa/inet.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define PORT 5460</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">progname</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">sock</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">usage</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
</span><span class='line'>            <span class="s">&quot;Usage: %s options</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>            <span class="s">&quot;where options must be one of:</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>            <span class="s">&quot;  -s         Running as a  named server.</span><span class="se">\n</span><span class="s">&quot;</span>
</span><span class='line'>            <span class="s">&quot;  -c         Asking for &#39;s address.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">progname</span><span class="p">);</span>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="nf">udp_socket</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sock</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Cannot open a new socket: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sock</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">server</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">listen_addr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">listen_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span><span class='line'>    <span class="n">listen_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
</span><span class='line'>    <span class="n">listen_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">listen_addr</span><span class="p">,</span>
</span><span class='line'>             <span class="k">sizeof</span><span class="p">(</span><span class="n">listen_addr</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Cannot bind to the UDP port %d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="n">PORT</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">received</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">received</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                            <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="n">socklen_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">received</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">buf</span><span class="p">[</span><span class="n">received</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="n">sendto</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="s">&quot;bingo&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">waiton_response</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'>        <span class="n">socklen_t</span> <span class="n">addrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">received</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">received</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                            <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addrlen</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">received</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="n">buf</span><span class="p">[</span><span class="n">received</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;bingo&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Got. %s&#39;s address is %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
</span><span class='line'>                   <span class="n">name</span><span class="p">,</span> <span class="n">inet_ntoa</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">));</span>
</span><span class='line'>            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">client</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">bcast</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pthread_attr_t</span> <span class="n">attr</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">setsockopt</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_BROADCAST</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bcast</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bcast</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">pthread_attr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pthread_attr_setdetachstate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_CREATE_DETACHED</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span><span class='line'>    <span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
</span><span class='line'>    <span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Searching...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">sendto</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>               <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">waiton_response</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">name</span><span class="p">);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot find the machine.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">progname</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="n">sock</span> <span class="o">=</span> <span class="n">udp_socket</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>        <span class="n">usage</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;-s&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">server</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;-c&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">client</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="n">usage</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>PS. 最近 gist.github.com 好像不是很给力，用它贴代码的话，不翻墙就看不到，只好直接贴这里了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux 下有关环境变量与换行符的一个小问题]]></title>
    <link href="http://glacjay.github.com/blog/2011-03-05/linux-%E4%B8%8B%E6%9C%89%E5%85%B3%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98.html"/>
    <updated>2011-03-05T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-03-05/linux-下有关环境变量与换行符的一个小问题</id>
    <content type="html"><![CDATA[<p>最近在工作中，老是遇到一个莫名其妙的问题。我有一个用来设置一些环境变量的脚本，结果经常发现这个脚本设过的环境变量乱七八糟的，像 PATH 这种，就是之前的值跟后面添加的值重叠在了一起。直到后来才发现，原来是换行符搞的鬼。</p>

<p>这样说还不太清楚，上代码吧。编辑文本文件 <code>test.sh</code> 如下，记得以 DOS 换行符的模式来保存：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Save this file using DOS&#39;s CR/LF.</span>
</span><span class='line'>
</span><span class='line'><span class="nb">export </span><span class="nv">VAR1</span><span class="o">=</span>blahblahblah
</span><span class='line'><span class="nb">export </span><span class="nv">VAR2</span><span class="o">=</span>hello
</span><span class='line'><span class="nb">export </span><span class="nv">VAR1</span><span class="o">=</span><span class="nv">$VAR1</span>:<span class="nv">$VAR2</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，执行一下命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ . ./test.sh</span></code></pre></td></tr></table></div></figure>


<p>来使环境变量生效，并看一下结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo $VAR1
</span><span class='line'>:helloahblah</span></code></pre></td></tr></table></div></figure>


<p>当然，Shell 看到的还不是这个样子，而是会把多出来的那个 CR 回车符也看作是路径（或者其他什么值）的一部分，最后当然也会导致所作的设置不生效啦。</p>

<p>至于为什么会变成这种换行符，我倒是还没有搞明白，因为我的源文件确实是 Unix 风格的换行符。也许是因为是在 Windows 下用 ClearCase 来进行源码控制的关系？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenVPN 的并发测试方法]]></title>
    <link href="http://glacjay.github.com/blog/2011-01-19/openvpn-%E7%9A%84%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95.html"/>
    <updated>2011-01-19T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-01-19/openvpn-的并发测试方法</id>
    <content type="html"><![CDATA[<p>由于 OpenVPN 本身协议的特殊性，用一般的方法不太好测它的并发。看过 LoadRunner ，但也最多只支持标准的 SSL/TLS 协议（当然，我也没细看这个）。于是动手改了其客户端的实现，最终完成任务。</p>

<p>其实阻止我们在一台机器上同时跑很多 OpenVPN 客户端的因素就只有虚拟网卡一个。貌似装十个左右的虚拟网卡驱动之后，机器就不行了。于是解决办法也很简单，把虚拟网卡相关的功能跳过就可以了。根据<a href="http://glacjay.github.com/blog/2011-01-18/openvpn-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.html">上篇</a>的说明，只要在 <code>incoming_push_message()</code> 函数中，把对 <code>do_up()</code> 的调用直接换成 <code>initialization_sequence_completed()</code> 就 OK 了。</p>

<p>当然，这样一来，流量的来源也就没有了，而没有数据流量也就无所谓测试了，最多测下并发接入的性能。要流量也很简单，改下 <code>io_wait()</code> 、 <code>read_tun()</code> 、 <code>write_tun()</code> 这几个函数的实现，手工组个 Ping 请求的 IP 报文给 OpenVPN 去发就行了。</p>

<p>在这个过程中我也终于搞清楚那个 <code>checksum</code> 到底是怎么回事儿，原来在累加一遍求出一个和之后，如果这个和本身超过了 <code>16</code> 位，那么还要把这个和继续按 <code>16</code> 位来切分求和，这样才是最终结果。之前看 WikiPedia 上的那个例子，一直就没搞明白那个 <code>2</code> 到底是打哪儿来的。</p>

<p>最后，就是要把起客户端这个过程给自动化了。于是又去研究 Windows 的 Batch 脚本，<code>for</code> 是循环， <code>start</code> 是后台运行， <code>ping</code> 用来模拟 <code>sleep</code> ， <code>taskkill</code> 是强制杀掉，搞了个 <code>1000</code> 客户端连了断、断了连的自动化测试出来。丢在那边跑了两天，服务端表示很淡定。</p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenVPN 的初始化过程分析]]></title>
    <link href="http://glacjay.github.com/blog/2011-01-18/openvpn-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.html"/>
    <updated>2011-01-18T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2011-01-18/openvpn-的初始化过程分析</id>
    <content type="html"><![CDATA[<p>题外话：Eclipse CDT 很给力，至少在我用起来，比 gVim + Cscope 或者 SourceInsight 要来得给力，推荐一下。</p>

<p>更准确的来说，是 OpenVPN 的客户端与服务端之间，从协商密钥、到推送配置，以及最后的网卡与路由配置生效，开始进行 IP 报文的传递，这整个的过程。</p>

<p>完了。嗯，整个过程就像上面说的，这几个步骤而已。</p>

<p>不过重点当然还是代码啦。以前一直以为 OpenVPN 的点对点模式下，两端会进行一个决定谁是客户端，谁是服务端的协商过程，一直都想知道是怎么做的。后来才知道，原来通过配置信息，就已经决定好这个了。当然，我下面说的是客户端-服务器模式。</p>

<p>那么先来看客户端的初始化。客户端进入的还是点对点模式，进入点，也是其事件循环的入口为 <code>tunnel_point_to_point()</code> 。然后是 <code>init_instance()</code> ，在这个函数中进行客户端自身的初始化，包括各种数据结构的建立，像分片啦、压缩啦、socket 啦、MTU 啦等。其中代码量最多的是 SSL 模块的初始化（ <code>do_init_crypto</code> 和 <code>do_init_frame_tls</code> ），要调很多的 OpenSSL 的函数；还有对 socket 的初始化，分为两个阶段，第一个阶段解析域名，第二个阶段发起连接（如果是 TCP 的话）。我一直搞不十分清楚的是 MTU ，也就是 <code>frame</code> 模块，因为太细节而且太分散了。</p>

<p>然后通过 <code>pre_select()</code> 函数进入 <code>check_tls()</code> 过程。因为是客户端，这时就会准备好发送第一个握手报文，命令码为 <code>P_CONTROL_HARD_RESET_CLIENT_V1/2</code> 。按照<a href="http://glacjay.github.com/blog/2010-11-22/openvpn-%E7%9A%84%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90.html">上篇</a>所说与服务器交换好了密钥之后，会在 <code>tls_process()</code> 函数的 <code>3852</code> 行，设置连接成功建立的标志 <code>connection_established</code> 。</p>

<p>之后，还是在 <code>pre_select()</code> 的 <code>check_connection_established()</code> 函数中，初始化 <code>push_request_interval</code> 定时器，由客户端开始发送推送配置的请求报文。推送配置功能的报文走的是和交换密钥相同的 SSL 隧道，按理说蛮可靠的，不过还是实现了重传，不知道是基于什么考虑。通过 <code>check_incoming_control_channel()</code> 函数收到服务器推过来的额外配置之后，调用 <code>process_incoming_push_msg()</code> 函数解析一下收到的配置字符串，就要根据这些配置，调用 <code>do_up()</code> 函数进行最终的初始化工作了。</p>

<p>在 <code>do_up()</code> 中，先调用 <code>do_open_tun()</code> ，根据由服务器发过来的所分配置的虚拟 IP 地址把虚拟网卡给起了，然后把 <code>route_wakeup</code> 定时器给激活一下，告诉 <code>check_add_routes()</code> 函数加一下路由，完了之后就是 <code>initialization_sequence_completed()</code> 了。</p>

<p>服务器嘛，也就是顺序不一样。首先，虚拟网卡和系统路由可以先建起来，因为不需要等其他人推配置。然后就等着客户端发过来第一个报文了，然后握手，然后把配置推过去，然后就完了。</p>

<p>然后就是在虚拟网卡跟物理网卡之间当搬运工啦。因为服务器要服务多个客户端，所以还用二叉树实现了一个调度器。</p>

<p>就这样。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenVPN 的握手协议分析]]></title>
    <link href="http://glacjay.github.com/blog/2010-11-22/openvpn-%E7%9A%84%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90.html"/>
    <updated>2010-11-22T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2010-11-22/openvpn-的握手协议分析</id>
    <content type="html"><![CDATA[<p>又是好久没来这儿了啊。</p>

<p>最近因为工作需要（其实也没需要那么多），一直在断断续续地看 OpenVPN 的代码，终于大概搞清楚了它的握手是怎么个流程了。简单来说的话其实非常的简单，首先在 <code>reliable</code> 模块中实现了一个可靠的 UDP 报文协议，就是加上超时重传和确认报文的功能；然后用该协议交换一个 Hard Reset 命令，开始握手；最后建立 SSL 对象，并且通过内存 <code>BIO</code> 在可靠 UDP 协议的基础上转发 OpenSSL 的握手协议报文，通过这个 SSL 连接交换 OpenVPN 自己的密钥。接下来就是用这些密钥，该干嘛干嘛了。</p>

<p>本来还写了好多，不过太乱，写不下去了，还是简单点吧。具体实现就是，首先在 <code>key_state_init()</code> 函数中，初始化了 <code>ssl</code> 、 <code>ssl_bio</code> 、 <code>ct_in</code> 、 <code>ct_out</code> 这几个相关的成员， <code>ssl</code> 就是普通 SSL 程序里面的 <code>SSL</code> 对象， <code>ssl_bio</code> 是以 <code>BIO</code> 接口来读写这个 <code>ssl</code> 成员而准备的，<code>tls_process()</code> 中通过 <code>ssl_bio</code> 这个成员完成 OpenVPN 自己的密钥交换，完成从 <code>S_START</code> 到 <code>S_GOT_KEY</code> 这几个状态的转换。而 <code>ct_in</code> 和 <code>ct_out</code> 则是这个 <code>ssl</code> 对象的后端，不是通常用的 socket BIO 对象，而是两个 memory BIO 对象，为的就是得到 <code>ssl</code> 对象要发给对端的密文，然后通过可靠 UDP 协议来转发。这样， <code>tls_process()</code> 的主要工作就是操作这几个对象，外加可靠 UDP 模块的那几个队列了。</p>

<p>这里的关键就是通过 OpenSSL 实现提供的 memory BIO 对象抓取密文包的功能。如果是在其他没有这个功能接口的语言实现或封装中，则可以使用 socketpair 这种方法来抓，我今天就试着改了一下 OpenVPN ，这种方法是可行的。具体就是把其中一个 socket 给 ssl 当后端，另一个 socket 就可以用来读写密文了。注意 <code>socketpair()</code> 调用中的 <code>type</code> 参数要加上 <code>SOCK_NONBLOCK</code> 。</p>

<p>不过在 Erlang 这个语言中，甚至就连 <code>socketpair</code> 这个调用都没封。搜了一下它的源码，才发现自己实现一个也非常的简单，怪不得。下面摘自 <code>otp_src_R14B/lib/kernel/test/inet_sockopt_SUITE.erl</code> 文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">create_socketpair</span><span class="p">(</span><span class="nv">ListenOptions</span><span class="p">,</span><span class="nv">ConnectOptions</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>    <span class="o">?</span><span class="n">line</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="nv">LS</span><span class="p">}</span><span class="o">=</span><span class="nn">gen_tcp</span><span class="p">:</span><span class="n">listen</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nv">ListenOptions</span><span class="p">),</span>
</span><span class='line'>    <span class="o">?</span><span class="n">line</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="nv">Port</span><span class="p">}</span><span class="o">=</span><span class="nn">inet</span><span class="p">:</span><span class="n">port</span><span class="p">(</span><span class="nv">LS</span><span class="p">),</span>
</span><span class='line'>    <span class="o">?</span><span class="n">line</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="nv">CS</span><span class="p">}</span><span class="o">=</span><span class="nn">gen_tcp</span><span class="p">:</span><span class="n">connect</span><span class="p">(</span><span class="n">localhost</span><span class="p">,</span><span class="nv">Port</span><span class="p">,</span><span class="nv">ConnectOptions</span><span class="p">),</span>
</span><span class='line'>    <span class="o">?</span><span class="n">line</span> <span class="p">{</span><span class="n">ok</span><span class="p">,</span><span class="nv">AS</span><span class="p">}</span><span class="o">=</span><span class="nn">gen_tcp</span><span class="p">:</span><span class="n">accept</span><span class="p">(</span><span class="nv">LS</span><span class="p">),</span>
</span><span class='line'>    <span class="o">?</span><span class="n">line</span> <span class="nn">gen_tcp</span><span class="p">:</span><span class="n">close</span><span class="p">(</span><span class="nv">LS</span><span class="p">),</span>
</span><span class='line'>    <span class="p">{</span><span class="nv">AS</span><span class="p">,</span><span class="nv">CS</span><span class="p">}.</span>
</span></code></pre></td></tr></table></div></figure>


<p>至于前面的 <code>?line</code> 是啥，咱就不需要关心了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 Python 操作虚拟网卡]]></title>
    <link href="http://glacjay.github.com/blog/2010-09-18/%E7%94%A8-python-%E6%93%8D%E4%BD%9C%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1.html"/>
    <updated>2010-09-18T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2010-09-18/用-python-操作虚拟网卡</id>
    <content type="html"><![CDATA[<p>在我的 <a href="http://glacjay.github.com/blog/2009-12-19/%E5%88%A9%E7%94%A8-xmpp-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0-vpn.html">XTunnel</a> 项目中，已经用 Python 作过这种相对底层的工作了（这说明 Python 果然还是非常强大的，上下层通吃啊），不过那边目前还是只实现了 Linux 的版本。后来我又陆陆续续地把 Windows 以及 Mac 下的操作方法给搞通了，今天就来总结一下。</p>

<p>在 Linux 内核中，特别是在现在的发行版中，应该都已经有了 <code>TUN/TAP</code> 虚拟网卡的驱动程序，看一下有没有 <code>/dev/net/tun</code> 这个文件就可以知道了。如果没有，就执行一下 <code>sudo modprobe tun</code> 这个命令吧。如果还是没有，那就 Google 之吧。下面上代码：</p>

<div><script src='https://gist.github.com/585369.js?file='></script>
<noscript><pre><code>import fcntl
import os
import struct
import subprocess


# Some constants used to ioctl the device file. I got them by a simple C
# program.
TUNSETIFF = 0x400454ca
TUNSETOWNER = TUNSETIFF + 2
IFF_TUN = 0x0001
IFF_TAP = 0x0002
IFF_NO_PI = 0x1000

# Open TUN device file.
tun = open('/dev/net/tun', 'r+b')
# Tall it we want a TUN device named tun0.
ifr = struct.pack('16sH', 'tun0', IFF_TUN | IFF_NO_PI)
fcntl.ioctl(tun, TUNSETIFF, ifr)
# Optionally, we want it be accessed by the normal user.
fcntl.ioctl(tun, TUNSETOWNER, 1000)

# Bring it up and assign addresses.
subprocess.check_call('ifconfig tun0 192.168.7.1 pointopoint 192.168.7.2 up',
        shell=True)

while True:
    # Read an IP packet been sent to this TUN device.
    packet = list(os.read(tun.fileno(), 2048))

    # Modify it to an ICMP Echo Reply packet.
    #
    # Note that I have not checked content of the packet, but treat all packets
    # been sent to our TUN device as an ICMP Echo Request.

    # Swap source and destination address.
    packet[12:16], packet[16:20] = packet[16:20], packet[12:16]

    # Under Linux, the code below is not necessary to make the TUN device to
    # work. I don't know why yet, but if you run tcpdump, you can see the
    # difference.
    if True:
        # Change ICMP type code to Echo Reply (0).
        packet[20] = chr(0)
        # Clear original ICMP Checksum field.
        packet[22:24] = chr(0), chr(0)
        # Calculate new checksum.
        checksum = 0
        # for every 16-bit of the ICMP payload:
        for i in range(20, len(packet), 2):
            half_word = (ord(packet[i]) &lt;&lt; 8) + ord(packet[i+1])
            checksum += half_word
        # Get one's complement of the checksum.
        checksum = ~(checksum + 4) &amp; 0xffff
        # Put the new checksum back into the packet.
        packet[22] = chr(checksum &gt;&gt; 8)
        packet[23] = chr(checksum &amp; ((1 &lt;&lt; 8) -1))

    # Write the reply packet into TUN device.
    os.write(tun.fileno(), ''.join(packet))
</code></pre></noscript></div>


<p>简而言之，就是首先打开对应的设备文件，然后通过 <code>ioctl</code> 系统调用告诉它我们想要的网卡类型和名称，同时还可以告诉它我们想以普通用户的身份来对它进行操作。之后通过 <code>ifconfig</code> 命令将新建的网卡拉起来，就可以开始读写了。</p>

<p>当你以 root 身份运行这个脚本的时候，可以 <code>ping</code> 一下 <code>192.168.7.2</code> 这个地址试试，看看是不是能 <code>ping</code> 得通。</p>

<p>下面的代码则在 Mac 环境中实现了同样的功能（不过还没有设置用户身份的功能）：</p>

<div><script src='https://gist.github.com/586860.js?file='></script>
<noscript><pre><code>import os
import subprocess


# Open file corresponding to the TUN device.
tun = open('/dev/tun0', 'r+b')

# Bring it up and assign addresses.
subprocess.check_call('ifconfig tun0 192.168.7.1 192.168.7.2 up', shell=True)

while True:
    # Read an IP packet been sent to this TUN device.
    packet = list(os.read(tun.fileno(), 2048))

    # Modify it to an ICMP Echo Reply packet.
    #
    # Note that I have not checked content of the packet, but treat all packets
    # been sent to our TUN device as an ICMP Echo Request.

    # Swap source and destination address.
    packet[12:16], packet[16:20] = packet[16:20], packet[12:16]
    # Change ICMP type code to Echo Reply (0).
    packet[20] = chr(0)
    # Clear original ICMP Checksum field.
    packet[22:24] = chr(0), chr(0)
    # Calculate new checksum.
    checksum = 0
    # for every 16-bit of the ICMP payload:
    for i in range(20, len(packet), 2):
        half_word = (ord(packet[i]) &lt;&lt; 8) + ord(packet[i+1])
        checksum += half_word
    # Get one's complement of the checksum.
    checksum = ~(checksum + 4) &amp; 0xffff
    # Put the new checksum back into the packet.
    packet[22] = chr(checksum &gt;&gt; 8)
    packet[23] = chr(checksum &amp; ((1 &lt;&lt; 8) - 1))

    # Write the reply packet into TUN device.
    os.write(tun.fileno(), ''.join(packet))</code></pre></noscript></div>


<p>当然要运行上面的代码，你首先要到<a href="http://tuntaposx.sourceforge.net/">这里</a>下载并安装 Mac 下的 <code>TUN/TAP</code> 设备驱动程序才行。安装之后，在系统的 <code>/dev</code> 目录中就会分别有 16 个 <code>/dev/tunX</code> 以及 <code>/dev/tapX</code> （ <code>X</code> 表示网卡序号）字符设备文件，分别对应于 <code>16</code> 个同名的 <code>TUN/TAP</code> 虚拟网卡。当然，在运行这个脚本之前，你是看不到这些网卡的。不不，用 <code>ifconfig -a</code> 也不行。</p>

<p>因为与 Linux 下的驱动的实现方法不同，这里是用的文件名来标识网卡类型与名称，所以就不需要 Linux 版本中的第一个 <code>ioctl</code> 调用了。</p>

<p>也不记得一开始是在哪边看到的一个讲 <code>TUN/TAP</code> 编程的文章，说要实现对 <code>ping</code> 报文的处理，只要简单地将读到的 IP 报文中的源地址与目的地址对换一下，再写回去就可以了。在 Linux 系统中也确实是如此，因此我也就没有深究。直到后来才发现，同样的招数在 Mac 下居然没用。于是赶紧上网翻 ICMP 的报文格式，改报文中的 <code>type</code> 码，并重新计算 <code>checksum</code> ，这才搞定。这时也才发现，用 Python 来操作原始的字节流还是没有 C 这种底层语言直观啊。</p>

<p>可是 Linux 下为什么不需要这么麻烦呢？于是回去抓了抓包，这才发现，相对于 Mac 下的一问（ <code>ping</code> 命令）一答（ Python 脚本），在 Linux 下居然是两问两答，一问是 <code>ping</code> 命令，一问是我们的那个 Python 脚本。这也不奇怪，我连 <code>ICMP</code> 中的 <code>type</code> 码都没改，发过来的是 <code>request</code> ，那再发出去的当然还是 <code>request</code> 。至于应答，大概就是 Linux 的 <code>TUN/TAP</code> 驱动搞的鬼了。</p>

<p>最后，当然也有 Windows 的实现版本啦，不过代码被我丢到公司的 Windows 工作用机上了，所以，就请您且听下回分解了。</p>

<hr />

<p><strong>Update 2011-04-26:</strong> Windows 下的实现代码如下：</p>

<div><script src='https://gist.github.com/586892.js?file=tun-ping-win.py'></script>
<noscript><pre><code>import _winreg as reg
import win32file


adapter_key = r'SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE10318}'


def get_device_guid():
    with reg.OpenKey(reg.HKEY_LOCAL_MACHINE, adapter_key) as adapters:
        try:
            for i in xrange(10000):
                key_name = reg.EnumKey(adapters, i)
                with reg.OpenKey(adapters, key_name) as adapter:
                    try:
                        component_id = reg.QueryValueEx(adapter, 'ComponentId')[0]
                        if component_id == 'tap0801':
                            return reg.QueryValueEx(adapter, 'NetCfgInstanceId')[0]
                    except WindowsError, err:
                        pass
        except WindowsError, err:
            pass

def CTL_CODE(device_type, function, method, access):
    return (device_type &lt;&lt; 16) | (access &lt;&lt; 14) | (function &lt;&lt; 2) | method;

def TAP_CONTROL_CODE(request, method):
    return CTL_CODE(34, request, method, 0)

TAP_IOCTL_CONFIG_POINT_TO_POINT = TAP_CONTROL_CODE(5, 0)
TAP_IOCTL_SET_MEDIA_STATUS = TAP_CONTROL_CODE(6, 0)
TAP_IOCTL_CONFIG_TUN = TAP_CONTROL_CODE(10, 0)


if __name__ == '__main__':
    guid = get_device_guid()
    handle = win32file.CreateFile(r'\\.\Global\%s.tap' % guid,
                                  win32file.GENERIC_READ | win32file.GENERIC_WRITE,
                                  win32file.FILE_SHARE_READ | win32file.FILE_SHARE_WRITE,
                                  None, win32file.OPEN_EXISTING,
                                  win32file.FILE_ATTRIBUTE_SYSTEM, # | win32file.FILE_FLAG_OVERLAPPED,
                                  None)
    print(handle.handle)
    if False:
        win32file.DeviceIoControl(handle, TAP_IOCTL_CONFIG_POINT_TO_POINT,
                                  '\xc0\xa8\x11\x01\xc0\xa8\x11\x10', None);
    else:
        win32file.DeviceIoControl(handle, TAP_IOCTL_SET_MEDIA_STATUS, '\x01\x00\x00\x00', None)
        win32file.DeviceIoControl(handle, TAP_IOCTL_CONFIG_TUN,
                                  '\x0a\x03\x00\x01\x0a\x03\x00\x00\xff\xff\xff\x00', None)
    while True:
        l, p = win32file.ReadFile(handle, 2000)
        q = p[:12] + p[16:20] + p[12:16] + p[20:]
        win32file.WriteFile(handle, q)
        print(p, q)
    win32file.CloseHandle(handle)
</code></pre></noscript></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过 ODBC 接口访问 Oracle 数据库 -- Linux 篇]]></title>
    <link href="http://glacjay.github.com/blog/2010-03-03/%E9%80%9A%E8%BF%87-odbc-%E6%8E%A5%E5%8F%A3%E8%AE%BF%E9%97%AE-oracle-%E6%95%B0%E6%8D%AE%E5%BA%93-linux-%E7%AF%87.html"/>
    <updated>2010-03-03T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2010-03-03/通过-odbc-接口访问-oracle-数据库-linux-篇</id>
    <content type="html"><![CDATA[<p>首先，你要安装好 UnixODBC 软件包，这个就不多说了。</p>

<p>然后，安装 Oracle 官方客户端，因为我的使用环境为 Fedora 12 ，所以我下载安装的是 <code>oracle-xe-client-10.2.0.1-1.0.i386.rpm</code> 。</p>

<p>装好之后，要设置一些环境变量，我是用的一个 Shell 脚本来完成这项工作的，你可以把它放在 <code>/etc/profile.d/</code> 目录下并加上可执行权限来让其在系统启动时自动执行，也可以直接运行这个脚本来使其立即生效。脚本如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># File: oracle.sh</span>
</span><span class='line'><span class="nb">export </span><span class="nv">ORACLE_HOME</span><span class="o">=</span>/usr/lib/oracle/xe/app/oracle/product/10.2.0/client
</span><span class='line'><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:<span class="nv">$ORACLE_HOME</span>/bin
</span><span class='line'><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$LD_LIBRARY_PATH</span>:<span class="nv">$ORACLE_HOME</span>/lib
</span><span class='line'><span class="nb">export </span><span class="nv">TNS_ADMIN</span><span class="o">=</span><span class="nv">$ORACLE_HOME</span>/network/admin
</span><span class='line'><span class="nb">export </span><span class="nv">TWO_TASK</span><span class="o">=</span><span class="nb">test</span>
</span><span class='line'><span class="nb">export </span><span class="nv">NLS_LANG</span><span class="o">=</span>”Simplified Chinese_china.UTF8”
</span><span class='line'><span class="nb">export </span><span class="nv">NLS_DATE_FORMAT</span><span class="o">=</span><span class="s2">&quot;YYYY-MM-DD HH24:MI:SS&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>TWO_TASK</code> 变量的值应设为 <code>tnsnames.ora</code> 文件中的那个键名（下面再讲）， <code>NLS_LANG</code> 是为了 UTF-8 编码，而 <code>NLS_DATE_FORMAT</code> 设的是 <code>DATE</code> 类型的数据在插入和显示时所用的格式，这里设的是我比较习惯的一种。</p>

<p>然后在 <code>$ORACLE_HOME</code> 目录中建一个子目录 <code>network/admin</code> ，并在其中新建两个文本文件如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># File: sqlnet.ora
</span><span class='line'>SQLNET.AUTHENTICATION_SERVICES = (NTS)
</span><span class='line'>NAMES.DIRECTORY_PATH = (TNSNAMES, EZCONNECT)</span></code></pre></td></tr></table></div></figure>


<p>这个文件中的都是一些固定的配置，其中 <code>TNSNAMES</code> 和 <code>EZCONNECT</code> 分别为我所用到的两种指定连接目标的方式。另一个文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># File: tnsnames.ora
</span><span class='line'>test =
</span><span class='line'>  (DESCRIPTION =
</span><span class='line'>    (ADDRESS =
</span><span class='line'>      (PROTOCOL = TCP)
</span><span class='line'>      (HOST = 192.168.0.2)
</span><span class='line'>      (PORT = 1521)
</span><span class='line'>    )
</span><span class='line'>    (CONNECT_DATA =
</span><span class='line'>      (SID = test)
</span><span class='line'>    )
</span><span class='line'>  )</span></code></pre></td></tr></table></div></figure>


<p>第二行中的 <code>test</code> 就是 <code>TWO_TASK</code> 环境变量的值， <code>SID</code> 就是数据库名，其它的就不需要说明了。当然，在这个文件中可以配置多个数据库连接，用不同的名称来标识（ <code>TWO_TASK</code> 就是用来选择的），这个例子中只有一个配置。</p>

<p>以上的步骤主要是 Oracle 相关，都完成了之后，可以先测一下 Oracle 客户端是不是能正常使用了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sqlplus username/password@test</span></code></pre></td></tr></table></div></figure>


<p>这个命令可以连接数据库。这种参数格式就是上面提到的 <code>TNSNAMES</code> 方式，而 <code>EZCONNECT</code> 方式则是下面的样子（这种方式就不需要在 <code>tnsnames.ora</code> 文件中进行配置了）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sqlplus username/password@192.168.0.2:1521/test</span></code></pre></td></tr></table></div></figure>


<p>成功之后可以试试下面的 SQL 语句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt; select * from some_table;</span></code></pre></td></tr></table></div></figure>


<p>接下来就是配置 UnixODBC 了。首先是 <code>odbcinst.ini</code> 文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="k">[oracle]</span>
</span><span class='line'><span class="na">Driver</span> <span class="o">=</span> <span class="s">/usr/lib/oracle/xe/app/oracle/product/10.2.0/client/lib/libsqora.so.10.1</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后是 <code>odbc.ini</code> 文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="k">[oracle]</span>
</span><span class='line'><span class="na">Driver</span> <span class="o">=</span> <span class="s">oracle</span>
</span></code></pre></td></tr></table></div></figure>


<p>都没什么可配的。</p>

<p>最后就是程序了，跟其它的 ODBC 程序没什么不同，除了连接字符串，需要写成这个样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"DSN=oracle;UID=username;PWD=password"</span></code></pre></td></tr></table></div></figure>


<p><code>DSN</code> 就是 ODBC Data Source 名，也就是上面 <code>odbc.ini</code> 文件中方括号内的名字； <code>UID</code> 就是用户名， <code>PWD</code> 就是密码。</p>

<p>好了，就这么多。</p>

<p>PS. 我和另一位同事分别碰到过一次一个特别令人头痛的问题，就是在连接时， UnixODBC 说 <code>libsqora.so.10.1</code> （就是在 <code>odbcinst.ini</code> 文件中指定的那个）找不到，虽然这个文件明明就在那边；用 <code>ldd</code> 命令查看该文件的结果是说“这不是一个动态可执行文件”。更不幸的是，我不知怎么在我的机器上把这个问题给莫名其妙地解决了，却想破头都不知道是怎么解决的。太失败了。</p>

<hr />

<p><strong>Update:</strong> 问题解决了，出问题的都是新装的 Fedora 12 机器，后来做了次全系统的更新，再建个链接，就好了。只是不知道倒底是哪个软件包的版本太老，试了 <code>glibc</code> 、 <code>libtool</code> 、 <code>kernel</code> 都不是。</p>

<p><strong>Update 2012-12-31:</strong> 找到问题的原因了，都是 SELinux 惹的祸，关之即可，或者配下相关的策略啥的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle 建库 SQL 脚本]]></title>
    <link href="http://glacjay.github.com/blog/2010-03-02/oracle-%E5%BB%BA%E5%BA%93-sql-%E8%84%9A%E6%9C%AC.html"/>
    <updated>2010-03-02T00:00:00+08:00</updated>
    <id>http://glacjay.github.com/blog/2010-03-02/oracle-建库-sql-脚本</id>
    <content type="html"><![CDATA[<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="c1">-- 首先是删除该数据库中该用户名下的所有表、序列与触发器，</span>
</span><span class='line'><span class="c1">-- 其中触发器是通过表格级联删除的。</span>
</span><span class='line'><span class="k">declare</span>
</span><span class='line'>  <span class="k">cursor</span> <span class="n">usertables</span> <span class="k">is</span>
</span><span class='line'>    <span class="k">select</span> <span class="o">*</span>
</span><span class='line'>    <span class="k">from</span> <span class="n">user_tables</span>
</span><span class='line'>    <span class="k">where</span> <span class="k">table_name</span> <span class="k">not</span> <span class="k">like</span> <span class="s1">&#39;BIN$%&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">cursor</span> <span class="n">usersequences</span> <span class="k">is</span>
</span><span class='line'>    <span class="k">select</span> <span class="o">*</span>
</span><span class='line'>    <span class="k">from</span> <span class="n">user_sequences</span><span class="p">;</span>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">next_row</span> <span class="k">in</span> <span class="n">usertables</span> <span class="n">loop</span>
</span><span class='line'>    <span class="k">execute</span> <span class="k">immediate</span>
</span><span class='line'>      <span class="s1">&#39;drop table &#39;</span> <span class="o">||</span> <span class="n">next_row</span><span class="p">.</span><span class="k">table_name</span> <span class="o">||</span>
</span><span class='line'>      <span class="s1">&#39; cascade constraints&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">end</span> <span class="n">loop</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">next_row</span> <span class="k">in</span> <span class="n">usersequences</span> <span class="n">loop</span>
</span><span class='line'>    <span class="k">execute</span> <span class="k">immediate</span>
</span><span class='line'>      <span class="s1">&#39;drop sequence &#39;</span> <span class="o">||</span> <span class="n">next_row</span><span class="p">.</span><span class="n">sequence_name</span><span class="p">;</span>
</span><span class='line'>  <span class="k">end</span> <span class="n">loop</span><span class="p">;</span>
</span><span class='line'><span class="k">end</span><span class="p">;</span>
</span><span class='line'><span class="o">/</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- 然后，就是一砣……的建表语句啦，</span>
</span><span class='line'><span class="c1">-- 比方说下面就是两个含外键的表。</span>
</span><span class='line'><span class="k">create</span> <span class="k">table</span> <span class="ss">&quot;A&quot;</span> <span class="p">(</span>
</span><span class='line'>  <span class="ss">&quot;ID&quot;</span> <span class="nb">integer</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">&quot;NAME&quot;</span> <span class="n">nvarchar2</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span>         <span class="c1">-- nvarchar2类型支持UTF8</span>
</span><span class='line'><span class="p">);</span>
</span><span class='line'><span class="c1">-- Oracle中的表名与字段名最好写成这样引号加全大写的形式。</span>
</span><span class='line'>
</span><span class='line'><span class="k">create</span> <span class="k">table</span> <span class="ss">&quot;B&quot;</span> <span class="p">(</span>
</span><span class='line'>  <span class="ss">&quot;ID&quot;</span> <span class="nb">integer</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">&quot;A&quot;</span> <span class="nb">integer</span> <span class="k">not</span> <span class="k">null</span> <span class="k">references</span> <span class="ss">&quot;B&quot;</span> <span class="k">on</span> <span class="k">delete</span> <span class="k">cascade</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">&quot;VALUE&quot;</span> <span class="n">nvarchar2</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span>
</span><span class='line'><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- 接下来是第三部分，为所有的表创建对应的序列和触发器，以实现自增主键。</span>
</span><span class='line'><span class="k">declare</span>
</span><span class='line'>  <span class="k">cursor</span> <span class="n">usertables</span> <span class="k">is</span>
</span><span class='line'>    <span class="k">select</span> <span class="n">cols</span><span class="p">.</span><span class="k">table_name</span><span class="p">,</span> <span class="n">cols</span><span class="p">.</span><span class="k">column_name</span>
</span><span class='line'>    <span class="k">from</span> <span class="n">all_constraints</span> <span class="n">cons</span><span class="p">,</span> <span class="n">all_cons_columns</span> <span class="n">cols</span>
</span><span class='line'>    <span class="k">where</span> <span class="n">cols</span><span class="p">.</span><span class="k">owner</span> <span class="o">=</span> <span class="p">(</span>
</span><span class='line'>      <span class="k">select</span> <span class="n">sys_context</span><span class="p">(</span><span class="s1">&#39;USERENV&#39;</span><span class="p">,</span> <span class="s1">&#39;SESSION_USER&#39;</span><span class="p">)</span>
</span><span class='line'>      <span class="k">from</span> <span class="n">dual</span><span class="p">)</span>
</span><span class='line'>    <span class="k">and</span> <span class="n">cols</span><span class="p">.</span><span class="k">table_name</span> <span class="k">not</span> <span class="k">like</span> <span class="s1">&#39;BIN$%&#39;</span>
</span><span class='line'>    <span class="k">and</span> <span class="n">cons</span><span class="p">.</span><span class="n">constraint_type</span> <span class="o">=</span> <span class="s1">&#39;P&#39;</span>
</span><span class='line'>    <span class="k">and</span> <span class="n">cons</span><span class="p">.</span><span class="k">constraint_name</span> <span class="o">=</span> <span class="n">cols</span><span class="p">.</span><span class="k">constraint_name</span>
</span><span class='line'>    <span class="k">and</span> <span class="n">cons</span><span class="p">.</span><span class="k">owner</span> <span class="o">=</span> <span class="n">cols</span><span class="p">.</span><span class="k">owner</span>
</span><span class='line'><span class="k">begin</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">nextrow</span> <span class="k">in</span> <span class="n">usertables</span> <span class="n">loop</span>
</span><span class='line'>    <span class="c1">-- 1000以下的留作初始测试数据用，见下</span>
</span><span class='line'>    <span class="k">execute</span> <span class="k">immediate</span>
</span><span class='line'>      <span class="s1">&#39;create sequence &quot;&#39;</span> <span class="o">||</span> <span class="n">nextrow</span><span class="p">.</span><span class="k">table_name</span> <span class="o">||</span>
</span><span class='line'>      <span class="s1">&#39;_PK_SEQ&quot; start with 1000&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">execute</span> <span class="k">immediate</span>
</span><span class='line'>      <span class="s1">&#39;create or replace trigger &quot;&#39;</span> <span class="o">||</span> <span class="n">nextrow</span><span class="p">.</span><span class="k">table_name</span> <span class="o">||</span>
</span><span class='line'>      <span class="s1">&#39;_PK_TRG&quot; before insert on &quot;&#39;</span> <span class="o">||</span> <span class="n">nextrow</span><span class="p">.</span><span class="k">table_name</span> <span class="o">||</span>
</span><span class='line'>      <span class="s1">&#39;&quot; for each row begin if :new.&quot;&#39;</span> <span class="o">||</span> <span class="n">nextrow</span><span class="p">.</span><span class="k">column_name</span> <span class="o">||</span>
</span><span class='line'>      <span class="s1">&#39;&quot; is null then select &quot;&#39;</span> <span class="o">||</span> <span class="n">nextrow</span><span class="p">.</span><span class="k">table_name</span> <span class="o">||</span>
</span><span class='line'>      <span class="s1">&#39;_PK_SEQ&quot;.nextval into :new.&quot;&#39;</span> <span class="o">||</span> <span class="n">nextrow</span><span class="p">.</span><span class="k">column_name</span> <span class="o">||</span>
</span><span class='line'>      <span class="s1">&#39;&quot; from dual; end if; end;&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">end</span> <span class="n">loop</span><span class="p">;</span>
</span><span class='line'><span class="k">end</span><span class="p">;</span>
</span><span class='line'><span class="o">/</span>
</span><span class='line'>
</span><span class='line'><span class="c1">-- 最后当然就是测试数据啦。</span>
</span><span class='line'><span class="k">insert</span> <span class="k">into</span> <span class="ss">&quot;A&quot;</span> <span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">NAME</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;first name&#39;</span><span class="p">);</span>
</span><span class='line'><span class="k">insert</span> <span class="k">into</span> <span class="ss">&quot;B&quot;</span> <span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">AID</span><span class="p">,</span> <span class="n">VALUE</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Jay&#39;</span><span class="p">);</span>
</span><span class='line'><span class="k">insert</span> <span class="k">into</span> <span class="ss">&quot;B&quot;</span> <span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="n">AID</span><span class="p">,</span> <span class="n">VALUE</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;杰&#39;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
