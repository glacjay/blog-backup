<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compiler on Random Stuff from GlacJAY</title>
    <link>https://glacjay.info/tags/compiler/</link>
    <description>Recent content in Compiler on Random Stuff from GlacJAY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 26 Jul 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://glacjay.info/tags/compiler/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[转载] Compilers: what are you thinking about?</title>
      <link>https://glacjay.info/post/2011-07-26/%E8%BD%AC%E8%BD%BD-compilers-what-are-you-thinking-about/</link>
      <pubDate>Tue, 26 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-07-26/%E8%BD%AC%E8%BD%BD-compilers-what-are-you-thinking-about/</guid>
      <description>

&lt;p&gt;最近在翻看以前加星的 Google Reader 文章，把有用的整理出来打标签，然后就看到了这篇。原文作者的博客现在不知道被丢到哪边去了，搜也搜不到，转到这里，权当保存一下吧。&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.onebadseed.com/blog/?p=119&#34;&gt;Compilers: what are you thinking about?&lt;/a&gt;。当然，已经打不开了。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;compilers-what-are-you-thinking-about:ef1b8fdac518361c2e2ceb322c646507&#34;&gt;Compilers: what are you thinking about?&lt;/h2&gt;

&lt;p&gt;Author: Rotten Cotton&lt;/p&gt;

&lt;p&gt;My recent post &lt;a href=&#34;http://www.onebadseed.com/blog/?p=103&#34;&gt;Compiler bibliography&lt;/a&gt;, a motley list of compiler papers that had been sitting in a box in my attic, generated a surprising amount of traffic: over a thousand unique visitors. But no comments. For those of you interested in compiler design, I ask, what are you trying to understand? What are you trying to do?&lt;/p&gt;

&lt;p&gt;I imagine some of you are interested in understanding how compilers work and, more importantly, how to build them. The first step in learning to design compilers is to build one. (Tautologous, no?) To start, I recommend following the syllabus of a compiler design course. Googling “&lt;a href=&#34;http://www.google.com/search?hl=en&amp;amp;q=compiler+syllabus&amp;amp;aq=f&amp;amp;oq=&amp;amp;aqi=g1&#34;&gt;compiler syllabus&lt;/a&gt;” returns a massive list of syllabi for compiler for compiler classes. The first link, a &lt;a href=&#34;http://web.cecs.pdx.edu/~harry/compilers/syllabus.html&#34;&gt;compiler design&lt;/a&gt; class, at Portand State University, follows Louden’s book &lt;a href=&#34;http://www.amazon.com/gp/product/0534939724?ie=UTF8&amp;amp;tag=wwwonebadseec-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0534939724&#34;&gt;Compiler Construction&lt;/a&gt; to build a SPARC compiler for a toy programming language, &lt;a href=&#34;http://web.cecs.pdx.edu/~harry/compilers/PCATLangSpec.pdf&#34;&gt;PCAT&lt;/a&gt; (pdf). MIT’s compiler design class, &lt;a href=&#34;http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-035Fall-2005/CourseHome/&#34;&gt;6.035&lt;/a&gt;, is on &lt;a href=&#34;http://ocw.mit.edu/&#34;&gt;OCW&lt;/a&gt;. Following one of these classes will teach you the basic challenges involved in designing a compiler and the organizational principles that have emerged to solve these problems. If you’re ambitious, start with a free C front end and build a C compiler for your favorite architecture. There is &lt;a href=&#34;http://www.smlnj.org/doc/ckit/index.html&#34;&gt;ckit&lt;/a&gt; for ML, &lt;a href=&#34;http://www.sivity.net/projects/language.c/&#34;&gt;Language.C&lt;/a&gt; for Haskell or &lt;a href=&#34;http://clang.llvm.org/&#34;&gt;clang&lt;/a&gt; (part of the &lt;a href=&#34;http://llvm.org/&#34;&gt;LLVM&lt;/a&gt; project) written in, I think, C++. There are others, no doubt. This way, you won’t have to write a front-end and you will have a huge source of potential examples on which to test your compiler and, when your start to design optimizations (the fun part), explore your compiler’s performance.&lt;/p&gt;

&lt;p&gt;For a few years after I first took 6.035, whenever the course was taught again and the project (toy language) for that semester was announced, I would spend a long caffeine-fueled weekend hacking out a new compiler. I must have build three or four compilers this way, targeting different architectures and exploring various design choices. This was a very valuable experience.&lt;/p&gt;

&lt;p&gt;Once you understand the basics of compiler design, what’s next? There are a number of directions you can go.&lt;/p&gt;

&lt;p&gt;You can study programming language features and their implementation in a compiler and runtime. For this, I recommend a book like Scott’s &lt;a href=&#34;http://www.amazon.com/gp/product/0123745144?ie=UTF8&amp;amp;tag=wwwonebadseec-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0123745144&#34;&gt;Programming Language Pragmatics&lt;/a&gt; or Turbak and Gifford’s &lt;a href=&#34;http://www.amazon.com/gp/product/0262201755?ie=UTF8&amp;amp;tag=wwwonebadseec-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0262201755&#34;&gt;Design Concepts in Programming Languages&lt;/a&gt;. I used a draft version of the latter in MIT’s Programming Languages class, 6.821. This will move beyond compiling the standard C- or Pascal-like toy languages standard in most first-year compiler courses. Learn about semantics: denotational, operational and axiomatic. This is important if you (a) want to build a correct compiler, and (b) as a theoretical foundation for program analysis.&lt;/p&gt;

&lt;p&gt;At the other end of the spectrum are computer architectures. Go learn about computer architecture: instruction set architectures and micro-architectures, their implementation. There are many interesting architectures out there to study. Write assembly language programs by hand. Learn to extract maximal performance form an architecture on small examples. Pay attention to the techniques used to extract performance when hand-coding. These will be the basis for compiler optimizations. The standard text for computer architecture is probably Hennessy and Patterson’s text, &lt;a href=&#34;http://www.amazon.com/gp/product/0123704901?ie=UTF8&amp;amp;tag=wwwonebadseec-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0123704901&#34;&gt;Computer Architecture: A Quantitative Approach&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A deep understanding of both the semantics of your input programming language and your target (micro-)architectures is essential to building a compiler that generates high-performance code. Program analysis and optimization is the bridge between the input program and assembly language. Start with a book on advanced compiler design like Muchnick’s &lt;a href=&#34;http://www.amazon.com/gp/product/1558603204?ie=UTF8&amp;amp;tag=wwwonebadseec-20&amp;amp;linkCode=as2&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=1558603204&#34;&gt;Advanced Compiler Design and Implementation&lt;/a&gt; (or maybe the new dragon book, I haven’t looked at it) or start diving into the literature or program analysis and optimization.&lt;/p&gt;

&lt;p&gt;What are you trying to understand about compilers?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之六：匿名函数 lambda</title>
      <link>https://glacjay.info/post/2011-05-21/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%85%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-lambda/</link>
      <pubDate>Sat, 21 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-05-21/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%85%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-lambda/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;既然上次已经提到说，我们其实是在从 Lisp、Scheme 还有类似的其他语言中借鉴各种要实现的功能（我没想过要把这个项目做成原创的⋯⋯或者至少也要等到以后再说吧），那么现在也&lt;strong&gt;是时候&lt;/strong&gt;实现一些更加强大的功能了。&lt;/p&gt;

&lt;h2 id=&#34;那就来做延迟求值以及匿名函数吧:4bbf12fdd90013097351677638258420&#34;&gt;那就来做延迟求值以及匿名函数吧&lt;/h2&gt;

&lt;p&gt;Lambda ，又名匿名函数，可以像普通的数值或者字符串类型那样被当作函数参数来到处传递，也可以在需要的时候才调用（当然不调也可以）。同时，外层函数（也就是定义匿名函数的函数）作为它们的运行环境，在其中定义的局部变量可以被这些匿名函数所访问。这就形成了&lt;a href=&#34;http://en.wikipedia.org/wiki/Closure_(computer_science)&#34;&gt;一个闭包&lt;/a&gt;。我们这次&lt;strong&gt;并不是&lt;/strong&gt;要实现完整的闭包功能，只是开头的一小步而已，完整的实现要等到再后面了。&lt;/p&gt;

&lt;p&gt;其实说到底，正如编程语言中的其他很多功能一样，闭包也只是又一种语法糖而已。比如说，你可以认为这样其实是定义了一个类，这个类中有唯一一个需要被调用的方法，还有一些作为运行环境的成员变量（或者你也可以反过来&lt;a href=&#34;http://strlen.com/bla/index.html&#34;&gt;用闭包来实现面向对象系统&lt;/a&gt; &amp;ndash; 这是由 &lt;a href=&#34;http://strlen.com/&#34;&gt;Wouter van Oortmerssen&lt;/a&gt; 所提出来的观点。自从我发现 &lt;a href=&#34;http://strlen.com/e/index.html&#34;&gt;Amiga E&lt;/a&gt; 这个项目之后，作为作者的他就成了我的偶像。如果你是一个编程语言方面的极客的话，那你就一定要去看看 Wouter 所做过的东西） &amp;ndash; 有很多功能其实都是相互正交的。&lt;/p&gt;

&lt;p&gt;（ blah blah blah ⋯⋯这个人在说自己很啰嗦之类的，就不翻了）&lt;/p&gt;

&lt;p&gt;那么，为了避免定义很多具名小函数的麻烦，同时降低函数重名的概率， lambda 允许你在任何需要它们的地方进行定义，并且返回一个表示所定义函数的值。&lt;/p&gt;

&lt;p&gt;我们现在所要增加的是像下面这样的东西：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(lambda (args) body)
(call f (args))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个表达式会返回所定义的函数（目前来说，其实就是这个函数的起始地址），而不是去执行这个函数。而 &lt;code&gt;call&lt;/code&gt; ，当然就是以指定的参数列表，来调用传给它的那个函数地址。&lt;/p&gt;

&lt;p&gt;那么，这跟“真正”的闭包又有什么区别呢？&lt;/p&gt;

&lt;p&gt;最重要的一点就是，当你在 lambda 中引用了外层作用域中的某个变量后，那么，当以后对同一个 lambda 进行调用时，这个变量还是可以访问的。这样的变量与 lambda 绑定在了一起。当然，只是得到一个函数的地址的话，肯定是实现不了这个功能的。让我们来看一种实现闭包的技术吧，这样你就能够了解大概所要做的工作了（工作量不大，但也不小）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们可以创建一个“环境”，一个存放那些被引用到的外部变量的地方，以使得当外层函数返回之后，它们也可以继续存在。这个环境必须是在堆中，而且每次对外层函数的调用，都需要创建一个新的环境。&lt;/li&gt;
&lt;li&gt;我们必须返回一个可以用来访问这个环境的东西。你可以返回一个对象，其中的成员变量就是被 lambda 引用到的那些变量。或者你也可以用一个 thunk （中文叫啥呢？），也就是自动生成出来的一个包含有指向这个对象指针的小函数，它会在调用我们的 lambda 之前将这个对象加载到预先指定的地方。或者你也可以用什么其他的办法。&lt;/li&gt;
&lt;li&gt;你必须决定有哪些变量需要放入这个环境中。可以是外层函数中的所有局部变量，当然也可以只是那些被引用到的变量。后一种作法可以节省一定的内存空间，但是需要作更多的工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好吧，还是让我们先来把匿名函数本身给弄出来吧。就像以前一样，我会一步一步地说明所要做的修改，但我同时也会对之前的代码做一些整理。这些整理的部分我就不一一说明了。&lt;/p&gt;

&lt;p&gt;首先是对 lambda 表达式本身进行处理的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_lambda args, body
    name = &amp;quot;lambda__#{@seq}&amp;quot;
    @seq += 1
    compile_defun(name, args,body)
    puts &amp;quot;\tmovl\t$#{name},%eax&amp;quot;
    return [:subexpr]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现应该是很容易理解的吧。我们在这里做的，就是给要定义的匿名函数，生成一个形如 &lt;code&gt;lambda__[number]&lt;/code&gt; 的函数名，然后就把它当作一个普通函数来处理了。虽然你也可以就把它生成到外层函数的函数体中，但我发现那样做的话，就会显得很乱的样子，所以我现在还是就把它作为单独的函数来处理了。然后我们调用 &lt;code&gt;#compile_defun&lt;/code&gt; 方法来处理这个函数，这样的话，这个函数其实也就只有对用户来说，才是真正匿名的了。然后我们把这个函数的地址保存在寄存器 &lt;code&gt;%eax&lt;/code&gt; 中，这里同时也是我们存放子表达式结果的地方。当然，这是一种很懒的作法啦，我们迟早需要为复杂的表达式，实现更加强大的处理机制的。但寄存器分配果然还是很麻烦的一件事情，所以现在就先这样吧（将所有的中间结果压入栈中也是一种可行的作法啦，不过那样比较慢）。&lt;/p&gt;

&lt;p&gt;最后，我们返回一个 &lt;code&gt;[:subexpr]&lt;/code&gt; ，来告拆调用者到哪边可以得到这个 lambda 的值。&lt;/p&gt;

&lt;p&gt;之后是一些重构。你也许已经注意到了， &lt;code&gt;#compile_exp&lt;/code&gt; 中的代码有点乱，因为要处理不同类型的参数。让我们把这部分代码给提取出来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_eval_arg arg
    atype, aparam = get_arg(arg)
    return &amp;quot;$.LC#{aparam}&amp;quot; if atype == :strconst
    return &amp;quot;$#{aparam}&amp;quot; if atype == :int
    return aparam.to_s if atype == :atom
    return &amp;quot;%eax&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是，这里又出现了一个新的 &lt;code&gt;:atom&lt;/code&gt; 类型。借助于此，我们就可以把一个 C 函数的地址传给 &lt;code&gt;:call&lt;/code&gt; 指令了。反正实现起来也很简单。当然，我们还要在 &lt;code&gt;#get_arg&lt;/code&gt; 方法中加上如下代码，以使其生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    return [:atom, a] if (a.is_a?(Symbol))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，作为重构的一部分，对 &lt;code&gt;:call&lt;/code&gt; 的处理被分离了出来，成为一个单独的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_call func, args
    stack_adjustment = PTR_SIZE + (((args.length+0.5)*PTR_SIZE/(4.0*PTR_SIZE)).round) * (4*PTR_SIZE)
    puts &amp;quot;\tsubl\t$#{stack_adjustment}, %esp&amp;quot;
    args.each_with_index do |a,i|
      param = compile_eval_arg(a)
      puts &amp;quot;\tmovl\t#{param}, #{i&amp;gt;0 ? i*4 : &amp;quot;&amp;quot;}(%esp)&amp;quot;
    end

    res = compile_eval_arg(func)
    res = &amp;quot;*%eax&amp;quot; if res == &amp;quot;%eax&amp;quot; # Ugly. Would be nicer if retain some knowledge of what res contains.
    puts &amp;quot;\tcall\t#{res}&amp;quot;
    puts &amp;quot;\taddl\t#{stack_adjustment}, %esp&amp;quot;
    return [:subexpr]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来很熟悉对不对？因为它就是原来的 &lt;code&gt;#compile_exp&lt;/code&gt; 方法，只不过是用 &lt;code&gt;#compile_eval_arg&lt;/code&gt; 替换掉了其中的一些代码。另外有改动的地方，就是同时也用 &lt;code&gt;#compile_eval_arg&lt;/code&gt; 方法来得到要调用的函数，并对可能得到的 &lt;code&gt;%eax&lt;/code&gt; 做了些手脚，在前面加了个星号。&lt;/p&gt;

&lt;p&gt;如果你知道这是怎么回事的话，你也许已经开始寻思其他的点子了，而不管那是真正的好事，还只是开枪打自己的脚。上面的代码其实就相当于，你把任意一个表达式的值当作指向一段代码的指针，然后也不做任何的检查，就直接跳过去执行它。如果是往一个随机的地址进行跳转的话，你最有可能得到的就是一个段错误了。当然，你也可以很容易地通过这项技术，来实现面向对象系统中的虚函数跳转表，或者其他的什么东西。因此，安全性将会是以后必须要考虑的东西。还有就是，要实现对一个地址（而不是函数名）的间接调用，你必须要在这个地址前面加上星号。&lt;/p&gt;

&lt;p&gt;那么，现在的 &lt;code&gt;#compile_exp&lt;/code&gt; 方法变成什么样子了呢？简单来说就是，变得整齐多了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_do(*exp)
    exp.each { |e| compile_exp(e) }
    return [:subexpr]
  end
  def compile_exp(exp)
    return if !exp || exp.size == 0
    return compile_do(*exp[1..-1]) if exp[0] == :do
    return compile_defun(*exp[1..-1]) if exp[0] == :defun
    return compile_ifelse(*exp[1..-1]) if exp[0] == :if
    return compile_lambda(*exp[1..-1]) if exp[0] == :lambda
    return compile_call(exp[1], exp[2]) if exp[0] == :call
    return compile_call(exp[0], *exp[1..-1])
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来很不错，不是吗？&lt;code&gt;#compile_call&lt;/code&gt; 几乎跟之前的 &lt;code&gt;#compile_exp&lt;/code&gt; 一模一样，只不过是把一些代码给提取出来，成为了辅助方法而已。&lt;/p&gt;

&lt;p&gt;那么就来简单地测试一下吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:do,
  [:call, [:lambda, [], [:puts, &amp;quot;Test&amp;quot;]], [] ]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（看起来也没那么糟不是吗？）&lt;/p&gt;

&lt;p&gt;编译运行之：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ ruby step6.rb &amp;gt;step6.s
$ make step6
cc      step6.s  -o step6
$ ./step6
Test
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这篇的代码在&lt;a href=&#34;http://www.hokstad.com/static/compiler/step6.rb&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;之后的部分:4bbf12fdd90013097351677638258420&#34;&gt;之后的部分&lt;/h2&gt;

&lt;p&gt;因为我合并了几篇文章，下面就列一下更新过后的，“已经写完但还需要整理的”文章列表。因为我肯定还会合并下面的某些部分的，所以我想我需要找时间开始写一些新的部分了（为了完成我所定下的 30 篇的计划）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;步骤七：再看用匿名函数实现循环，以及对函数参数的访问&lt;/li&gt;
&lt;li&gt;步骤八：实现赋值语句以及简单的四则运算&lt;/li&gt;
&lt;li&gt;步骤九：一个更简洁的 &lt;code&gt;while&lt;/code&gt; 循环语句&lt;/li&gt;
&lt;li&gt;步骤十：测试这个语言：实现一个简单的输入转换模块&lt;/li&gt;
&lt;li&gt;步骤十一：重构代码生成器，分离架构相关的部分&lt;/li&gt;
&lt;li&gt;步骤十二：对某些功能点的讨论，以及未来的前进方向&lt;/li&gt;
&lt;li&gt;步骤十三：实现数组&lt;/li&gt;
&lt;li&gt;步骤十四：局部变量以及多重作用域&lt;/li&gt;
&lt;li&gt;步骤十五：访问变长参数列表&lt;/li&gt;
&lt;li&gt;步骤十六：再看输入转换模块，重构以支持新功能，并用其解析它自己&lt;/li&gt;
&lt;li&gt;步骤十七：总结实现自举所需要的功能点&lt;/li&gt;
&lt;li&gt;步骤十八：开始实现真正的解析器&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之五：整数常量，以及 if 语句</title>
      <link>https://glacjay.info/post/2011-05-17/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Tue, 17 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-05-17/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-5.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-5.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;上次我承诺会发布的更快一些，不过还是失败了⋯⋯作为补偿，这章的内容将会是原计划中的第 5，6，7 章内容的合并，因为这三章确实都很短。闲话少叙：&lt;/p&gt;

&lt;h2 id=&#34;处理数字常量:a8d5e417469934211fedda17d3824d8d&#34;&gt;处理数字常量&lt;/h2&gt;

&lt;p&gt;到目前为止，我们只处理了一些实现所必须的数字常量，也就是当一个外部函数的返回值是数字的情况，而且没有做任何形式的类型检查。&lt;/p&gt;

&lt;p&gt;那么，就让我们来看一下 gcc 在 C 语言中是怎样处理各种类型（包括 &lt;code&gt;long long&lt;/code&gt; 等）的整数的吧。当然，这次还是针对 32 位的 x86 架构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void foo1(unsigned short a) {}
void foo2(signed short a) {}
void foo3(unsigned int a) {}
void foo4(signed int a) {}
void foo5(unsigned long a) {}
void foo6(signed long a) {}
void foo7(unsigned long long a) {}
void foo8(signed long long a) {}

int main()
{
  foo1(1);
  foo2(2);
  foo3(3);
  foo4(4);
  foo5(5);
  foo6(6);
  foo7(7);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我略掉了大部分 gcc 所生成的代码，如果愿意，你可以自己执行 &lt;code&gt;gcc -S&lt;/code&gt; 命令来看。有趣的部分是对各个函数的调用，其生成的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;        movl    $1, (%esp)
        call    foo1
        movl    $2, (%esp)
        call    foo2
        movl    $3, (%esp)
        call    foo3
        movl    $4, (%esp)
        call    foo4
        movl    $5, (%esp)
        call    foo5
        movl    $6, (%esp)
        call    foo6
        movl    $7, (%esp)
        movl    $0, 4(%esp)
        call    foo7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，至少在处理函数调用的时候，gcc 都会把各种整数类型统一作为 32 位的整型来处理，除了 &lt;code&gt;long long&lt;/code&gt; 类型之外。因此，我们可以暂时忘掉 &lt;code&gt;long long&lt;/code&gt; 类型，而只处理 32 位以内的整数值，这样我们就可以忽略类型处理相关的东西了。&lt;/p&gt;

&lt;p&gt;懒惰还真是一种病啊。&lt;/p&gt;

&lt;p&gt;我们同时也会略过浮点型。为什么呢？因为只要有整数运算，你就可以实现一个完整的编译器了，所以现在就加入对浮点型的支持完全只是浪费时间而已。当然这个东西以后总归是要做的。&lt;/p&gt;

&lt;p&gt;另外，当&lt;strong&gt;我&lt;/strong&gt;还年轻时，我们连 FPU 是啥都还不知道呢。尽管如此，我们依然可以用整数来模拟各种定点运算，一样可以完成很多事情。&lt;/p&gt;

&lt;p&gt;那么，我们真正要做的修改有哪些呢？&lt;/p&gt;

&lt;p&gt;在方法 &lt;code&gt;#get_arg&lt;/code&gt; 中，在处理字符串常量之前，加入如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    return [:int, a] if (a.is_a?(Fixnum))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在方法 &lt;code&gt;#compile_exp&lt;/code&gt; 中，我们用如下代码来处理 &lt;code&gt;#get_arg&lt;/code&gt; 的返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    elsif atype == :int then param = &amp;quot;$#{aparam}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，就完事了。就这么简单。&lt;/p&gt;

&lt;p&gt;然后就是测试啦：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:do,
  [:printf,&amp;quot;&#39;hello world&#39; takes %ld bytes\n&amp;quot;,[:strlen, &amp;quot;hello world&amp;quot;]],
  [:printf,&amp;quot;The above should show _%ld_ bytes\n&amp;quot;,11]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;插曲-针对原生数据类型的一些思考:a8d5e417469934211fedda17d3824d8d&#34;&gt;插曲：针对原生数据类型的一些思考&lt;/h2&gt;

&lt;p&gt;“纯”面向对象类型的语言很棒，但并不是对底层的代码生成器而言的，我想。不管你是否想要实现一个纯的面向对象语言，我仍然坚信，首先实现原生的数据类型和其操作，是非常有价值的。你可以在后面的阶段再来考虑是否要对用户隐藏它们，或者是让它们看起来像是对象，或者是透明地在它们和对象之间执行自动转换的操作，等等。&lt;/p&gt;

&lt;p&gt;要注意的是，Matz 的 Ruby 解释器（Matz Ruby Interpreter，简称MRI）就是这样实现的：里面的数字就跟“真正的”对象神马的完全不一样，但是解释器本身却尽其所能的对用户隐藏这一事实。不过我个人认为 MRI 做的还是不够。&lt;/p&gt;

&lt;h2 id=&#34;if-then-else:a8d5e417469934211fedda17d3824d8d&#34;&gt;&lt;code&gt;If ... then ... else&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;如果没有某种形式的条件逻辑支持的话，我们的语言是没有太大用处的。几乎所有有用的语言都支持某种形式的 &lt;code&gt;if .. then .. else&lt;/code&gt; 构造。现在，我们要实现的是像 &lt;code&gt;[:if, condition, if-arm, else-arm]&lt;/code&gt; 这样的构造，而且是以 C 语言的形式来实现。也就是说， &lt;code&gt;0&lt;/code&gt; 和空指针都表示假，其他值则都为真。&lt;/p&gt;

&lt;p&gt;仍然是一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void foo() {}
void bar() {}
int main()
{
  if (baz()) {
    foo();
  } else {
    bar();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相关的汇编输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;        call    baz
        testl   %eax, %eax
        je      .L6
        call    foo
        jmp     .L10
.L6:
        call    bar
.L10:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于大多数的语言和架构来说，这都是一个编译 &lt;code&gt;if .. then .. else&lt;/code&gt; 时会采用的通用模板：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算条件表达式。&lt;/li&gt;
&lt;li&gt;对结果进行测试（这里用的是 &lt;code&gt;testl&lt;/code&gt; 指令 &amp;ndash; 在其他架构中比较通用的还有 &lt;code&gt;cmp&lt;/code&gt; 指令，或者对寄存器进行自减）。 &lt;code&gt;testl&lt;/code&gt; 指令比较它的左右两个操作数，并进行相应的标志位设置。&lt;/li&gt;
&lt;li&gt;然后，条件跳转到 &lt;strong&gt;&lt;code&gt;else&lt;/code&gt; 语句处。这里，我们检查条件表达式的值是否不为真。在这种情况下我们用的是 &lt;code&gt;je&lt;/code&gt; 指令，即“相等时跳转”（ jump on equal ），也就是当结果相等时跳转（要注意的是，在大多数的 CPU 架构中，很多指令都会设置条件码，而不仅仅是显示的测试指令）。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后执行 &lt;code&gt;then&lt;/code&gt; 子句。&lt;/li&gt;
&lt;li&gt;跳过 &lt;code&gt;else&lt;/code&gt; 子句，继续执行整个 &lt;code&gt;if&lt;/code&gt; 语句之后的部分。&lt;/li&gt;
&lt;li&gt;生成 &lt;code&gt;else&lt;/code&gt; 子句的标号，以及其中的指令序列。&lt;/li&gt;
&lt;li&gt;生成 &lt;code&gt;if&lt;/code&gt; 语句的结束标号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他还有很多不同的变种，比如根据条件表达式取值的概率，或者某个架构中是否跳转的执行代价，进而调整两个子句的顺序等。不过就目前来说，上面的方法已经足够了。&lt;/p&gt;

&lt;p&gt;总之，编译的方法还是很简单的，应该说就是以上所述流程的直译：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def ifelse cond, if_arg,else_arm
    compile_exp(cond)
    puts &amp;quot;\ttestl\t%eax, %eax&amp;quot;
    @seq += 2
    else_arm_seq = @seq - 1
    end_if_arm_seq = @seq
    puts &amp;quot;\tje\t.L#{else_arm_seq}&amp;quot;
    compile_exp(if_arm)
    puts &amp;quot;\tjmp\t.L#{end_if_arm_seq}&amp;quot;
    puts &amp;quot;.L#{else_arm_seq}:&amp;quot;
    compile_exp(else_arm)
    puts &amp;quot;.L#{end_if_arm_seq}:&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码应该很易懂的，其实就是对所有子句 &amp;ndash; 条件， &lt;code&gt;then&lt;/code&gt; 子句，以及 &lt;code&gt;else&lt;/code&gt; 子句 &amp;ndash; 分别调用 &lt;code&gt;#compile_exp&lt;/code&gt; 方法，并在其间插入所需的辅助指令，同时用 &lt;code&gt;@seq&lt;/code&gt; 成员来生成所需的标号。&lt;/p&gt;

&lt;p&gt;为了使其生效，我们在 &lt;code&gt;#compile_exp&lt;/code&gt; 方法中的 &lt;code&gt;return defun ...&lt;/code&gt; 之后插入如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    return ifelse(*exp[1..-1]) if (exp[0] == :if)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个简单的测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:do,
  [:if, [:strlen,&amp;quot;&amp;quot;],
    [:puts, &amp;quot;IF: The string was not empty&amp;quot;],
    [:puts, &amp;quot;ELSE: The string was empty&amp;quot;]
  ],
  [:if, [:strlen,&amp;quot;Test&amp;quot;],
    [:puts, &amp;quot;Second IF: The string was not empty&amp;quot;],
    [:puts, &amp;quot;Second IF: The string was empty&amp;quot;]
  ]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.hokstad.com/static/compiler/step5.rb&#34;&gt;这里是最终结果&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如往常般，执行的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ ruby step5.rb &amp;gt;step5.s
$ make step5
cc   step5.s   -o step5
$ ./step5
ELSE: The string was empty
Second IF: The string was not empty
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;有关循环的一些思考:a8d5e417469934211fedda17d3824d8d&#34;&gt;有关循环的一些思考&lt;/h2&gt;

&lt;p&gt;非条件循环是很容易实现的，不过我们需要实现它吗？显然不需要。我们已经可以用递归来实现循环了，又何必要乱加东西呢？&lt;/p&gt;

&lt;p&gt;不过，要令它工作良好，我们还需要实现尾递归优化，可是我现在还没有做好准备。尾递归优化，或者更一般的形式 &amp;ndash; 尾调用优化 &amp;ndash; 所说的情况是，在一个函数的末尾，调用了一个需要相同或者更少个数参数的函数，并返回它所返回的值。在这种情况下，你可以将当前函数的调用栈，复用给被调用的函数来使用，并且是通过 &lt;code&gt;jmp&lt;/code&gt; 而不是 &lt;code&gt;call&lt;/code&gt; 来调用这个函数。 &lt;code&gt;jmp&lt;/code&gt; 指令不会在堆栈中压入一个新的返回地址，因此当这个被调用的函数返回，返回到的就是当前函数的调用者那里，而不是当前的这个函数。&lt;/p&gt;

&lt;p&gt;这就同时完成了几件事情：首先，也是最重要的，就是堆栈不再会随着调用而增长了。其次，我们能够省掉几个指令周期。有了尾调用优化，再配合其他几个优化之后，你就可以这样来写循环，而不用担心堆栈溢出的问题了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[:defun, :loop, [], [:do,
  [:puts, &amp;quot;I am all loopy&amp;quot;],
  [:loop]
],
[:loop]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，尾调用优化意味着，对任何形如 &lt;code&gt;(defun foo () (do bar foo))&lt;/code&gt; 的函数来说，堆栈的使用率都会从原来的成比例增长减少为定值了。&lt;/p&gt;

&lt;p&gt;当前的版本已经可以编译上面的代码了，不过它会很快用完堆栈并且崩溃掉的。不是很令人满意啊。&lt;/p&gt;

&lt;p&gt;果然（原文： I sense a disturbance in the force ），两位读到这篇文章的极客都指出了堆栈增长的问题。&lt;/p&gt;

&lt;p&gt;现在，让我们先忽略这个问题吧，同时注意下对堆栈空间的使用好了。之后，我们会实现一个专门的循环结构的。目前就这样吧 &amp;ndash; 如果以后我实现了尾调用优化的话，我们还可以重新考虑在运行时库中实现一个循环构造的方案。&lt;/p&gt;

&lt;p&gt;不管怎样，我们现在可以写出一个无限循环了⋯⋯不是太有用，不是吗？&lt;/p&gt;

&lt;p&gt;当然，我们其实也已经可以写 &lt;code&gt;while&lt;/code&gt; 循环了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(defun some-while-loop () (if condition (some-while-loop) ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来不是太好，不过确实可以工作。但看起来总归还是太丑了，所以我们总归还是要实现一个正尔八经的 &lt;code&gt;while&lt;/code&gt; 循环的。&lt;/p&gt;

&lt;p&gt;我不是一个 Lisp 程序员。我没办法处理那么多的括号⋯⋯不过 Lisp 的语法确实很适合于一门还没有语法的语言。到了一定的阶段之后，我会实现一个完整的解析器的。也许是出于偶然，我已经实现的和将要实现的很多东西在某种程度上来说都是取自于 Lisp 的，至少看起来是这样的。如果你能适应 Lisp 的语法的话，这个语言还是非常强大的。就算你不打算用它来开发你的程序，好好地学一下这门语言也是非常值得的。&lt;/p&gt;

&lt;p&gt;在我想来，很多看起来像是从 Lisp 中得来的点子，大概都是来自于我花在学习 Lisp 的有限经验。&lt;/p&gt;

&lt;p&gt;下一篇：匿名函数，也许不止。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之四：自定义函数，以及运行时支持</title>
      <link>https://glacjay.info/post/2011-05-09/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%9B%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81/</link>
      <pubDate>Mon, 09 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-05-09/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%9B%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-4.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-4.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;抱歉，又拖了很长时间。要忙的事情实在很多。正如上一篇文章末尾提到的那样，这次要讲的是自定义函数，以及一个简单的“运行时库”。&lt;/p&gt;

&lt;h2 id=&#34;自定义函数:a1905e7840a324707222cc702f5afc30&#34;&gt;自定义函数&lt;/h2&gt;

&lt;p&gt;一门编程语言如果连函数和方法都没有的话，那也就不能算是一门语言了。而且，实践表明，一门面向对象语言中的所有特性都可以通过过程式的语言要素来实现：一个方法也只不过是以一个对象为额外参数的函数而已。因此，增加对函数的支持就是实现一门语言的核心所在。&lt;/p&gt;

&lt;p&gt;其实，这个东东也是很简单的啦。跟以前一样，还是让我们来看一下 C 语言中的函数是怎么实现的吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void foo()
{
  puts(&amp;quot;Hello world&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gcc 生成的汇编代码是这个样子滴：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;.globl foo
        .type   foo, @function
foo:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $8, %esp
        movl    $.LC0, (%esp)
        call    puts
        leave
        ret
        .size   foo, .-foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的函数调用现在应该很容易认了吧。剩下的就是简单的样板代码了：&lt;/p&gt;

&lt;p&gt;在函数的开头，首先是将寄存器 &lt;code&gt;%ebp&lt;/code&gt; 压入堆栈，然后拷贝寄存器 &lt;code&gt;%esp&lt;/code&gt; 到 &lt;code&gt;%ebp&lt;/code&gt; 。而在函数的最后， &lt;code&gt;leave&lt;/code&gt; 指令就是前面两条指令的逆操作，而 &lt;code&gt;ret&lt;/code&gt; 指令则是从堆栈中弹出要返回到的指令地址（也就是调用该函数的那条指令的下一条指令）并跳转。为什么在这里要将 &lt;code&gt;%esp&lt;/code&gt; （也就是堆栈指针）拷到 &lt;code&gt;%ebp&lt;/code&gt; 呢？嘛，一个很明显的好处就是你可以尽情的申请堆栈空间，然后在完事时简单地将 &lt;code&gt;%ebp&lt;/code&gt; 拷回给 &lt;code&gt;%esp&lt;/code&gt; 就行了。从上面就可以看到， GCC 已经充分利用了这一点，直接用 &lt;code&gt;leave&lt;/code&gt; 指令来处理调用函数时对参数所申请的空间 &amp;ndash; 反正手工释放也只是浪费时间而已。&lt;/p&gt;

&lt;p&gt;这么说来的话，要做的事情应该就很简单了啊。&lt;/p&gt;

&lt;p&gt;首先需要修改方法 &lt;code&gt;Compiler#initialize&lt;/code&gt; ，创建一个用来保存所有函数定义的哈希：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def initialize
    @global_functions = {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后增加一个输出所有函数定义的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def output_functions
    @global_functions.each do |name,data|
      puts &amp;quot;.globl #{name}&amp;quot;
      puts &amp;quot;.type   #{name}, @function&amp;quot;
      puts &amp;quot;#{name}:&amp;quot;
      puts &amp;quot;\tpushl   %ebp&amp;quot;
      puts &amp;quot;\tmovl    %esp, %ebp&amp;quot;
      compile_exp(data[1])
      puts &amp;quot;\tleave&amp;quot;
      puts &amp;quot;\tret&amp;quot;
      puts &amp;quot;\t.size   #{name}, .-#{name}&amp;quot;
      puts
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，这里也同时包括了 &lt;code&gt;.globl&lt;/code&gt; 与 &lt;code&gt;.type&lt;/code&gt; 与 &lt;code&gt;.size&lt;/code&gt; 之类的东西。 &lt;code&gt;.globl&lt;/code&gt; 的意思就是你想让这个函数也能够从其他文件（也就是编译单元）中调用，这在链接多个目标文件的时候是很重要的。我想 &lt;code&gt;.type&lt;/code&gt; 和 &lt;code&gt;.size&lt;/code&gt; 主要是用在调试的时候，分别用来表示一个符号对应的是一个函数，以及这个函数的大小。&lt;/p&gt;

&lt;p&gt;除了这些之外，这个方法就很简单啦 &amp;ndash; 它会通过调用 &lt;code&gt;#compile_exp&lt;/code&gt; 方法来完成实际的工作。&lt;/p&gt;

&lt;p&gt;我们再来增加一个用来定义函数的辅助方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def defun name, args, body
    @global_functions[name] = [args, body]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在方法 &lt;code&gt;#compile_exp&lt;/code&gt; 中增加如下的几行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    return if !exp || exp.size == 0
    return defun(*exp[1..-1]) if (exp[0] == :defun)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之所以要增加第一行代码，一方面是出于健壮性的考虑，同时这也允许我们用 &lt;code&gt;nil&lt;/code&gt; 和空数组来表示“啥也不做”的意思，当你要定义一个空函数的时候就会用到这一点了。这样一来，第二行代码就不需要去检查将要定义的是不是一个空函数了。&lt;/p&gt;

&lt;p&gt;不知道你注意到了没有，我们其实已经实现了对函数的递归定义。像 &lt;code&gt;[:defun,:foo,[:defun, :bar, []]]&lt;/code&gt; 这样的代码完全是合法的。同时你也许会注意到，这个实现会导致两个函数其实都是可以从别处调用的。好吧，现在是没关系的啦，我们以后会处理这个的（要么不允许编写这样的代码，要么就只允许外层函数来调用内层函数 &amp;ndash; 我还没有决定到底要做哪个啦）。&lt;/p&gt;

&lt;p&gt;剩下的事情就是输出这些函数的定义了，因此我们在方法 &lt;code&gt;#compile&lt;/code&gt; 中对 &lt;code&gt;#output_constants&lt;/code&gt; 的调用之前增加如下的一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    output_functions
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;增加对一个运行时库的支持:a1905e7840a324707222cc702f5afc30&#34;&gt;增加对一个运行时库的支持&lt;/h2&gt;

&lt;p&gt;首先，让我们将现在的 &lt;code&gt;#compile&lt;/code&gt; 方法重命名为 &lt;code&gt;#compile_main&lt;/code&gt; ，然后重新定义 &lt;code&gt;#compile&lt;/code&gt; 方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile(exp)
    compile_main([:do, DO_BEFORE, exp, DO_AFTER])
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后是对常量 &lt;code&gt;DO_BEFORE&lt;/code&gt; 和 &lt;code&gt;DO_AFTER&lt;/code&gt; 的定义（如果愿意的话，你也可以把它们放在一个单独的文件中，我现在就直接把它们放在开头好了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;DO_BEFORE= [:do,
  [:defun, :hello_world,[], [:puts, &amp;quot;Hello World&amp;quot;]]
]
DO_AFTER= []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你得承认，你想看到的应该是更加高级一些的东东，但那样就违背我们最初的目标了。上面的代码对于实现一个运行时库来说已经足够了。当然，你也可以用一些只能通过 C 或者汇编才能实现的东西，只要把包含那些函数实现的目标文件给链接进来就可以了，因为我们一直都是在按照 C 语言的调用规则来办事的嘛。&lt;/p&gt;

&lt;p&gt;让我们来测试一下吧。在 &lt;code&gt;Compiler.new.compile(prog)&lt;/code&gt; 的前面加入下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:hello_world]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后编译运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ ruby step4.rb &amp;gt;step4.s
$ make step4
cc    step4.s   -o step4
$ ./step4
Hello World
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在&lt;a href=&#34;http://www.hokstad.com/static/compiler/step4.rb&#34;&gt;这里&lt;/a&gt;找到今天的成果。&lt;/p&gt;

&lt;h2 id=&#34;对函数参数的访问吗:a1905e7840a324707222cc702f5afc30&#34;&gt;对函数参数的访问吗？&lt;/h2&gt;

&lt;p&gt;今天还遗留了一个任务：实现对函数参数的访问。这个的工作量可是不小的。放心，我不会忘了这个的，这将会是第八篇文章的主题。我也不会让你等太久的啦，这次一定 :-)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之三：语句序列，以及子表达式</title>
      <link>https://glacjay.info/post/2011-05-02/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%89%E8%AF%AD%E5%8F%A5%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 02 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-05-02/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%89%E8%AF%AD%E5%8F%A5%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up---step-3.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up&amp;mdash;step-3.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;我本来是想要早点发表的，可是我这周又不行了 &amp;ndash; 虽然整理一篇旧文只需要半个小时。不管怎样，这是第三章，而且我会在末尾大概列一下之后的大纲。由于我会试着把一些小的步骤组合成更有内容的章节（下面就有个这样的例子），因此原来的 30 篇文章已经被我给减到了 20 篇左右（当然，这只是我已经完成了的，后面还有新的呢）。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;用-do-语句将表达式给串起来:05b0e8016c5bc2be24a3301233eda28c&#34;&gt;用 do 语句将表达式给串起来&lt;/h2&gt;

&lt;p&gt;到目前为止，&lt;a href=&#34;http://www.hokstad.com/static/compiler/step2b.rb&#34;&gt;上次的第二版程序&lt;/a&gt;只能编译一个单独的表达式。只是这样的话，并不是非常的有用啊。因此我决定实现一种支持顺序执行的结构，就像函数体那样的。当然，如你所想，这是很简单的。我会增加一个关键字 &lt;code&gt;do&lt;/code&gt; ，而其作用就是顺序执行传给它的每一个（个数不限哦，或者说，只受限于内存的大小）参数表达式。看起来就像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:do,
  [:printf,&amp;quot;Hello&amp;quot;],
  [:printf,&amp;quot; &amp;quot;],
  [:printf,&amp;quot;World\n&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要实现这个是非常简单的。我们只需要在函数 &lt;code&gt;#compile_exp&lt;/code&gt; 的开头加入下列代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    if exp[0] == :do
      exp[1..-1].each { |e| compile_exp(e) }
      return
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归在这里的作用很重要哦 &amp;ndash; 毕竟你是在处理一个树形结构，那也就需要在越来越深层的树结点之上调用实现编译的核心函数，而这当然也包括我们的下一个目标，即对子表达式的处理。&lt;/p&gt;

&lt;h2 id=&#34;子表达式-步骤一:05b0e8016c5bc2be24a3301233eda28c&#34;&gt;子表达式，步骤一&lt;/h2&gt;

&lt;p&gt;先来给出一个我们想要支持的用例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:printf,&amp;quot;‘hello world’ takes %ld bytes\n&amp;quot;,[:strlen, “hello world&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个需要改变的地方，在函数 &lt;code&gt;#get_arg&lt;/code&gt; 中，我们在其开头加入如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    # Handle strings or subexpressions
    if a.is_a?(Array)
      compile_exp(a)
      return nil # What should we return?
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你这时已经试着用上面的代码来编译测试用例了的话，gcc 会报错给你的，因为我们现在只处理了 &lt;code&gt;#get_arg&lt;/code&gt; 的返回值是一个字符串常量对应的序列号的情况，而这对子表达式来说显然是不适用的。&lt;/p&gt;

&lt;h2 id=&#34;子表达式-步骤二-返回值:05b0e8016c5bc2be24a3301233eda28c&#34;&gt;子表达式，步骤二：返回值&lt;/h2&gt;

&lt;p&gt;那么 gcc 是怎么处理这个的呢。让我们来看看下面这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
  printf(&amp;quot;&#39;Hello world&#39; takes %ld bytes\n&amp;quot;,foo(&amp;quot;Hello world&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所产生的汇编吧（只截取 &lt;code&gt;main&lt;/code&gt; 中相关的部分）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;    subl    $20, %esp
    movl    $.LC0, (%esp)
    call    foo
    movl    %eax, 4(%esp)
    movl    $.LC1, (%esp)
    call    printf
    addl    $20, %esp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该说还是很直观的吧。gcc 首先会去调用子表达式（ &lt;code&gt;foo&lt;/code&gt; ），并且希望这个函数能够把它的返回值放入寄存器 &lt;code&gt;%eax&lt;/code&gt; 中，然后就会把这个值作为参数拷到堆栈上，而不是什么字符串常量的地址。&lt;/p&gt;

&lt;p&gt;首先是要调整 &lt;code&gt;#get_arg&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def get_arg(a)
    # Handle strings and subexpressions
    if a.is_a?(Array)
      compile_exp(a)
      return [:subexpr]
    end
    seq = @string_constants[a]
    return seq if seq
    seq = @seq
    @seq += 1
    @string_constants[a] = seq
    return [:strconst,seq]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唯一需要改动的地方就是返回值了，我们增加了一个表示返回值类型的标识 &amp;ndash; 以后还会加入其他类型的。&lt;/p&gt;

&lt;p&gt;剩下的工作就是改写 &lt;code&gt;#compile_exp&lt;/code&gt; 函数中的相关部分了。这时就不能直接收集 &lt;code&gt;#get_arg&lt;/code&gt; 的返回值了，而是需要对每个参数都做相应的处理并直接输出（而这同时也是 &lt;code&gt;stack_adjustment&lt;/code&gt; 需要修改的原因，因为已经没有 &lt;code&gt;args&lt;/code&gt; 数组了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    stack_adjustment = PTR_SIZE + (((exp.length-1+0.5)*PTR_SIZE/(4.0*PTR_SIZE)).round) * (4*PTR_SIZE)
    puts &amp;quot;\tsubl\t$#{stack_adjustment}, %esp&amp;quot; if exp[0] != :do

    exp[1..-1].each_with_index do |a,i|
      atype, aparam = get_arg(a)
      if exp[0] != :do
        if atype == :strconst
          param = &amp;quot;$.LC#{aparam}&amp;quot;
        else
          param = &amp;quot;%eax&amp;quot;
        end
        puts &amp;quot;\tmovl\t#{param},#{i&amp;gt;0 ? i*4 : &amp;quot;&amp;quot;}(%esp)&amp;quot;
      end
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如你所见，并不是什么复杂的更改。我们只是检查了 &lt;code&gt;#get_arg&lt;/code&gt; 所返回的类型信息，并相应的输出字符串常量或者寄存器 &lt;code&gt;%eax&lt;/code&gt; 而已。随着我们加入更多要处理的情况，这个部分代码还会继续扩充的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.hokstad.com/static/compiler/step3.rb&#34;&gt;你可以在这里找到最新版本的代码&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;之后的计划:05b0e8016c5bc2be24a3301233eda28c&#34;&gt;之后的计划&lt;/h2&gt;

&lt;p&gt;这里只列出的基本完成的部分。我的计划是，当我开始着手写新的部分时，我会将重心放在一个简单的解析器上，以尽快实现编译器的自举（即，编译它自己）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;步骤四：运行时，以及函数的定义&lt;/li&gt;
&lt;li&gt;步骤五：处理其他类型的常量值&lt;/li&gt;
&lt;li&gt;步骤六：条件表达式 &lt;code&gt;if ... then ... else&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;步骤七：循环语句&lt;/li&gt;
&lt;li&gt;步骤八：匿名函数（ &lt;code&gt;lambda&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;步骤九：用匿名函数来实现循环，以及对函数参数的处理&lt;/li&gt;
&lt;li&gt;步骤十：赋值，以及简单的代数运算&lt;/li&gt;
&lt;li&gt;步骤十一：更简结的 &lt;code&gt;while&lt;/code&gt; 循环&lt;/li&gt;
&lt;li&gt;步骤十二：测试我们的语言：开发一个简单的输入转换模块&lt;/li&gt;
&lt;li&gt;步骤十三：重构代码生成模块，并抽象出平台相关的部分&lt;/li&gt;
&lt;li&gt;步骤十四：对一些概念的讨论，以及今后的前进方向&lt;/li&gt;
&lt;li&gt;步骤十五：数组&lt;/li&gt;
&lt;li&gt;步骤十六：局部变量以及多种作用域&lt;/li&gt;
&lt;li&gt;步骤十七：可变长参数列表&lt;/li&gt;
&lt;li&gt;步骤十八：再看输入转换模块：测试新的功能点，以及自我转换&lt;/li&gt;
&lt;li&gt;步骤十九：确定自举所需要实现的功能&lt;/li&gt;
&lt;li&gt;步骤二十：开始实现真正的解析器&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之二：函数调用，以及 Hello World</title>
      <link>https://glacjay.info/post/2011-04-29/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BB%A5%E5%8F%8A-hello-world/</link>
      <pubDate>Fri, 29 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-04-29/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BB%A5%E5%8F%8A-hello-world/</guid>
      <description>

&lt;p&gt;原文地址：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-2.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-2.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我会选择 Ruby 来作为我的实现语言并没有什么特别的理由。在现阶段，语言的选择并不重要；不过，我确实很喜欢 Ruby。&lt;/p&gt;

&lt;p&gt;在这之后，我会采取一系列的步骤令所实现的语言向其实现语言靠拢。我的意思是，我想将编译器实现为可以&lt;strong&gt;自举&lt;/strong&gt;的，即它应该能够编译自身。&lt;/p&gt;

&lt;p&gt;而这也就意味着，要么我的编译器需要至少支持 Ruby 语言的一个子集，要么就需要一个中间的翻译步骤，来将编译器中的实现翻译成它自己可以编译的语言。&lt;/p&gt;

&lt;p&gt;虽然这一点并没有限制你所用的实现语言，但那至少意味着你用来实现的语言跟你要实现的语言之间很相似，除非你对实现编译器的自举没有什么兴趣。&lt;/p&gt;

&lt;p&gt;这也同时意味着，如果你想实现编译器的自举，那你最好不要用实现语言中的什么复杂的特性。要记住，你得实现所有你用过的那些语言特性，不然，当你要开始做自举的时候，你就得对整个编译器的架构做大的调整了。那一点都不好玩。&lt;/p&gt;

&lt;p&gt;话说回来，使用 Ruby 来作为实现语言的一大优点（同样对于其他某些语言来说也是这样，比如说 Lisp ），就是你可以很容易地构建出一个树形的数据结构出来 &amp;ndash; Ruby 的话就是用数组或者哈希， Lisp 的话就是用列表。&lt;/p&gt;

&lt;p&gt;这也就是说，我可以用数组来手工构建抽象语法树，从而避免了实现一个语法分析器的工作。耶！代价就是很丑，不过也可以接受的语法啦。&lt;/p&gt;

&lt;h2 id=&#34;hello-world:e9de4645ccf3bc033ab96239ad817245&#34;&gt;Hello World&lt;/h2&gt;

&lt;p&gt;Hello World 的话看起来会是这个样子的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[:puts, &amp;quot;Hello World&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，我们需要处理的东西非常简单：我们需要将一个参数压入堆栈，然后调用一个函数。&lt;/p&gt;

&lt;p&gt;那么就让我们来看一下怎样用 x86 汇编来做这件事吧。我用 &lt;code&gt;gcc -S&lt;/code&gt; 编译了下面的这段 C 程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
    puts(&amp;quot;Hello World&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后看看输出会是什么样子的。下面给出的是真正相关的部分，是与上一次的输出比较之后的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;        .section        .rodata
.LC0:
        .string &amp;quot;Hello World&amp;quot;
        .text
...
        subl    $4, %esp
        movl    $.LC0, (%esp)
        call    puts
        addl    $4, %esp
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你懂一些汇编的话，就算以前没有写过 x86 的汇编程序，也应该可以很容易的看懂这段代码吧：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这里首先定义了一个字符串常量。&lt;/li&gt;
&lt;li&gt;通过对堆栈指针的减 &lt;code&gt;4&lt;/code&gt; 操作，在堆栈上申请了一段 &lt;code&gt;4&lt;/code&gt; 个字节大小的空间。&lt;/li&gt;
&lt;li&gt;然后将之前定义的字符串常量的地址，放入刚刚申请的那 &lt;code&gt;4&lt;/code&gt; 个字节的空间中。&lt;/li&gt;
&lt;li&gt;接着，我们调用了由 glibc 提供的 &lt;code&gt;puts&lt;/code&gt; 函数（在这个系列中，我会假设你已经有了 gcc/gas + glibc ；Linux 的话这些东东应该已经有了）。&lt;/li&gt;
&lt;li&gt;最后，通过一个加 &lt;code&gt;4&lt;/code&gt; 操作来释放堆栈空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，我们要怎样在我们的编译器中实现这一切呢？首先，我们需要一种方法来处理那些字符串常量，通过在上次的 Compiler 类的实现中添加下面的代码（我的所有 Ruby 代码都在&lt;a href=&#34;http://www.hokstad.com/static/compiler/step2.rb&#34;&gt;这里&lt;/a&gt;，这样你就知道该做什么了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def initialize
    @string_constants = {}
    @seq = 0
  end
  def get_arg(a)
    # For now we assume strings only
    seq = @string_constants[a]
    return seq if seq
    seq = @seq
    @seq += 1
    @string_constants[a] = seq
    return seq
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码就是简单地将一个字符串常量映射到一个整数上，而这个整数则对应着一个标号。相同的字符串常量会对应到相同的整数上，因此也只会被输出一次。用哈希而不是数组来保证这种唯一性是一种很常用的优化手段，不过也不一定非要这样做。&lt;/p&gt;

&lt;p&gt;下面这个函数是用来输出所有的字符串常量的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def output_constants
    puts &amp;quot;\t.section\t.rodata&amp;quot;
    @string_constants.each do |c,seq|
      puts &amp;quot;.LC#{seq}:&amp;quot;
      puts &amp;quot;\t.string \&amp;quot;#{c}\&amp;quot;&amp;quot;
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后剩下的就是编译函数调用的代码了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_exp(exp)
    call = exp[0].to_s
    args = exp[1..-1].collect {|a| get_arg(a)}

    puts &amp;quot;\tsubl\t$4,%esp&amp;quot;

    args.each do |a|
      puts &amp;quot;\tmovl\t$.LC#{a},(%esp)&amp;quot;
    end

    puts &amp;quot;\tcall\t#{call}&amp;quot;
    puts &amp;quot;\taddl\t$4, %esp&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也许你已经注意到这里的不一致性了：上面的代码虽然好像是可以处理多参数调用的样子，但却只从堆栈中减掉了一个 &lt;code&gt;4&lt;/code&gt; ，而不是按照实际的参数个数而进行相应的调整，从而导致了不同参数间的相互覆盖。&lt;/p&gt;

&lt;p&gt;我们马上就会处理这个问题的。对于我们简单的 Hello World 程序来说，目前这样已经足够了。&lt;/p&gt;

&lt;p&gt;在这段代码中还有几点需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们甚至都还没有检查被调用的函数到底存不存在 &amp;ndash; gcc/gas 会帮我们处理这个问题的，虽然这也意味着没啥帮助的错误信息。&lt;/li&gt;
&lt;li&gt;我们可以调用任何一个可以连接的函数，只要这个函数只需一个字符串作为参数。&lt;/li&gt;
&lt;li&gt;这段代码目前还有很多需要被抽像出去的地方，比如说得到被调函数地址的方法，还有所有那些硬编码进来的 x86 汇编等。相信我，我会（慢慢）解决这些问题的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在我们可以来&lt;a href=&#34;http://www.hokstad.com/static/compiler/step2.rb&#34;&gt;试着运行一下这个编译器&lt;/a&gt;了。你应该会得到下面这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;        .text
.globl main
        .type   main, @function
main:
        leal    4(%esp), %ecx
        andl    $-16, %esp
        pushl   -4(%ecx)
        pushl   %ebp
        movl    %esp, %ebp
        pushl   %ecx
        subl    $4,%esp
        movl    $.LC0,(%esp)
        call    puts
        addl    $4, %esp
        popl    %ecx
        popl    %ebp
        leal    -4(%ecx), %esp
        ret
        .size   main, .-main
        .section        .rodata
.LC0:
        .string &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;[vidarh@dev compiler]$ ruby step2.rb &amp;gt;hello.s
[vidarh@dev compiler]$ gcc -o hello hello.s
[vidarh@dev compiler]$ ./hello
Hello World
[vidarh@dev compiler]$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;那么-要怎么处理多个参数的情况呢:e9de4645ccf3bc033ab96239ad817245&#34;&gt;那么，要怎么处理多个参数的情况呢？&lt;/h2&gt;

&lt;p&gt;我不会再展示用来说明的 C 代码和对应的汇编代码了 &amp;ndash; 进行不同参数个数的调用并查看其输出对你来说应该不难。相反，我就直接给出对 compile_exp 函数所做的修改了（完整的代码在&lt;a href=&#34;http://www.hokstad.com/static/compiler/step2b.rb&#34;&gt;这里&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  PTR_SIZE=4
  def compile_exp(exp)
    call = exp[0].to_s

    args = exp[1..-1].collect {|a| get_arg(a)}

    # gcc on i386 does 4 bytes regardless of arguments, and then
    # jumps up 16 at a time, We will blindly do the same.
    stack_adjustment = PTR_SIZE + (((args.length+0.5)*PTR_SIZE/(4.0*PTR_SIZE)).round) * (4*PTR_SIZE)
    puts &amp;quot;\tsubl\t$#{stack_adjustment}, %esp&amp;quot;
    args.each_with_index do |a,i|
      puts &amp;quot;\tmovl\t$.LC#{a},#{i&amp;gt;0 ? i*PTR_SIZE : &amp;quot;&amp;quot;}(%esp)&amp;quot;
    end

    puts &amp;quot;\tcall\t#{call}&amp;quot;
    puts &amp;quot;\taddl\t$#{stack_adjustment}, %esp&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里做了什么呢？改动的地方没几个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这里不再是申请固定大小的堆栈空间了（上一个版本中是 &lt;code&gt;4&lt;/code&gt; 个字节），而是根据实际参数的个数来相应的调整堆栈指针。我得承认，我不知道 gcc 为什么会做这样的调整 &amp;ndash; 而且原因并不重要，虽然我猜这是为了堆栈的对齐。优化和清理&lt;strong&gt;以后&lt;/strong&gt;再说，并且，当你不知道某事的运行机理时，那就不要去改变它。&lt;/li&gt;
&lt;li&gt;这之后，如你所见，参数被一个一个地放到堆栈上了。我们还是假定它们全都是相同大小的指针（因此在 x86 上就是 &lt;code&gt;4&lt;/code&gt; 个字节）。&lt;/li&gt;
&lt;li&gt;同时你还可以看到，第一个参数是被放在堆栈中最靠下的位置的。如果你还没有写过汇编程序，并且无法想象出这是怎么回事的话，那就把它们画出来吧；还要记住，这里的堆栈是向下扩展的。当申请空间时，我们是将堆栈指针向下移动的，而拷贝参数时则是从下往上（用越来越大的索引来访问 &lt;code&gt;%esp&lt;/code&gt; ，就像你访问数组时一样）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个编译器现在已经可以编译下面这样的代码了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[:printf,&amp;quot;Hello %s\n&amp;quot;,&amp;quot;World&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;至于以后嘛:e9de4645ccf3bc033ab96239ad817245&#34;&gt;至于以后嘛&lt;/h2&gt;

&lt;p&gt;这就是我们踏出的第一步，而且我保证之后的步骤会越来越实际的，因为只要实现很少的几个功能点，我们就可以编译实际的程序了。而且我会努力令这些步骤更加精炼，更多的说明这样做的原因，而不是仅仅解释做了什么。&lt;/p&gt;

&lt;p&gt;下面我会处理多个参数的调用（译者：我们不是才处理过嘛），然后是语句序列、子表达式，以及对返回值的处理，等等。&lt;/p&gt;

&lt;p&gt;大约十二个这样难度的步骤之后，我们就会完成函数定义、参数传递、条件判断、运行时库，甚至是一个用来实现匿名函数的简单的 lambda （真正的&lt;a href=&#34;http://en.wikipedia.org/wiki/Closure_(computer_science)&#34;&gt;闭包&lt;/a&gt;就要到后面了）。&lt;/p&gt;

&lt;p&gt;再之后，我们会实现一个简单的文本处理程序，来对一个比 Ruby 的数组和符号更好一点的语法提供支持（只是某种程度啦，真正的语法分析得再多等等）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之一：一个简单的 main 函数模板</title>
      <link>https://glacjay.info/post/2011-04-11/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%80%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-main-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 11 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-04-11/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%80%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-main-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-1.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[译者抱怨：翻译好麻烦啊。]&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我已经将这件事情搁置了很长时间了 &amp;ndash; 这个系列中最早的文章甚至可以追溯到 2005 年的早期，而那时我还没有开始写这个博客呢。&lt;/p&gt;

&lt;p&gt;我灰常喜欢编译器技术，而且我也已经写过好几个小型的编译器了。不久前我开始用 Ruby 语言写一个简单的编译器，而且我也以发表为目的记下了大量的笔记。问题在于，当我一步步地完成这个系列文章的时候，我的博客却渐渐地，没落了（？原文： Problem was I was that by the time I was finishing up the steps I have so far, my blog was languishing, and so it&amp;rsquo;s been just gathering dust. 啊，我的英文好渣）。&lt;/p&gt;

&lt;p&gt;我已经写完了大概 30 篇文章，并形成了一个简单但是可以工作的编译器。我也许要花上一段时间来发表它们，因为这些文章均需要一定程度的整理，而且我能花在写作上的时间不是很多。不过根据具体的时间安排，我也有可能一周就发表好几篇。&lt;/p&gt;

&lt;p&gt;闲话少叙，第一篇参上：&lt;/p&gt;

&lt;h2 id=&#34;有关一些背景-以及一小段代码:c8341cd3ce6d259f088f9fe37556573b&#34;&gt;有关一些背景，以及一小段代码&lt;/h2&gt;

&lt;p&gt;通常，在开始尝试编写一个编译器时，我会选择自顶向下的开发方式。换句话说就是，我会采取常见的策略，从设计一个语法分析器开始，而不管这个分析器是手写的，还是通过分析器生成器来生成。然后我会通过一系列的树形结构转换程序将 &lt;code&gt;AST&lt;/code&gt;（即 &lt;a href=&#34;http://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;Abstract Syntax Tree，抽象语法树&lt;/a&gt;）转化为符号表，同时进行错误检查，为树结点附加各类信息，并最终进行代码生成的步骤。在我转而使用 Linux 之后，我在这里就会选择生成 C 代码，前提是你的语言能够很好的契合 C 的语意。从这里也可以看出，C 是一门多么低层的语言了。&lt;/p&gt;

&lt;p&gt;不过，我的第一个编译器是用 M68000 汇编语言写的，而且其输出也是 M68000 的汇编程序。&lt;/p&gt;

&lt;p&gt;我是从允许内嵌的汇编代码片断开始&lt;a href=&#34;http://en.wikipedia.org/wiki/Bootstrapping_(compilers)&#34;&gt;自举&lt;/a&gt;这个编译器的，并在此基础上逐步地增加所支持的语法结构。&lt;/p&gt;

&lt;p&gt;首先我加入了对函数的定义以及调用的支持，并以此为基础构建我的整个编译器。然后我会增加基于寄存器的基本四则运算的支持，然后是局部变量，等等等等，但在同时也会解析汇编，以保证当遇到内嵌汇编代码片段中的寄存器时，还能够保持寄存器分配器的简洁（原文： but parse the assembly so that the register allocator would stay clear of registers used in the assembler that was interspersed. ）。&lt;/p&gt;

&lt;p&gt;然后这个编译器就从编译汇编语言的语法，逐渐演变成编译我所设计的杂牌语言的语法，其中的汇编也越来越少。&lt;/p&gt;

&lt;p&gt;我想再自举一个编译器出来。不过这次我就不打算用汇编来实现它了。这次我会&lt;strong&gt;从底层 &amp;ndash; 也就是代码生成器 &amp;ndash; 开始&lt;/strong&gt;。并且我会完成如下几个目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实现的简洁性优先于其性能。&lt;/strong&gt;要点在于，我希望能够将它重写为以其自身来实现。换句话说，我希望它能够实现自举（ self hosted ，跟 bootstrap 有啥区别呢？）。由于开始的代码最终会被替换掉，那么也就没有必要浪费时间在使它可以运行的更快上面。性能问题大可以以后再考虑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要做限制性能的决定。&lt;/strong&gt;虽然性能并不是我们最初的目标，但也不能太大意，而导致今后不好对此进行改进。 Ruby ，说的就是你（ Ruby 的运行时非常的动态）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现的简洁性优先于惯例。&lt;/strong&gt;不要仅仅因为一个特性很方便就去实现它，而仅实现那些可以帮助我们完成对编译器的自举的特性。而这就意味着，这些特性要能使我们的生活更加方便，而不仅仅是无谓地增加了实现编译器本身的难度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要急着设计语言，我们要设计的是特性。&lt;/strong&gt;我想首先实现一个灵活而强大的代码生成器，以及一个可以支持各种功能的简洁的 &lt;code&gt;AST&lt;/code&gt; 。我的意思是像 Lisp 语言那样极富表达能力的语法结构，并尽量用 Ruby 来达到相似的目标（这段翻的太渣了，请参考原文）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我并不想深入学习 x86 的汇编语言，虽然我会以其作为我的目标语言。&lt;/strong&gt;这样说有点夸张。我很熟悉 M68K 和 6510 的汇编语言，同时我也具备足够的知识来阅读 x86 的汇编程序。虽然我从来没有用它写过什么像样的代码，而且我也不打算这么做。我所需要知道的一切信息都来自于查看 gcc 产生的汇编输出。要善用 &lt;code&gt;gcc -S&lt;/code&gt; 命令。虽然可能对 x86 的某些细节存在疑问，但我所具备的基础汇编知识已经足够我理解那些个汇编代码了。虽然在此过程中，我很可能会犯一些很愚蠢的错误，但我同时也可以从中学到很多知识（而且那些非常相信能够从我这里学到相关知识的人们也请注意了 - 我在这方面也只是个初学者哦）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;听起来之后貌似会抄很多的小道，同时也会遇到很多痛苦的地方，不是吗？但这同时也会非常有趣哦！&lt;/p&gt;

&lt;p&gt;不管怎样，我们先从一段没什么实际用处的代码开始吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/bin/env ruby
class Compiler

  def compile(exp)
    # Taken from gcc -S output
    puts &amp;lt;&amp;lt;PROLOG
 .file &amp;quot;bootstrap.rb&amp;quot;
 .text
.globl main
 .type main, @function
main:
 leal 4(%esp), %ecx
 andl $-16, %esp
 pushl -4(%ecx)
 pushl %ebp
 movl %esp, %ebp
 pushl %ecx
PROLOG

    puts &amp;lt;&amp;lt;EPILOG
 popl %ecx
 popl %ebp
 leal -4(%ecx), %esp
 ret
EPILOG

    puts &amp;lt;&amp;lt;GLOBAL_EPILOG
 .size main, .-main
GLOBAL_EPILOG
  end
end

prog = [:puts,&amp;quot;Hello World&amp;quot;]

Compiler.new.compile(prog)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，这段代码嘛也没做。它只是把用 &lt;code&gt;gcc -S&lt;/code&gt; 命令将下面这段代码编译出来的结果拆吧拆吧之后给打印出来了而已：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这可是一个完整可工作的编译器哟 &amp;ndash; 某种程度上来说吧。不幸地是，不管用它编译什么程序，得到的都只是一段毫无用处的代码，因些可以说它本身也是同样毫无用处的。但我们总要踏出这最初的一步。&lt;/p&gt;

&lt;p&gt;你可以认为这个系列的文章是我的“意识流”。我做这件事仅仅是因为好玩而已。我并没打算坐下来，好好地完成一个多么赞的设计。我甚至会因为一时兴起而把一段代码给丢掉，或者之后又把它给找回来。&lt;/p&gt;

&lt;p&gt;你在这里将要看到的其实已经是我第二次的代码了：我所做的每一个 SVN 提交都对应于我的一篇文章，不过我会在文章中做很多额外的讲解。有时这些讲解会令我中途改变主意 &amp;ndash; 但我不会对代码做太大的修改，除非我认为这个修改能令我的讲解更清晰，或者我一开始完全就想错掉了。就算是这样，我也多半不会做出修改，除了在那边标注一下我会在之后解决。有些时候，我也会把几个我做起来很麻烦，但解释起来又很简单的步骤合而为一。&lt;/p&gt;

&lt;p&gt;我在这里欢迎大家涌跃发言。不过要记住，虽然我会十分留意您的发言，但我已经完成了这个系列中的很大一部分，我不会因为某些意见而完全重写这些文章。不过我会留下一些笔记，并同时记住我之前都写了些什么内容。&lt;/p&gt;

&lt;p&gt;下次我会让这个编译器真正去处理它的输入的，我保证。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;[译者再次抱怨：翻译好麻烦啊。]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之零</title>
      <link>https://glacjay.info/post/2011-04-10/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E9%9B%B6/</link>
      <pubDate>Sun, 10 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-04-10/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E9%9B%B6/</guid>
      <description>&lt;p&gt;这是一个国外的编译器达人写的一系列教程，内容为用 Ruby 语言，以自底向上的方式开发一个 Ruby 语言的编译器。这个教程非常适合于实战派的程序员。该教程的入口见&lt;a href=&#34;http://www.hokstad.com/compiler&#34;&gt;这里&lt;/a&gt;，其代码见&lt;a href=&#34;https://github.com/vidarh/writing-a-compiler-in-ruby&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我会试着翻译一下这个教程。由于这个项目之后又有了很大的进展，而教程本身却又已经很久没有更新了，所以之后我可能也会自己总结一下那些最新的开发工作。&lt;/p&gt;

&lt;p&gt;使用版本管理软件的好处之一，就是你可以一步一步的学习一个软件的开发过程。不过这个项目用的是 Git，貌似不支持直接将 Working Tree 检出到历史上的某一个版本，所以我就新建了一个分支，然后将主干上的提交一个一个地 merge 到这个新的分支上，这样就可以一个提交一个提交的按顺序把玩这个编译器了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MiniJava 语法中的 non-LALR(1) 的部分及用 Bison 的解决方案</title>
      <link>https://glacjay.info/post/2009-03-22/minijava-%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84-non-lalr1-%E7%9A%84%E9%83%A8%E5%88%86%E5%8F%8A%E7%94%A8-bison-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 22 Mar 2009 22:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2009-03-22/minijava-%E8%AF%AD%E6%B3%95%E4%B8%AD%E7%9A%84-non-lalr1-%E7%9A%84%E9%83%A8%E5%88%86%E5%8F%8A%E7%94%A8-bison-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>&lt;p&gt;我正在看&lt;a href=&#34;http://www.cs.princeton.edu/~appel/modern/java/&#34;&gt;虎书&lt;/a&gt;，在这本书中所给出的那个 &lt;a href=&#34;http://www.cambridge.org/us/features/052182060X/&#34;&gt;MiniJava&lt;/a&gt; 语言的语法并不是 LALR(1) 语法，因此在某些情况下，所生成的语法分析器会对正确的输入给出语法解析错误。不过 Bison 提供了一个简单而又强大的&lt;a href=&#34;http://www.gnu.org/software/bison/manual/html_mono/bison.html#Generalized-LR-Parsing&#34;&gt;解决方案&lt;/a&gt;，可以轻易的解决掉这个问题。&lt;/p&gt;

&lt;p&gt;MiniJava 语法中的 non-LALR(1) 部分其实是一个 &lt;a href=&#34;http://www.gnu.org/software/bison/manual/html_mono/bison.html#Shift_002fReduce&#34;&gt;shift/reduce 冲突&lt;/a&gt;。具体来说就是，在 &lt;a href=&#34;http://www.cambridge.org/us/features/052182060X/grammar.html#prod7&#34;&gt;MethodDeclaration&lt;/a&gt; 中的 (&lt;a href=&#34;http://www.cambridge.org/us/features/052182060X/grammar.html#prod6&#34;&gt;VarDeclaration&lt;/a&gt;)* 和 (&lt;a href=&#34;http://www.cambridge.org/us/features/052182060X/grammar.html#prod5&#34;&gt;Statement&lt;/a&gt;)* 之间的状态下，当 Lookahead Token 是一个 IDENTIFIER 时，如果选择 shift ，那么下一步的动作就是进一步将这个 IDENTIFIER reduce 为一个 Type ，即将这个 IDENTIFIER 看作一个新的变量定义的开始；而如果选择 reduce 的话，实际上就是按照 (Statement)* 中的 epsilon 规则来 reduce ，即结束变量定义部分的解析，转而进入语句定义部分的解析。我们可以看到，仅仅依靠目前的信息，即 IDENTIFIER 这个 Lookahead Token ，是不足以决定接下来的动作的，因此 Bison 的默认策略，即 shift ，就会在某些情况下（这种情况其实很常见，就是当第一条语句是赋值语句时）产生错误的解析步骤。&lt;/p&gt;

&lt;p&gt;这个问题其实很好解决，只要 Bison 能多向前看一个 Token 就可以了，可是 Bison 是 LALR(1) 语法分析器生成器，而不是 LALR(2) 。不过 Bison 提供了另外一条解决问题的途径，就是 GLR - Generalized LR Parsing 。简单来说，就是当 Bison 遇到一个冲突时，不管是 shift/reduce 冲突，还是 &lt;a href=&#34;http://www.gnu.org/software/bison/manual/html_mono/bison.html#Reduce_002fReduce&#34;&gt;reduce/reduce 冲突&lt;/a&gt;，就会将分析路径分为两条，分别跟进两种情况。当其中一条分析路径遇到语法错误，进行不下去时，就会自动消失。如果我们的文法是没有二义性的 LR 文法的话，最后就肯定可以得到正确的分析结果了。而我们的 MiniJava 的文法就是这种情况。说来好像复杂，但用起来其实很简单，只要在我们的 Bison 文法文件中加上 %glr-parser 这个选项就可以了。&lt;/p&gt;

&lt;p&gt;不过奇怪的是，加上这个选项之后，我们就不用再自己写 YYSTYPE 和 YYLTYPE 的定义了，搞不懂，莫非是个 Bug ？&lt;/p&gt;

&lt;p&gt;另外，本来我以为只要将变量定义语句也算到语句中的一种的话，这个问题也可以得到解决，不过后来发现我想错了，这样还是无法处理函数定义中的第一条语句是赋值语句的情况。未经证实，嗯，因为要改的地方还不少。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>对 Bison 手册中的 C&#43;&#43; 的例子的总结</title>
      <link>https://glacjay.info/post/2009-03-19/%E5%AF%B9-bison-%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84-c-%E7%9A%84%E4%BE%8B%E5%AD%90%E7%9A%84%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 19 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2009-03-19/%E5%AF%B9-bison-%E6%89%8B%E5%86%8C%E4%B8%AD%E7%9A%84-c-%E7%9A%84%E4%BE%8B%E5%AD%90%E7%9A%84%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;注意，我用的软件版本为：Bison - 2.4.1，Flex - 2.5.35 。至于老的版本会怎样我就不深究了。工具不是重点。&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;%skeleton &amp;quot;lalr1.cc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%language &amp;quot;c++&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来代替了，其中参数 &amp;ldquo;c++&amp;rdquo; 不区分大小写。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;如我在&lt;a href=&#34;https://glacjay.info/post/2009-03-18/bison-%E4%B8%AD%E7%9A%84-prologue-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%98%E8%BF%81/&#34;&gt;上一篇 Blog&lt;/a&gt; 中所说，分别在 &lt;code&gt;%union&lt;/code&gt; 的前后放不同的 &lt;code&gt;%{ %}&lt;/code&gt; 形式的 Prologue 这种方式对于需要输出头文件的情况已经不适用了，新的方法为在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%code requires { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中放 Bison 定义要用到的 C/C++ 代码，在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%code provides { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中放需要 Bison 定义的 C/C++ 代码。这两部分的代码都会原样输出到生成的头文件中。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在 &lt;code&gt;%code provides&lt;/code&gt; 块中要如下定义 &lt;code&gt;YYSTYPE&lt;/code&gt; 和 &lt;code&gt;YYLTYPE&lt;/code&gt; 这两个类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef yy::Parser::semantic_type YYSTYPE;
typedef yy::Parser::location_type YYLTYPE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不然 Flex 就会抱怨说这两个类型没有声明，我不知道为什么。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这一点我一直有点奇怪，既然在 &lt;code&gt;%option&lt;/code&gt; 中已经指定了 &lt;code&gt;noyywrap&lt;/code&gt; 这个选项，为什么还要对 &lt;code&gt;yywrap&lt;/code&gt; 做 &lt;code&gt;#undef&lt;/code&gt; 再 &lt;code&gt;#define&lt;/code&gt; 的处理呢，也许是之前版本的 Bug 吧，反正我用的这个版本只要指定了那个选项就 OK 了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Flex 中有两个选项是针对与 Bison 之间的配合使用的，就是 &lt;code&gt;bison-bridge&lt;/code&gt; 和 &lt;code&gt;bison-locations&lt;/code&gt; 。不过我是没搞懂这两个选项是怎么用的啦，至少是按照例子中的那样定义 &lt;code&gt;YY_DECL&lt;/code&gt; 这个宏的情况下。按照错误提示更改了 &lt;code&gt;yylex&lt;/code&gt; 的两个参数的名称之后，编译出来的程序会 segmentation fault 的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;其他就没什么说的了，按照例子上的来就可以了。&lt;/p&gt;

&lt;p&gt;PS. 其实有个蛮不错的 Bison 的替代品，叫作 Lemon 的一个 Parser Generator ，是写 SQLite 的那个家伙搞出来的，并且就用在了 SQLite 的实现中。这东东较 Bison 有很多使用上的改进，用起来会很舒服，唯一可惜的就是不自动支持 &lt;code&gt;Location&lt;/code&gt; ，至于这个特性有没有那么重要呢？谁知道，先就这样吧。&lt;/p&gt;

&lt;p&gt;PPS. 其实还是有几个有趣的针对 C++ 后端的 Parser Generator 的，像 YARD 就是一个充分挖掘了 C++ 的模板特性的 Parser 库，用起来感觉会很不一样就是了；Boost.Spirit 则是充分发挥了 C++ 的运算符重载能力的 Parser 库，算的上是 C++ 的 Internal DSL 应用了；再有就是连 Guido 都称赞过的 ANTLR 了，只是为其写 C 后端的那个家伙一直说要完成 C++ 后端又一直不见影子。其实我倒是很想用 ANTLR 这种 Lexer 和 Parser 原生整合在一起的工具的，看回来有时间是不是自己动手实现一个 C++ 的后端出来玩玩。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bison 中的 Prologue 的格式变迁</title>
      <link>https://glacjay.info/post/2009-03-18/bison-%E4%B8%AD%E7%9A%84-prologue-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%98%E8%BF%81/</link>
      <pubDate>Wed, 18 Mar 2009 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2009-03-18/bison-%E4%B8%AD%E7%9A%84-prologue-%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%98%E8%BF%81/</guid>
      <description>&lt;p&gt;今天在用 Bison 手册中的 C++ 例子作为一个编译器前端实现的起点时发现，这个官方示例居然编译通不过，具体错误为在 Bison 生成的头文件中，没有 Driver 类的声明。按照 POSIX Yacc 标准，位于 &lt;code&gt;%union&lt;/code&gt; 块之前的 Prologue 区中的代码，应该会被拷到头文件中的啊，于是 google 半天，在某个地方的 Bison ChangeLog 中找到了线索。&lt;/p&gt;

&lt;p&gt;原来，POSIX Yacc 确实应该符合上述行为，可是 Bison 这家伙为了统一性，从 2.3a 版开始，就把所有 Prologue 中的代码，不管是 %union 前的还是之后的，统统只拷到实现文件中而不管头文件了。而为了对应不同的需求，又新增了一套 Prologue 语法，就是 &lt;code&gt;%before-header&lt;/code&gt; 等四个新的 directive。好吧，这样也不错，以显式的统一格式的声明代替了可能会让人抓狂的隐规则。遂试之，结果告诉我说语法错误。接着往上看 ChangeLog 才发现，到了 2.3b 就又改了，把 &lt;code&gt;%before-header&lt;/code&gt; 改成了 &lt;code&gt;%code&lt;/code&gt; 之类的。这回终于没问题了。&lt;/p&gt;

&lt;p&gt;我说，这也太不厚道了吧，这种兼容性改动，我在它的文档里面扒了半天都没看到半个字，而且还是出现在流行度这么高的软件中。于是深刻体会到「错文档不如无文档」的道理啊。由此看来，要做好软件还是需要有相当的责任感的啊。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>