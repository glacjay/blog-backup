<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Random Stuff from GlacJAY</title>
    <link>https://glacjay.info/tags/linux/</link>
    <description>Recent content in Linux on Random Stuff from GlacJAY</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 21 May 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://glacjay.info/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之六：匿名函数 lambda</title>
      <link>https://glacjay.info/post/2011-05-21/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%85%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-lambda/</link>
      <pubDate>Sat, 21 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-05-21/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%85%AD%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-lambda/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-6.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;既然上次已经提到说，我们其实是在从 Lisp、Scheme 还有类似的其他语言中借鉴各种要实现的功能（我没想过要把这个项目做成原创的⋯⋯或者至少也要等到以后再说吧），那么现在也&lt;strong&gt;是时候&lt;/strong&gt;实现一些更加强大的功能了。&lt;/p&gt;

&lt;h2 id=&#34;那就来做延迟求值以及匿名函数吧:4bbf12fdd90013097351677638258420&#34;&gt;那就来做延迟求值以及匿名函数吧&lt;/h2&gt;

&lt;p&gt;Lambda ，又名匿名函数，可以像普通的数值或者字符串类型那样被当作函数参数来到处传递，也可以在需要的时候才调用（当然不调也可以）。同时，外层函数（也就是定义匿名函数的函数）作为它们的运行环境，在其中定义的局部变量可以被这些匿名函数所访问。这就形成了&lt;a href=&#34;http://en.wikipedia.org/wiki/Closure_(computer_science)&#34;&gt;一个闭包&lt;/a&gt;。我们这次&lt;strong&gt;并不是&lt;/strong&gt;要实现完整的闭包功能，只是开头的一小步而已，完整的实现要等到再后面了。&lt;/p&gt;

&lt;p&gt;其实说到底，正如编程语言中的其他很多功能一样，闭包也只是又一种语法糖而已。比如说，你可以认为这样其实是定义了一个类，这个类中有唯一一个需要被调用的方法，还有一些作为运行环境的成员变量（或者你也可以反过来&lt;a href=&#34;http://strlen.com/bla/index.html&#34;&gt;用闭包来实现面向对象系统&lt;/a&gt; &amp;ndash; 这是由 &lt;a href=&#34;http://strlen.com/&#34;&gt;Wouter van Oortmerssen&lt;/a&gt; 所提出来的观点。自从我发现 &lt;a href=&#34;http://strlen.com/e/index.html&#34;&gt;Amiga E&lt;/a&gt; 这个项目之后，作为作者的他就成了我的偶像。如果你是一个编程语言方面的极客的话，那你就一定要去看看 Wouter 所做过的东西） &amp;ndash; 有很多功能其实都是相互正交的。&lt;/p&gt;

&lt;p&gt;（ blah blah blah ⋯⋯这个人在说自己很啰嗦之类的，就不翻了）&lt;/p&gt;

&lt;p&gt;那么，为了避免定义很多具名小函数的麻烦，同时降低函数重名的概率， lambda 允许你在任何需要它们的地方进行定义，并且返回一个表示所定义函数的值。&lt;/p&gt;

&lt;p&gt;我们现在所要增加的是像下面这样的东西：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(lambda (args) body)
(call f (args))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个表达式会返回所定义的函数（目前来说，其实就是这个函数的起始地址），而不是去执行这个函数。而 &lt;code&gt;call&lt;/code&gt; ，当然就是以指定的参数列表，来调用传给它的那个函数地址。&lt;/p&gt;

&lt;p&gt;那么，这跟“真正”的闭包又有什么区别呢？&lt;/p&gt;

&lt;p&gt;最重要的一点就是，当你在 lambda 中引用了外层作用域中的某个变量后，那么，当以后对同一个 lambda 进行调用时，这个变量还是可以访问的。这样的变量与 lambda 绑定在了一起。当然，只是得到一个函数的地址的话，肯定是实现不了这个功能的。让我们来看一种实现闭包的技术吧，这样你就能够了解大概所要做的工作了（工作量不大，但也不小）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们可以创建一个“环境”，一个存放那些被引用到的外部变量的地方，以使得当外层函数返回之后，它们也可以继续存在。这个环境必须是在堆中，而且每次对外层函数的调用，都需要创建一个新的环境。&lt;/li&gt;
&lt;li&gt;我们必须返回一个可以用来访问这个环境的东西。你可以返回一个对象，其中的成员变量就是被 lambda 引用到的那些变量。或者你也可以用一个 thunk （中文叫啥呢？），也就是自动生成出来的一个包含有指向这个对象指针的小函数，它会在调用我们的 lambda 之前将这个对象加载到预先指定的地方。或者你也可以用什么其他的办法。&lt;/li&gt;
&lt;li&gt;你必须决定有哪些变量需要放入这个环境中。可以是外层函数中的所有局部变量，当然也可以只是那些被引用到的变量。后一种作法可以节省一定的内存空间，但是需要作更多的工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好吧，还是让我们先来把匿名函数本身给弄出来吧。就像以前一样，我会一步一步地说明所要做的修改，但我同时也会对之前的代码做一些整理。这些整理的部分我就不一一说明了。&lt;/p&gt;

&lt;p&gt;首先是对 lambda 表达式本身进行处理的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_lambda args, body
    name = &amp;quot;lambda__#{@seq}&amp;quot;
    @seq += 1
    compile_defun(name, args,body)
    puts &amp;quot;\tmovl\t$#{name},%eax&amp;quot;
    return [:subexpr]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现应该是很容易理解的吧。我们在这里做的，就是给要定义的匿名函数，生成一个形如 &lt;code&gt;lambda__[number]&lt;/code&gt; 的函数名，然后就把它当作一个普通函数来处理了。虽然你也可以就把它生成到外层函数的函数体中，但我发现那样做的话，就会显得很乱的样子，所以我现在还是就把它作为单独的函数来处理了。然后我们调用 &lt;code&gt;#compile_defun&lt;/code&gt; 方法来处理这个函数，这样的话，这个函数其实也就只有对用户来说，才是真正匿名的了。然后我们把这个函数的地址保存在寄存器 &lt;code&gt;%eax&lt;/code&gt; 中，这里同时也是我们存放子表达式结果的地方。当然，这是一种很懒的作法啦，我们迟早需要为复杂的表达式，实现更加强大的处理机制的。但寄存器分配果然还是很麻烦的一件事情，所以现在就先这样吧（将所有的中间结果压入栈中也是一种可行的作法啦，不过那样比较慢）。&lt;/p&gt;

&lt;p&gt;最后，我们返回一个 &lt;code&gt;[:subexpr]&lt;/code&gt; ，来告拆调用者到哪边可以得到这个 lambda 的值。&lt;/p&gt;

&lt;p&gt;之后是一些重构。你也许已经注意到了， &lt;code&gt;#compile_exp&lt;/code&gt; 中的代码有点乱，因为要处理不同类型的参数。让我们把这部分代码给提取出来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_eval_arg arg
    atype, aparam = get_arg(arg)
    return &amp;quot;$.LC#{aparam}&amp;quot; if atype == :strconst
    return &amp;quot;$#{aparam}&amp;quot; if atype == :int
    return aparam.to_s if atype == :atom
    return &amp;quot;%eax&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是，这里又出现了一个新的 &lt;code&gt;:atom&lt;/code&gt; 类型。借助于此，我们就可以把一个 C 函数的地址传给 &lt;code&gt;:call&lt;/code&gt; 指令了。反正实现起来也很简单。当然，我们还要在 &lt;code&gt;#get_arg&lt;/code&gt; 方法中加上如下代码，以使其生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    return [:atom, a] if (a.is_a?(Symbol))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，作为重构的一部分，对 &lt;code&gt;:call&lt;/code&gt; 的处理被分离了出来，成为一个单独的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_call func, args
    stack_adjustment = PTR_SIZE + (((args.length+0.5)*PTR_SIZE/(4.0*PTR_SIZE)).round) * (4*PTR_SIZE)
    puts &amp;quot;\tsubl\t$#{stack_adjustment}, %esp&amp;quot;
    args.each_with_index do |a,i|
      param = compile_eval_arg(a)
      puts &amp;quot;\tmovl\t#{param}, #{i&amp;gt;0 ? i*4 : &amp;quot;&amp;quot;}(%esp)&amp;quot;
    end

    res = compile_eval_arg(func)
    res = &amp;quot;*%eax&amp;quot; if res == &amp;quot;%eax&amp;quot; # Ugly. Would be nicer if retain some knowledge of what res contains.
    puts &amp;quot;\tcall\t#{res}&amp;quot;
    puts &amp;quot;\taddl\t#{stack_adjustment}, %esp&amp;quot;
    return [:subexpr]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来很熟悉对不对？因为它就是原来的 &lt;code&gt;#compile_exp&lt;/code&gt; 方法，只不过是用 &lt;code&gt;#compile_eval_arg&lt;/code&gt; 替换掉了其中的一些代码。另外有改动的地方，就是同时也用 &lt;code&gt;#compile_eval_arg&lt;/code&gt; 方法来得到要调用的函数，并对可能得到的 &lt;code&gt;%eax&lt;/code&gt; 做了些手脚，在前面加了个星号。&lt;/p&gt;

&lt;p&gt;如果你知道这是怎么回事的话，你也许已经开始寻思其他的点子了，而不管那是真正的好事，还只是开枪打自己的脚。上面的代码其实就相当于，你把任意一个表达式的值当作指向一段代码的指针，然后也不做任何的检查，就直接跳过去执行它。如果是往一个随机的地址进行跳转的话，你最有可能得到的就是一个段错误了。当然，你也可以很容易地通过这项技术，来实现面向对象系统中的虚函数跳转表，或者其他的什么东西。因此，安全性将会是以后必须要考虑的东西。还有就是，要实现对一个地址（而不是函数名）的间接调用，你必须要在这个地址前面加上星号。&lt;/p&gt;

&lt;p&gt;那么，现在的 &lt;code&gt;#compile_exp&lt;/code&gt; 方法变成什么样子了呢？简单来说就是，变得整齐多了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_do(*exp)
    exp.each { |e| compile_exp(e) }
    return [:subexpr]
  end
  def compile_exp(exp)
    return if !exp || exp.size == 0
    return compile_do(*exp[1..-1]) if exp[0] == :do
    return compile_defun(*exp[1..-1]) if exp[0] == :defun
    return compile_ifelse(*exp[1..-1]) if exp[0] == :if
    return compile_lambda(*exp[1..-1]) if exp[0] == :lambda
    return compile_call(exp[1], exp[2]) if exp[0] == :call
    return compile_call(exp[0], *exp[1..-1])
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来很不错，不是吗？&lt;code&gt;#compile_call&lt;/code&gt; 几乎跟之前的 &lt;code&gt;#compile_exp&lt;/code&gt; 一模一样，只不过是把一些代码给提取出来，成为了辅助方法而已。&lt;/p&gt;

&lt;p&gt;那么就来简单地测试一下吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:do,
  [:call, [:lambda, [], [:puts, &amp;quot;Test&amp;quot;]], [] ]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（看起来也没那么糟不是吗？）&lt;/p&gt;

&lt;p&gt;编译运行之：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ ruby step6.rb &amp;gt;step6.s
$ make step6
cc      step6.s  -o step6
$ ./step6
Test
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这篇的代码在&lt;a href=&#34;http://www.hokstad.com/static/compiler/step6.rb&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;之后的部分:4bbf12fdd90013097351677638258420&#34;&gt;之后的部分&lt;/h2&gt;

&lt;p&gt;因为我合并了几篇文章，下面就列一下更新过后的，“已经写完但还需要整理的”文章列表。因为我肯定还会合并下面的某些部分的，所以我想我需要找时间开始写一些新的部分了（为了完成我所定下的 30 篇的计划）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;步骤七：再看用匿名函数实现循环，以及对函数参数的访问&lt;/li&gt;
&lt;li&gt;步骤八：实现赋值语句以及简单的四则运算&lt;/li&gt;
&lt;li&gt;步骤九：一个更简洁的 &lt;code&gt;while&lt;/code&gt; 循环语句&lt;/li&gt;
&lt;li&gt;步骤十：测试这个语言：实现一个简单的输入转换模块&lt;/li&gt;
&lt;li&gt;步骤十一：重构代码生成器，分离架构相关的部分&lt;/li&gt;
&lt;li&gt;步骤十二：对某些功能点的讨论，以及未来的前进方向&lt;/li&gt;
&lt;li&gt;步骤十三：实现数组&lt;/li&gt;
&lt;li&gt;步骤十四：局部变量以及多重作用域&lt;/li&gt;
&lt;li&gt;步骤十五：访问变长参数列表&lt;/li&gt;
&lt;li&gt;步骤十六：再看输入转换模块，重构以支持新功能，并用其解析它自己&lt;/li&gt;
&lt;li&gt;步骤十七：总结实现自举所需要的功能点&lt;/li&gt;
&lt;li&gt;步骤十八：开始实现真正的解析器&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之五：整数常量，以及 if 语句</title>
      <link>https://glacjay.info/post/2011-05-17/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Tue, 17 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-05-17/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%94%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%E4%BB%A5%E5%8F%8A-if-%E8%AF%AD%E5%8F%A5/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-5.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-5.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;上次我承诺会发布的更快一些，不过还是失败了⋯⋯作为补偿，这章的内容将会是原计划中的第 5，6，7 章内容的合并，因为这三章确实都很短。闲话少叙：&lt;/p&gt;

&lt;h2 id=&#34;处理数字常量:a8d5e417469934211fedda17d3824d8d&#34;&gt;处理数字常量&lt;/h2&gt;

&lt;p&gt;到目前为止，我们只处理了一些实现所必须的数字常量，也就是当一个外部函数的返回值是数字的情况，而且没有做任何形式的类型检查。&lt;/p&gt;

&lt;p&gt;那么，就让我们来看一下 gcc 在 C 语言中是怎样处理各种类型（包括 &lt;code&gt;long long&lt;/code&gt; 等）的整数的吧。当然，这次还是针对 32 位的 x86 架构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void foo1(unsigned short a) {}
void foo2(signed short a) {}
void foo3(unsigned int a) {}
void foo4(signed int a) {}
void foo5(unsigned long a) {}
void foo6(signed long a) {}
void foo7(unsigned long long a) {}
void foo8(signed long long a) {}

int main()
{
  foo1(1);
  foo2(2);
  foo3(3);
  foo4(4);
  foo5(5);
  foo6(6);
  foo7(7);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我略掉了大部分 gcc 所生成的代码，如果愿意，你可以自己执行 &lt;code&gt;gcc -S&lt;/code&gt; 命令来看。有趣的部分是对各个函数的调用，其生成的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;        movl    $1, (%esp)
        call    foo1
        movl    $2, (%esp)
        call    foo2
        movl    $3, (%esp)
        call    foo3
        movl    $4, (%esp)
        call    foo4
        movl    $5, (%esp)
        call    foo5
        movl    $6, (%esp)
        call    foo6
        movl    $7, (%esp)
        movl    $0, 4(%esp)
        call    foo7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，至少在处理函数调用的时候，gcc 都会把各种整数类型统一作为 32 位的整型来处理，除了 &lt;code&gt;long long&lt;/code&gt; 类型之外。因此，我们可以暂时忘掉 &lt;code&gt;long long&lt;/code&gt; 类型，而只处理 32 位以内的整数值，这样我们就可以忽略类型处理相关的东西了。&lt;/p&gt;

&lt;p&gt;懒惰还真是一种病啊。&lt;/p&gt;

&lt;p&gt;我们同时也会略过浮点型。为什么呢？因为只要有整数运算，你就可以实现一个完整的编译器了，所以现在就加入对浮点型的支持完全只是浪费时间而已。当然这个东西以后总归是要做的。&lt;/p&gt;

&lt;p&gt;另外，当&lt;strong&gt;我&lt;/strong&gt;还年轻时，我们连 FPU 是啥都还不知道呢。尽管如此，我们依然可以用整数来模拟各种定点运算，一样可以完成很多事情。&lt;/p&gt;

&lt;p&gt;那么，我们真正要做的修改有哪些呢？&lt;/p&gt;

&lt;p&gt;在方法 &lt;code&gt;#get_arg&lt;/code&gt; 中，在处理字符串常量之前，加入如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    return [:int, a] if (a.is_a?(Fixnum))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在方法 &lt;code&gt;#compile_exp&lt;/code&gt; 中，我们用如下代码来处理 &lt;code&gt;#get_arg&lt;/code&gt; 的返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    elsif atype == :int then param = &amp;quot;$#{aparam}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，就完事了。就这么简单。&lt;/p&gt;

&lt;p&gt;然后就是测试啦：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:do,
  [:printf,&amp;quot;&#39;hello world&#39; takes %ld bytes\n&amp;quot;,[:strlen, &amp;quot;hello world&amp;quot;]],
  [:printf,&amp;quot;The above should show _%ld_ bytes\n&amp;quot;,11]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;插曲-针对原生数据类型的一些思考:a8d5e417469934211fedda17d3824d8d&#34;&gt;插曲：针对原生数据类型的一些思考&lt;/h2&gt;

&lt;p&gt;“纯”面向对象类型的语言很棒，但并不是对底层的代码生成器而言的，我想。不管你是否想要实现一个纯的面向对象语言，我仍然坚信，首先实现原生的数据类型和其操作，是非常有价值的。你可以在后面的阶段再来考虑是否要对用户隐藏它们，或者是让它们看起来像是对象，或者是透明地在它们和对象之间执行自动转换的操作，等等。&lt;/p&gt;

&lt;p&gt;要注意的是，Matz 的 Ruby 解释器（Matz Ruby Interpreter，简称MRI）就是这样实现的：里面的数字就跟“真正的”对象神马的完全不一样，但是解释器本身却尽其所能的对用户隐藏这一事实。不过我个人认为 MRI 做的还是不够。&lt;/p&gt;

&lt;h2 id=&#34;if-then-else:a8d5e417469934211fedda17d3824d8d&#34;&gt;&lt;code&gt;If ... then ... else&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;如果没有某种形式的条件逻辑支持的话，我们的语言是没有太大用处的。几乎所有有用的语言都支持某种形式的 &lt;code&gt;if .. then .. else&lt;/code&gt; 构造。现在，我们要实现的是像 &lt;code&gt;[:if, condition, if-arm, else-arm]&lt;/code&gt; 这样的构造，而且是以 C 语言的形式来实现。也就是说， &lt;code&gt;0&lt;/code&gt; 和空指针都表示假，其他值则都为真。&lt;/p&gt;

&lt;p&gt;仍然是一个简单的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void foo() {}
void bar() {}
int main()
{
  if (baz()) {
    foo();
  } else {
    bar();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相关的汇编输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;        call    baz
        testl   %eax, %eax
        je      .L6
        call    foo
        jmp     .L10
.L6:
        call    bar
.L10:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于大多数的语言和架构来说，这都是一个编译 &lt;code&gt;if .. then .. else&lt;/code&gt; 时会采用的通用模板：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算条件表达式。&lt;/li&gt;
&lt;li&gt;对结果进行测试（这里用的是 &lt;code&gt;testl&lt;/code&gt; 指令 &amp;ndash; 在其他架构中比较通用的还有 &lt;code&gt;cmp&lt;/code&gt; 指令，或者对寄存器进行自减）。 &lt;code&gt;testl&lt;/code&gt; 指令比较它的左右两个操作数，并进行相应的标志位设置。&lt;/li&gt;
&lt;li&gt;然后，条件跳转到 &lt;strong&gt;&lt;code&gt;else&lt;/code&gt; 语句处。这里，我们检查条件表达式的值是否不为真。在这种情况下我们用的是 &lt;code&gt;je&lt;/code&gt; 指令，即“相等时跳转”（ jump on equal ），也就是当结果相等时跳转（要注意的是，在大多数的 CPU 架构中，很多指令都会设置条件码，而不仅仅是显示的测试指令）。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后执行 &lt;code&gt;then&lt;/code&gt; 子句。&lt;/li&gt;
&lt;li&gt;跳过 &lt;code&gt;else&lt;/code&gt; 子句，继续执行整个 &lt;code&gt;if&lt;/code&gt; 语句之后的部分。&lt;/li&gt;
&lt;li&gt;生成 &lt;code&gt;else&lt;/code&gt; 子句的标号，以及其中的指令序列。&lt;/li&gt;
&lt;li&gt;生成 &lt;code&gt;if&lt;/code&gt; 语句的结束标号。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他还有很多不同的变种，比如根据条件表达式取值的概率，或者某个架构中是否跳转的执行代价，进而调整两个子句的顺序等。不过就目前来说，上面的方法已经足够了。&lt;/p&gt;

&lt;p&gt;总之，编译的方法还是很简单的，应该说就是以上所述流程的直译：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def ifelse cond, if_arg,else_arm
    compile_exp(cond)
    puts &amp;quot;\ttestl\t%eax, %eax&amp;quot;
    @seq += 2
    else_arm_seq = @seq - 1
    end_if_arm_seq = @seq
    puts &amp;quot;\tje\t.L#{else_arm_seq}&amp;quot;
    compile_exp(if_arm)
    puts &amp;quot;\tjmp\t.L#{end_if_arm_seq}&amp;quot;
    puts &amp;quot;.L#{else_arm_seq}:&amp;quot;
    compile_exp(else_arm)
    puts &amp;quot;.L#{end_if_arm_seq}:&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码应该很易懂的，其实就是对所有子句 &amp;ndash; 条件， &lt;code&gt;then&lt;/code&gt; 子句，以及 &lt;code&gt;else&lt;/code&gt; 子句 &amp;ndash; 分别调用 &lt;code&gt;#compile_exp&lt;/code&gt; 方法，并在其间插入所需的辅助指令，同时用 &lt;code&gt;@seq&lt;/code&gt; 成员来生成所需的标号。&lt;/p&gt;

&lt;p&gt;为了使其生效，我们在 &lt;code&gt;#compile_exp&lt;/code&gt; 方法中的 &lt;code&gt;return defun ...&lt;/code&gt; 之后插入如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    return ifelse(*exp[1..-1]) if (exp[0] == :if)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个简单的测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:do,
  [:if, [:strlen,&amp;quot;&amp;quot;],
    [:puts, &amp;quot;IF: The string was not empty&amp;quot;],
    [:puts, &amp;quot;ELSE: The string was empty&amp;quot;]
  ],
  [:if, [:strlen,&amp;quot;Test&amp;quot;],
    [:puts, &amp;quot;Second IF: The string was not empty&amp;quot;],
    [:puts, &amp;quot;Second IF: The string was empty&amp;quot;]
  ]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.hokstad.com/static/compiler/step5.rb&#34;&gt;这里是最终结果&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如往常般，执行的方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ ruby step5.rb &amp;gt;step5.s
$ make step5
cc   step5.s   -o step5
$ ./step5
ELSE: The string was empty
Second IF: The string was not empty
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;有关循环的一些思考:a8d5e417469934211fedda17d3824d8d&#34;&gt;有关循环的一些思考&lt;/h2&gt;

&lt;p&gt;非条件循环是很容易实现的，不过我们需要实现它吗？显然不需要。我们已经可以用递归来实现循环了，又何必要乱加东西呢？&lt;/p&gt;

&lt;p&gt;不过，要令它工作良好，我们还需要实现尾递归优化，可是我现在还没有做好准备。尾递归优化，或者更一般的形式 &amp;ndash; 尾调用优化 &amp;ndash; 所说的情况是，在一个函数的末尾，调用了一个需要相同或者更少个数参数的函数，并返回它所返回的值。在这种情况下，你可以将当前函数的调用栈，复用给被调用的函数来使用，并且是通过 &lt;code&gt;jmp&lt;/code&gt; 而不是 &lt;code&gt;call&lt;/code&gt; 来调用这个函数。 &lt;code&gt;jmp&lt;/code&gt; 指令不会在堆栈中压入一个新的返回地址，因此当这个被调用的函数返回，返回到的就是当前函数的调用者那里，而不是当前的这个函数。&lt;/p&gt;

&lt;p&gt;这就同时完成了几件事情：首先，也是最重要的，就是堆栈不再会随着调用而增长了。其次，我们能够省掉几个指令周期。有了尾调用优化，再配合其他几个优化之后，你就可以这样来写循环，而不用担心堆栈溢出的问题了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[:defun, :loop, [], [:do,
  [:puts, &amp;quot;I am all loopy&amp;quot;],
  [:loop]
],
[:loop]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，尾调用优化意味着，对任何形如 &lt;code&gt;(defun foo () (do bar foo))&lt;/code&gt; 的函数来说，堆栈的使用率都会从原来的成比例增长减少为定值了。&lt;/p&gt;

&lt;p&gt;当前的版本已经可以编译上面的代码了，不过它会很快用完堆栈并且崩溃掉的。不是很令人满意啊。&lt;/p&gt;

&lt;p&gt;果然（原文： I sense a disturbance in the force ），两位读到这篇文章的极客都指出了堆栈增长的问题。&lt;/p&gt;

&lt;p&gt;现在，让我们先忽略这个问题吧，同时注意下对堆栈空间的使用好了。之后，我们会实现一个专门的循环结构的。目前就这样吧 &amp;ndash; 如果以后我实现了尾调用优化的话，我们还可以重新考虑在运行时库中实现一个循环构造的方案。&lt;/p&gt;

&lt;p&gt;不管怎样，我们现在可以写出一个无限循环了⋯⋯不是太有用，不是吗？&lt;/p&gt;

&lt;p&gt;当然，我们其实也已经可以写 &lt;code&gt;while&lt;/code&gt; 循环了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cl&#34;&gt;(defun some-while-loop () (if condition (some-while-loop) ()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来不是太好，不过确实可以工作。但看起来总归还是太丑了，所以我们总归还是要实现一个正尔八经的 &lt;code&gt;while&lt;/code&gt; 循环的。&lt;/p&gt;

&lt;p&gt;我不是一个 Lisp 程序员。我没办法处理那么多的括号⋯⋯不过 Lisp 的语法确实很适合于一门还没有语法的语言。到了一定的阶段之后，我会实现一个完整的解析器的。也许是出于偶然，我已经实现的和将要实现的很多东西在某种程度上来说都是取自于 Lisp 的，至少看起来是这样的。如果你能适应 Lisp 的语法的话，这个语言还是非常强大的。就算你不打算用它来开发你的程序，好好地学一下这门语言也是非常值得的。&lt;/p&gt;

&lt;p&gt;在我想来，很多看起来像是从 Lisp 中得来的点子，大概都是来自于我花在学习 Lisp 的有限经验。&lt;/p&gt;

&lt;p&gt;下一篇：匿名函数，也许不止。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之四：自定义函数，以及运行时支持</title>
      <link>https://glacjay.info/post/2011-05-09/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%9B%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81/</link>
      <pubDate>Mon, 09 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-05-09/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E5%9B%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E6%94%AF%E6%8C%81/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-4.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-4.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;抱歉，又拖了很长时间。要忙的事情实在很多。正如上一篇文章末尾提到的那样，这次要讲的是自定义函数，以及一个简单的“运行时库”。&lt;/p&gt;

&lt;h2 id=&#34;自定义函数:a1905e7840a324707222cc702f5afc30&#34;&gt;自定义函数&lt;/h2&gt;

&lt;p&gt;一门编程语言如果连函数和方法都没有的话，那也就不能算是一门语言了。而且，实践表明，一门面向对象语言中的所有特性都可以通过过程式的语言要素来实现：一个方法也只不过是以一个对象为额外参数的函数而已。因此，增加对函数的支持就是实现一门语言的核心所在。&lt;/p&gt;

&lt;p&gt;其实，这个东东也是很简单的啦。跟以前一样，还是让我们来看一下 C 语言中的函数是怎么实现的吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void foo()
{
  puts(&amp;quot;Hello world&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gcc 生成的汇编代码是这个样子滴：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;.globl foo
        .type   foo, @function
foo:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $8, %esp
        movl    $.LC0, (%esp)
        call    puts
        leave
        ret
        .size   foo, .-foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的函数调用现在应该很容易认了吧。剩下的就是简单的样板代码了：&lt;/p&gt;

&lt;p&gt;在函数的开头，首先是将寄存器 &lt;code&gt;%ebp&lt;/code&gt; 压入堆栈，然后拷贝寄存器 &lt;code&gt;%esp&lt;/code&gt; 到 &lt;code&gt;%ebp&lt;/code&gt; 。而在函数的最后， &lt;code&gt;leave&lt;/code&gt; 指令就是前面两条指令的逆操作，而 &lt;code&gt;ret&lt;/code&gt; 指令则是从堆栈中弹出要返回到的指令地址（也就是调用该函数的那条指令的下一条指令）并跳转。为什么在这里要将 &lt;code&gt;%esp&lt;/code&gt; （也就是堆栈指针）拷到 &lt;code&gt;%ebp&lt;/code&gt; 呢？嘛，一个很明显的好处就是你可以尽情的申请堆栈空间，然后在完事时简单地将 &lt;code&gt;%ebp&lt;/code&gt; 拷回给 &lt;code&gt;%esp&lt;/code&gt; 就行了。从上面就可以看到， GCC 已经充分利用了这一点，直接用 &lt;code&gt;leave&lt;/code&gt; 指令来处理调用函数时对参数所申请的空间 &amp;ndash; 反正手工释放也只是浪费时间而已。&lt;/p&gt;

&lt;p&gt;这么说来的话，要做的事情应该就很简单了啊。&lt;/p&gt;

&lt;p&gt;首先需要修改方法 &lt;code&gt;Compiler#initialize&lt;/code&gt; ，创建一个用来保存所有函数定义的哈希：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def initialize
    @global_functions = {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后增加一个输出所有函数定义的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def output_functions
    @global_functions.each do |name,data|
      puts &amp;quot;.globl #{name}&amp;quot;
      puts &amp;quot;.type   #{name}, @function&amp;quot;
      puts &amp;quot;#{name}:&amp;quot;
      puts &amp;quot;\tpushl   %ebp&amp;quot;
      puts &amp;quot;\tmovl    %esp, %ebp&amp;quot;
      compile_exp(data[1])
      puts &amp;quot;\tleave&amp;quot;
      puts &amp;quot;\tret&amp;quot;
      puts &amp;quot;\t.size   #{name}, .-#{name}&amp;quot;
      puts
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，这里也同时包括了 &lt;code&gt;.globl&lt;/code&gt; 与 &lt;code&gt;.type&lt;/code&gt; 与 &lt;code&gt;.size&lt;/code&gt; 之类的东西。 &lt;code&gt;.globl&lt;/code&gt; 的意思就是你想让这个函数也能够从其他文件（也就是编译单元）中调用，这在链接多个目标文件的时候是很重要的。我想 &lt;code&gt;.type&lt;/code&gt; 和 &lt;code&gt;.size&lt;/code&gt; 主要是用在调试的时候，分别用来表示一个符号对应的是一个函数，以及这个函数的大小。&lt;/p&gt;

&lt;p&gt;除了这些之外，这个方法就很简单啦 &amp;ndash; 它会通过调用 &lt;code&gt;#compile_exp&lt;/code&gt; 方法来完成实际的工作。&lt;/p&gt;

&lt;p&gt;我们再来增加一个用来定义函数的辅助方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def defun name, args, body
    @global_functions[name] = [args, body]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在方法 &lt;code&gt;#compile_exp&lt;/code&gt; 中增加如下的几行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    return if !exp || exp.size == 0
    return defun(*exp[1..-1]) if (exp[0] == :defun)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之所以要增加第一行代码，一方面是出于健壮性的考虑，同时这也允许我们用 &lt;code&gt;nil&lt;/code&gt; 和空数组来表示“啥也不做”的意思，当你要定义一个空函数的时候就会用到这一点了。这样一来，第二行代码就不需要去检查将要定义的是不是一个空函数了。&lt;/p&gt;

&lt;p&gt;不知道你注意到了没有，我们其实已经实现了对函数的递归定义。像 &lt;code&gt;[:defun,:foo,[:defun, :bar, []]]&lt;/code&gt; 这样的代码完全是合法的。同时你也许会注意到，这个实现会导致两个函数其实都是可以从别处调用的。好吧，现在是没关系的啦，我们以后会处理这个的（要么不允许编写这样的代码，要么就只允许外层函数来调用内层函数 &amp;ndash; 我还没有决定到底要做哪个啦）。&lt;/p&gt;

&lt;p&gt;剩下的事情就是输出这些函数的定义了，因此我们在方法 &lt;code&gt;#compile&lt;/code&gt; 中对 &lt;code&gt;#output_constants&lt;/code&gt; 的调用之前增加如下的一行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    output_functions
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;增加对一个运行时库的支持:a1905e7840a324707222cc702f5afc30&#34;&gt;增加对一个运行时库的支持&lt;/h2&gt;

&lt;p&gt;首先，让我们将现在的 &lt;code&gt;#compile&lt;/code&gt; 方法重命名为 &lt;code&gt;#compile_main&lt;/code&gt; ，然后重新定义 &lt;code&gt;#compile&lt;/code&gt; 方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile(exp)
    compile_main([:do, DO_BEFORE, exp, DO_AFTER])
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后是对常量 &lt;code&gt;DO_BEFORE&lt;/code&gt; 和 &lt;code&gt;DO_AFTER&lt;/code&gt; 的定义（如果愿意的话，你也可以把它们放在一个单独的文件中，我现在就直接把它们放在开头好了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;DO_BEFORE= [:do,
  [:defun, :hello_world,[], [:puts, &amp;quot;Hello World&amp;quot;]]
]
DO_AFTER= []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你得承认，你想看到的应该是更加高级一些的东东，但那样就违背我们最初的目标了。上面的代码对于实现一个运行时库来说已经足够了。当然，你也可以用一些只能通过 C 或者汇编才能实现的东西，只要把包含那些函数实现的目标文件给链接进来就可以了，因为我们一直都是在按照 C 语言的调用规则来办事的嘛。&lt;/p&gt;

&lt;p&gt;让我们来测试一下吧。在 &lt;code&gt;Compiler.new.compile(prog)&lt;/code&gt; 的前面加入下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:hello_world]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后编译运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ ruby step4.rb &amp;gt;step4.s
$ make step4
cc    step4.s   -o step4
$ ./step4
Hello World
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在&lt;a href=&#34;http://www.hokstad.com/static/compiler/step4.rb&#34;&gt;这里&lt;/a&gt;找到今天的成果。&lt;/p&gt;

&lt;h2 id=&#34;对函数参数的访问吗:a1905e7840a324707222cc702f5afc30&#34;&gt;对函数参数的访问吗？&lt;/h2&gt;

&lt;p&gt;今天还遗留了一个任务：实现对函数参数的访问。这个的工作量可是不小的。放心，我不会忘了这个的，这将会是第八篇文章的主题。我也不会让你等太久的啦，这次一定 :-)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之三：语句序列，以及子表达式</title>
      <link>https://glacjay.info/post/2011-05-02/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%89%E8%AF%AD%E5%8F%A5%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 02 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-05-02/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%89%E8%AF%AD%E5%8F%A5%E5%BA%8F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up---step-3.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up&amp;mdash;step-3.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;我本来是想要早点发表的，可是我这周又不行了 &amp;ndash; 虽然整理一篇旧文只需要半个小时。不管怎样，这是第三章，而且我会在末尾大概列一下之后的大纲。由于我会试着把一些小的步骤组合成更有内容的章节（下面就有个这样的例子），因此原来的 30 篇文章已经被我给减到了 20 篇左右（当然，这只是我已经完成了的，后面还有新的呢）。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;用-do-语句将表达式给串起来:05b0e8016c5bc2be24a3301233eda28c&#34;&gt;用 do 语句将表达式给串起来&lt;/h2&gt;

&lt;p&gt;到目前为止，&lt;a href=&#34;http://www.hokstad.com/static/compiler/step2b.rb&#34;&gt;上次的第二版程序&lt;/a&gt;只能编译一个单独的表达式。只是这样的话，并不是非常的有用啊。因此我决定实现一种支持顺序执行的结构，就像函数体那样的。当然，如你所想，这是很简单的。我会增加一个关键字 &lt;code&gt;do&lt;/code&gt; ，而其作用就是顺序执行传给它的每一个（个数不限哦，或者说，只受限于内存的大小）参数表达式。看起来就像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:do,
  [:printf,&amp;quot;Hello&amp;quot;],
  [:printf,&amp;quot; &amp;quot;],
  [:printf,&amp;quot;World\n&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要实现这个是非常简单的。我们只需要在函数 &lt;code&gt;#compile_exp&lt;/code&gt; 的开头加入下列代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    if exp[0] == :do
      exp[1..-1].each { |e| compile_exp(e) }
      return
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;递归在这里的作用很重要哦 &amp;ndash; 毕竟你是在处理一个树形结构，那也就需要在越来越深层的树结点之上调用实现编译的核心函数，而这当然也包括我们的下一个目标，即对子表达式的处理。&lt;/p&gt;

&lt;h2 id=&#34;子表达式-步骤一:05b0e8016c5bc2be24a3301233eda28c&#34;&gt;子表达式，步骤一&lt;/h2&gt;

&lt;p&gt;先来给出一个我们想要支持的用例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;prog = [:printf,&amp;quot;‘hello world’ takes %ld bytes\n&amp;quot;,[:strlen, “hello world&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个需要改变的地方，在函数 &lt;code&gt;#get_arg&lt;/code&gt; 中，我们在其开头加入如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    # Handle strings or subexpressions
    if a.is_a?(Array)
      compile_exp(a)
      return nil # What should we return?
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你这时已经试着用上面的代码来编译测试用例了的话，gcc 会报错给你的，因为我们现在只处理了 &lt;code&gt;#get_arg&lt;/code&gt; 的返回值是一个字符串常量对应的序列号的情况，而这对子表达式来说显然是不适用的。&lt;/p&gt;

&lt;h2 id=&#34;子表达式-步骤二-返回值:05b0e8016c5bc2be24a3301233eda28c&#34;&gt;子表达式，步骤二：返回值&lt;/h2&gt;

&lt;p&gt;那么 gcc 是怎么处理这个的呢。让我们来看看下面这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
  printf(&amp;quot;&#39;Hello world&#39; takes %ld bytes\n&amp;quot;,foo(&amp;quot;Hello world&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所产生的汇编吧（只截取 &lt;code&gt;main&lt;/code&gt; 中相关的部分）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;    subl    $20, %esp
    movl    $.LC0, (%esp)
    call    foo
    movl    %eax, 4(%esp)
    movl    $.LC1, (%esp)
    call    printf
    addl    $20, %esp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该说还是很直观的吧。gcc 首先会去调用子表达式（ &lt;code&gt;foo&lt;/code&gt; ），并且希望这个函数能够把它的返回值放入寄存器 &lt;code&gt;%eax&lt;/code&gt; 中，然后就会把这个值作为参数拷到堆栈上，而不是什么字符串常量的地址。&lt;/p&gt;

&lt;p&gt;首先是要调整 &lt;code&gt;#get_arg&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def get_arg(a)
    # Handle strings and subexpressions
    if a.is_a?(Array)
      compile_exp(a)
      return [:subexpr]
    end
    seq = @string_constants[a]
    return seq if seq
    seq = @seq
    @seq += 1
    @string_constants[a] = seq
    return [:strconst,seq]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;唯一需要改动的地方就是返回值了，我们增加了一个表示返回值类型的标识 &amp;ndash; 以后还会加入其他类型的。&lt;/p&gt;

&lt;p&gt;剩下的工作就是改写 &lt;code&gt;#compile_exp&lt;/code&gt; 函数中的相关部分了。这时就不能直接收集 &lt;code&gt;#get_arg&lt;/code&gt; 的返回值了，而是需要对每个参数都做相应的处理并直接输出（而这同时也是 &lt;code&gt;stack_adjustment&lt;/code&gt; 需要修改的原因，因为已经没有 &lt;code&gt;args&lt;/code&gt; 数组了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;    stack_adjustment = PTR_SIZE + (((exp.length-1+0.5)*PTR_SIZE/(4.0*PTR_SIZE)).round) * (4*PTR_SIZE)
    puts &amp;quot;\tsubl\t$#{stack_adjustment}, %esp&amp;quot; if exp[0] != :do

    exp[1..-1].each_with_index do |a,i|
      atype, aparam = get_arg(a)
      if exp[0] != :do
        if atype == :strconst
          param = &amp;quot;$.LC#{aparam}&amp;quot;
        else
          param = &amp;quot;%eax&amp;quot;
        end
        puts &amp;quot;\tmovl\t#{param},#{i&amp;gt;0 ? i*4 : &amp;quot;&amp;quot;}(%esp)&amp;quot;
      end
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如你所见，并不是什么复杂的更改。我们只是检查了 &lt;code&gt;#get_arg&lt;/code&gt; 所返回的类型信息，并相应的输出字符串常量或者寄存器 &lt;code&gt;%eax&lt;/code&gt; 而已。随着我们加入更多要处理的情况，这个部分代码还会继续扩充的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.hokstad.com/static/compiler/step3.rb&#34;&gt;你可以在这里找到最新版本的代码&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;之后的计划:05b0e8016c5bc2be24a3301233eda28c&#34;&gt;之后的计划&lt;/h2&gt;

&lt;p&gt;这里只列出的基本完成的部分。我的计划是，当我开始着手写新的部分时，我会将重心放在一个简单的解析器上，以尽快实现编译器的自举（即，编译它自己）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;步骤四：运行时，以及函数的定义&lt;/li&gt;
&lt;li&gt;步骤五：处理其他类型的常量值&lt;/li&gt;
&lt;li&gt;步骤六：条件表达式 &lt;code&gt;if ... then ... else&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;步骤七：循环语句&lt;/li&gt;
&lt;li&gt;步骤八：匿名函数（ &lt;code&gt;lambda&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;步骤九：用匿名函数来实现循环，以及对函数参数的处理&lt;/li&gt;
&lt;li&gt;步骤十：赋值，以及简单的代数运算&lt;/li&gt;
&lt;li&gt;步骤十一：更简结的 &lt;code&gt;while&lt;/code&gt; 循环&lt;/li&gt;
&lt;li&gt;步骤十二：测试我们的语言：开发一个简单的输入转换模块&lt;/li&gt;
&lt;li&gt;步骤十三：重构代码生成模块，并抽象出平台相关的部分&lt;/li&gt;
&lt;li&gt;步骤十四：对一些概念的讨论，以及今后的前进方向&lt;/li&gt;
&lt;li&gt;步骤十五：数组&lt;/li&gt;
&lt;li&gt;步骤十六：局部变量以及多种作用域&lt;/li&gt;
&lt;li&gt;步骤十七：可变长参数列表&lt;/li&gt;
&lt;li&gt;步骤十八：再看输入转换模块：测试新的功能点，以及自我转换&lt;/li&gt;
&lt;li&gt;步骤十九：确定自举所需要实现的功能&lt;/li&gt;
&lt;li&gt;步骤二十：开始实现真正的解析器&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之二：函数调用，以及 Hello World</title>
      <link>https://glacjay.info/post/2011-04-29/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BB%A5%E5%8F%8A-hello-world/</link>
      <pubDate>Fri, 29 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-04-29/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%BA%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E4%BB%A5%E5%8F%8A-hello-world/</guid>
      <description>

&lt;p&gt;原文地址：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-2.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-2.html&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我会选择 Ruby 来作为我的实现语言并没有什么特别的理由。在现阶段，语言的选择并不重要；不过，我确实很喜欢 Ruby。&lt;/p&gt;

&lt;p&gt;在这之后，我会采取一系列的步骤令所实现的语言向其实现语言靠拢。我的意思是，我想将编译器实现为可以&lt;strong&gt;自举&lt;/strong&gt;的，即它应该能够编译自身。&lt;/p&gt;

&lt;p&gt;而这也就意味着，要么我的编译器需要至少支持 Ruby 语言的一个子集，要么就需要一个中间的翻译步骤，来将编译器中的实现翻译成它自己可以编译的语言。&lt;/p&gt;

&lt;p&gt;虽然这一点并没有限制你所用的实现语言，但那至少意味着你用来实现的语言跟你要实现的语言之间很相似，除非你对实现编译器的自举没有什么兴趣。&lt;/p&gt;

&lt;p&gt;这也同时意味着，如果你想实现编译器的自举，那你最好不要用实现语言中的什么复杂的特性。要记住，你得实现所有你用过的那些语言特性，不然，当你要开始做自举的时候，你就得对整个编译器的架构做大的调整了。那一点都不好玩。&lt;/p&gt;

&lt;p&gt;话说回来，使用 Ruby 来作为实现语言的一大优点（同样对于其他某些语言来说也是这样，比如说 Lisp ），就是你可以很容易地构建出一个树形的数据结构出来 &amp;ndash; Ruby 的话就是用数组或者哈希， Lisp 的话就是用列表。&lt;/p&gt;

&lt;p&gt;这也就是说，我可以用数组来手工构建抽象语法树，从而避免了实现一个语法分析器的工作。耶！代价就是很丑，不过也可以接受的语法啦。&lt;/p&gt;

&lt;h2 id=&#34;hello-world:e9de4645ccf3bc033ab96239ad817245&#34;&gt;Hello World&lt;/h2&gt;

&lt;p&gt;Hello World 的话看起来会是这个样子的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[:puts, &amp;quot;Hello World&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里，我们需要处理的东西非常简单：我们需要将一个参数压入堆栈，然后调用一个函数。&lt;/p&gt;

&lt;p&gt;那么就让我们来看一下怎样用 x86 汇编来做这件事吧。我用 &lt;code&gt;gcc -S&lt;/code&gt; 编译了下面的这段 C 程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
    puts(&amp;quot;Hello World&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后看看输出会是什么样子的。下面给出的是真正相关的部分，是与上一次的输出比较之后的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;        .section        .rodata
.LC0:
        .string &amp;quot;Hello World&amp;quot;
        .text
...
        subl    $4, %esp
        movl    $.LC0, (%esp)
        call    puts
        addl    $4, %esp
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你懂一些汇编的话，就算以前没有写过 x86 的汇编程序，也应该可以很容易的看懂这段代码吧：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这里首先定义了一个字符串常量。&lt;/li&gt;
&lt;li&gt;通过对堆栈指针的减 &lt;code&gt;4&lt;/code&gt; 操作，在堆栈上申请了一段 &lt;code&gt;4&lt;/code&gt; 个字节大小的空间。&lt;/li&gt;
&lt;li&gt;然后将之前定义的字符串常量的地址，放入刚刚申请的那 &lt;code&gt;4&lt;/code&gt; 个字节的空间中。&lt;/li&gt;
&lt;li&gt;接着，我们调用了由 glibc 提供的 &lt;code&gt;puts&lt;/code&gt; 函数（在这个系列中，我会假设你已经有了 gcc/gas + glibc ；Linux 的话这些东东应该已经有了）。&lt;/li&gt;
&lt;li&gt;最后，通过一个加 &lt;code&gt;4&lt;/code&gt; 操作来释放堆栈空间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么，我们要怎样在我们的编译器中实现这一切呢？首先，我们需要一种方法来处理那些字符串常量，通过在上次的 Compiler 类的实现中添加下面的代码（我的所有 Ruby 代码都在&lt;a href=&#34;http://www.hokstad.com/static/compiler/step2.rb&#34;&gt;这里&lt;/a&gt;，这样你就知道该做什么了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def initialize
    @string_constants = {}
    @seq = 0
  end
  def get_arg(a)
    # For now we assume strings only
    seq = @string_constants[a]
    return seq if seq
    seq = @seq
    @seq += 1
    @string_constants[a] = seq
    return seq
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码就是简单地将一个字符串常量映射到一个整数上，而这个整数则对应着一个标号。相同的字符串常量会对应到相同的整数上，因此也只会被输出一次。用哈希而不是数组来保证这种唯一性是一种很常用的优化手段，不过也不一定非要这样做。&lt;/p&gt;

&lt;p&gt;下面这个函数是用来输出所有的字符串常量的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def output_constants
    puts &amp;quot;\t.section\t.rodata&amp;quot;
    @string_constants.each do |c,seq|
      puts &amp;quot;.LC#{seq}:&amp;quot;
      puts &amp;quot;\t.string \&amp;quot;#{c}\&amp;quot;&amp;quot;
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后剩下的就是编译函数调用的代码了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def compile_exp(exp)
    call = exp[0].to_s
    args = exp[1..-1].collect {|a| get_arg(a)}

    puts &amp;quot;\tsubl\t$4,%esp&amp;quot;

    args.each do |a|
      puts &amp;quot;\tmovl\t$.LC#{a},(%esp)&amp;quot;
    end

    puts &amp;quot;\tcall\t#{call}&amp;quot;
    puts &amp;quot;\taddl\t$4, %esp&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也许你已经注意到这里的不一致性了：上面的代码虽然好像是可以处理多参数调用的样子，但却只从堆栈中减掉了一个 &lt;code&gt;4&lt;/code&gt; ，而不是按照实际的参数个数而进行相应的调整，从而导致了不同参数间的相互覆盖。&lt;/p&gt;

&lt;p&gt;我们马上就会处理这个问题的。对于我们简单的 Hello World 程序来说，目前这样已经足够了。&lt;/p&gt;

&lt;p&gt;在这段代码中还有几点需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们甚至都还没有检查被调用的函数到底存不存在 &amp;ndash; gcc/gas 会帮我们处理这个问题的，虽然这也意味着没啥帮助的错误信息。&lt;/li&gt;
&lt;li&gt;我们可以调用任何一个可以连接的函数，只要这个函数只需一个字符串作为参数。&lt;/li&gt;
&lt;li&gt;这段代码目前还有很多需要被抽像出去的地方，比如说得到被调函数地址的方法，还有所有那些硬编码进来的 x86 汇编等。相信我，我会（慢慢）解决这些问题的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在我们可以来&lt;a href=&#34;http://www.hokstad.com/static/compiler/step2.rb&#34;&gt;试着运行一下这个编译器&lt;/a&gt;了。你应该会得到下面这样的输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nasm&#34;&gt;        .text
.globl main
        .type   main, @function
main:
        leal    4(%esp), %ecx
        andl    $-16, %esp
        pushl   -4(%ecx)
        pushl   %ebp
        movl    %esp, %ebp
        pushl   %ecx
        subl    $4,%esp
        movl    $.LC0,(%esp)
        call    puts
        addl    $4, %esp
        popl    %ecx
        popl    %ebp
        leal    -4(%ecx), %esp
        ret
        .size   main, .-main
        .section        .rodata
.LC0:
        .string &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;[vidarh@dev compiler]$ ruby step2.rb &amp;gt;hello.s
[vidarh@dev compiler]$ gcc -o hello hello.s
[vidarh@dev compiler]$ ./hello
Hello World
[vidarh@dev compiler]$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;那么-要怎么处理多个参数的情况呢:e9de4645ccf3bc033ab96239ad817245&#34;&gt;那么，要怎么处理多个参数的情况呢？&lt;/h2&gt;

&lt;p&gt;我不会再展示用来说明的 C 代码和对应的汇编代码了 &amp;ndash; 进行不同参数个数的调用并查看其输出对你来说应该不难。相反，我就直接给出对 compile_exp 函数所做的修改了（完整的代码在&lt;a href=&#34;http://www.hokstad.com/static/compiler/step2b.rb&#34;&gt;这里&lt;/a&gt;）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  PTR_SIZE=4
  def compile_exp(exp)
    call = exp[0].to_s

    args = exp[1..-1].collect {|a| get_arg(a)}

    # gcc on i386 does 4 bytes regardless of arguments, and then
    # jumps up 16 at a time, We will blindly do the same.
    stack_adjustment = PTR_SIZE + (((args.length+0.5)*PTR_SIZE/(4.0*PTR_SIZE)).round) * (4*PTR_SIZE)
    puts &amp;quot;\tsubl\t$#{stack_adjustment}, %esp&amp;quot;
    args.each_with_index do |a,i|
      puts &amp;quot;\tmovl\t$.LC#{a},#{i&amp;gt;0 ? i*PTR_SIZE : &amp;quot;&amp;quot;}(%esp)&amp;quot;
    end

    puts &amp;quot;\tcall\t#{call}&amp;quot;
    puts &amp;quot;\taddl\t$#{stack_adjustment}, %esp&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里做了什么呢？改动的地方没几个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这里不再是申请固定大小的堆栈空间了（上一个版本中是 &lt;code&gt;4&lt;/code&gt; 个字节），而是根据实际参数的个数来相应的调整堆栈指针。我得承认，我不知道 gcc 为什么会做这样的调整 &amp;ndash; 而且原因并不重要，虽然我猜这是为了堆栈的对齐。优化和清理&lt;strong&gt;以后&lt;/strong&gt;再说，并且，当你不知道某事的运行机理时，那就不要去改变它。&lt;/li&gt;
&lt;li&gt;这之后，如你所见，参数被一个一个地放到堆栈上了。我们还是假定它们全都是相同大小的指针（因此在 x86 上就是 &lt;code&gt;4&lt;/code&gt; 个字节）。&lt;/li&gt;
&lt;li&gt;同时你还可以看到，第一个参数是被放在堆栈中最靠下的位置的。如果你还没有写过汇编程序，并且无法想象出这是怎么回事的话，那就把它们画出来吧；还要记住，这里的堆栈是向下扩展的。当申请空间时，我们是将堆栈指针向下移动的，而拷贝参数时则是从下往上（用越来越大的索引来访问 &lt;code&gt;%esp&lt;/code&gt; ，就像你访问数组时一样）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个编译器现在已经可以编译下面这样的代码了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;[:printf,&amp;quot;Hello %s\n&amp;quot;,&amp;quot;World&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;至于以后嘛:e9de4645ccf3bc033ab96239ad817245&#34;&gt;至于以后嘛&lt;/h2&gt;

&lt;p&gt;这就是我们踏出的第一步，而且我保证之后的步骤会越来越实际的，因为只要实现很少的几个功能点，我们就可以编译实际的程序了。而且我会努力令这些步骤更加精炼，更多的说明这样做的原因，而不是仅仅解释做了什么。&lt;/p&gt;

&lt;p&gt;下面我会处理多个参数的调用（译者：我们不是才处理过嘛），然后是语句序列、子表达式，以及对返回值的处理，等等。&lt;/p&gt;

&lt;p&gt;大约十二个这样难度的步骤之后，我们就会完成函数定义、参数传递、条件判断、运行时库，甚至是一个用来实现匿名函数的简单的 lambda （真正的&lt;a href=&#34;http://en.wikipedia.org/wiki/Closure_(computer_science)&#34;&gt;闭包&lt;/a&gt;就要到后面了）。&lt;/p&gt;

&lt;p&gt;再之后，我们会实现一个简单的文本处理程序，来对一个比 Ruby 的数组和符号更好一点的语法提供支持（只是某种程度啦，真正的语法分析得再多等等）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[翻译] 用 Ruby 写编译器之一：一个简单的 main 函数模板</title>
      <link>https://glacjay.info/post/2011-04-11/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%80%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-main-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 11 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-04-11/%E7%BF%BB%E8%AF%91-%E7%94%A8-ruby-%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8%E4%B9%8B%E4%B8%80%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-main-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-1.html&#34;&gt;http://www.hokstad.com/writing-a-compiler-in-ruby-bottom-up-step-1.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[译者抱怨：翻译好麻烦啊。]&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我已经将这件事情搁置了很长时间了 &amp;ndash; 这个系列中最早的文章甚至可以追溯到 2005 年的早期，而那时我还没有开始写这个博客呢。&lt;/p&gt;

&lt;p&gt;我灰常喜欢编译器技术，而且我也已经写过好几个小型的编译器了。不久前我开始用 Ruby 语言写一个简单的编译器，而且我也以发表为目的记下了大量的笔记。问题在于，当我一步步地完成这个系列文章的时候，我的博客却渐渐地，没落了（？原文： Problem was I was that by the time I was finishing up the steps I have so far, my blog was languishing, and so it&amp;rsquo;s been just gathering dust. 啊，我的英文好渣）。&lt;/p&gt;

&lt;p&gt;我已经写完了大概 30 篇文章，并形成了一个简单但是可以工作的编译器。我也许要花上一段时间来发表它们，因为这些文章均需要一定程度的整理，而且我能花在写作上的时间不是很多。不过根据具体的时间安排，我也有可能一周就发表好几篇。&lt;/p&gt;

&lt;p&gt;闲话少叙，第一篇参上：&lt;/p&gt;

&lt;h2 id=&#34;有关一些背景-以及一小段代码:c8341cd3ce6d259f088f9fe37556573b&#34;&gt;有关一些背景，以及一小段代码&lt;/h2&gt;

&lt;p&gt;通常，在开始尝试编写一个编译器时，我会选择自顶向下的开发方式。换句话说就是，我会采取常见的策略，从设计一个语法分析器开始，而不管这个分析器是手写的，还是通过分析器生成器来生成。然后我会通过一系列的树形结构转换程序将 &lt;code&gt;AST&lt;/code&gt;（即 &lt;a href=&#34;http://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;Abstract Syntax Tree，抽象语法树&lt;/a&gt;）转化为符号表，同时进行错误检查，为树结点附加各类信息，并最终进行代码生成的步骤。在我转而使用 Linux 之后，我在这里就会选择生成 C 代码，前提是你的语言能够很好的契合 C 的语意。从这里也可以看出，C 是一门多么低层的语言了。&lt;/p&gt;

&lt;p&gt;不过，我的第一个编译器是用 M68000 汇编语言写的，而且其输出也是 M68000 的汇编程序。&lt;/p&gt;

&lt;p&gt;我是从允许内嵌的汇编代码片断开始&lt;a href=&#34;http://en.wikipedia.org/wiki/Bootstrapping_(compilers)&#34;&gt;自举&lt;/a&gt;这个编译器的，并在此基础上逐步地增加所支持的语法结构。&lt;/p&gt;

&lt;p&gt;首先我加入了对函数的定义以及调用的支持，并以此为基础构建我的整个编译器。然后我会增加基于寄存器的基本四则运算的支持，然后是局部变量，等等等等，但在同时也会解析汇编，以保证当遇到内嵌汇编代码片段中的寄存器时，还能够保持寄存器分配器的简洁（原文： but parse the assembly so that the register allocator would stay clear of registers used in the assembler that was interspersed. ）。&lt;/p&gt;

&lt;p&gt;然后这个编译器就从编译汇编语言的语法，逐渐演变成编译我所设计的杂牌语言的语法，其中的汇编也越来越少。&lt;/p&gt;

&lt;p&gt;我想再自举一个编译器出来。不过这次我就不打算用汇编来实现它了。这次我会&lt;strong&gt;从底层 &amp;ndash; 也就是代码生成器 &amp;ndash; 开始&lt;/strong&gt;。并且我会完成如下几个目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实现的简洁性优先于其性能。&lt;/strong&gt;要点在于，我希望能够将它重写为以其自身来实现。换句话说，我希望它能够实现自举（ self hosted ，跟 bootstrap 有啥区别呢？）。由于开始的代码最终会被替换掉，那么也就没有必要浪费时间在使它可以运行的更快上面。性能问题大可以以后再考虑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要做限制性能的决定。&lt;/strong&gt;虽然性能并不是我们最初的目标，但也不能太大意，而导致今后不好对此进行改进。 Ruby ，说的就是你（ Ruby 的运行时非常的动态）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现的简洁性优先于惯例。&lt;/strong&gt;不要仅仅因为一个特性很方便就去实现它，而仅实现那些可以帮助我们完成对编译器的自举的特性。而这就意味着，这些特性要能使我们的生活更加方便，而不仅仅是无谓地增加了实现编译器本身的难度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要急着设计语言，我们要设计的是特性。&lt;/strong&gt;我想首先实现一个灵活而强大的代码生成器，以及一个可以支持各种功能的简洁的 &lt;code&gt;AST&lt;/code&gt; 。我的意思是像 Lisp 语言那样极富表达能力的语法结构，并尽量用 Ruby 来达到相似的目标（这段翻的太渣了，请参考原文）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我并不想深入学习 x86 的汇编语言，虽然我会以其作为我的目标语言。&lt;/strong&gt;这样说有点夸张。我很熟悉 M68K 和 6510 的汇编语言，同时我也具备足够的知识来阅读 x86 的汇编程序。虽然我从来没有用它写过什么像样的代码，而且我也不打算这么做。我所需要知道的一切信息都来自于查看 gcc 产生的汇编输出。要善用 &lt;code&gt;gcc -S&lt;/code&gt; 命令。虽然可能对 x86 的某些细节存在疑问，但我所具备的基础汇编知识已经足够我理解那些个汇编代码了。虽然在此过程中，我很可能会犯一些很愚蠢的错误，但我同时也可以从中学到很多知识（而且那些非常相信能够从我这里学到相关知识的人们也请注意了 - 我在这方面也只是个初学者哦）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;听起来之后貌似会抄很多的小道，同时也会遇到很多痛苦的地方，不是吗？但这同时也会非常有趣哦！&lt;/p&gt;

&lt;p&gt;不管怎样，我们先从一段没什么实际用处的代码开始吧：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#!/bin/env ruby
class Compiler

  def compile(exp)
    # Taken from gcc -S output
    puts &amp;lt;&amp;lt;PROLOG
 .file &amp;quot;bootstrap.rb&amp;quot;
 .text
.globl main
 .type main, @function
main:
 leal 4(%esp), %ecx
 andl $-16, %esp
 pushl -4(%ecx)
 pushl %ebp
 movl %esp, %ebp
 pushl %ecx
PROLOG

    puts &amp;lt;&amp;lt;EPILOG
 popl %ecx
 popl %ebp
 leal -4(%ecx), %esp
 ret
EPILOG

    puts &amp;lt;&amp;lt;GLOBAL_EPILOG
 .size main, .-main
GLOBAL_EPILOG
  end
end

prog = [:puts,&amp;quot;Hello World&amp;quot;]

Compiler.new.compile(prog)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说实话，这段代码嘛也没做。它只是把用 &lt;code&gt;gcc -S&lt;/code&gt; 命令将下面这段代码编译出来的结果拆吧拆吧之后给打印出来了而已：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这可是一个完整可工作的编译器哟 &amp;ndash; 某种程度上来说吧。不幸地是，不管用它编译什么程序，得到的都只是一段毫无用处的代码，因些可以说它本身也是同样毫无用处的。但我们总要踏出这最初的一步。&lt;/p&gt;

&lt;p&gt;你可以认为这个系列的文章是我的“意识流”。我做这件事仅仅是因为好玩而已。我并没打算坐下来，好好地完成一个多么赞的设计。我甚至会因为一时兴起而把一段代码给丢掉，或者之后又把它给找回来。&lt;/p&gt;

&lt;p&gt;你在这里将要看到的其实已经是我第二次的代码了：我所做的每一个 SVN 提交都对应于我的一篇文章，不过我会在文章中做很多额外的讲解。有时这些讲解会令我中途改变主意 &amp;ndash; 但我不会对代码做太大的修改，除非我认为这个修改能令我的讲解更清晰，或者我一开始完全就想错掉了。就算是这样，我也多半不会做出修改，除了在那边标注一下我会在之后解决。有些时候，我也会把几个我做起来很麻烦，但解释起来又很简单的步骤合而为一。&lt;/p&gt;

&lt;p&gt;我在这里欢迎大家涌跃发言。不过要记住，虽然我会十分留意您的发言，但我已经完成了这个系列中的很大一部分，我不会因为某些意见而完全重写这些文章。不过我会留下一些笔记，并同时记住我之前都写了些什么内容。&lt;/p&gt;

&lt;p&gt;下次我会让这个编译器真正去处理它的输入的，我保证。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;[译者再次抱怨：翻译好麻烦啊。]&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>总结一下学到的 LVS 相关知识（ DR 模式）</title>
      <link>https://glacjay.info/post/2011-03-13/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-dr-%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 13 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-03-13/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-dr-%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;不喜欢看长的 Blog 文章，当然更不喜欢写，所以就分开写啦。另，因为 TUN 模式限制更多，实际很可能用不到，所以不一定会写。&lt;/p&gt;

&lt;p&gt;所以这次要讲的是 DR 模式的负载均衡啦。 DR 模式，也就是 Direct Route ，其基本原理就是不对包做任何处理，直接转给所分配的真实服务；回包则由真实服务直接发给客户端而不走负载机。因为不像 NAT 模式那样有相似的架构可以参考，所以这次就上图来说明啦（注，该图偷自&lt;a href=&#34;http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/LVS-HOWTO.LVS-DR.html&#34;&gt;这里&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;
                           ________
                          |        |
                          | client |
                          |________|
                          CIP=192.168.1.254
                              |
                   CIP-&amp;gt;VIP | |
                            v |
                              |
                           ________
                          |        |
                          | router | advertises route to VIP
                          |________|
                              |
                __________    |
               |          |   |    VIP=192.168.1.110 (eth0:0, arps)
               | director |---+     DIP=192.168.1.1 (eth0)
               |__________|   |
                              |  ^
MAC_DIP-&amp;gt;MAC_RIP1(CIP-&amp;gt;VIP) | |  |  VIP-&amp;gt;CIP
                            v |
                              |
             +----------------+------------------+
             |                |                  |
             |                |                  |
      RIP1=192.168.1.2  RIP2=192.168.1.3  RIP3=192.168.1.4 (eth0)
      VIP=192.168.1.110 VIP=192.168.1.110 VIP=192.168.1.110 (all lo:0, non-arping)
      _____________     _____________      _____________
     |             |   |             |    |             |
     |   CIP-&amp;gt;VIP  |   |             |    |             |
     |   VIP-&amp;gt;CIP  |   |             |    |             |
     | realserver  |   | realserver  |    | realserver  |
     |_____________|   |_____________|    |_____________|

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，负载机（即图中的 &lt;code&gt;director&lt;/code&gt; ）需要将服务发布地址配置成网卡的从地址 &lt;code&gt;VIP&lt;/code&gt;（我还不太清楚为什么不能直接配成第一地址），以便接收来自客户端的 IP 报文。然后，它会根据分配置策略选择一个真实服务器（即图中的 &lt;code&gt;realserver&lt;/code&gt; ），并将这个 IP 报文直接转发过去，而这就需要真实服务器也有一个从地址配置成 &lt;code&gt;VIP&lt;/code&gt; （一般都配到 &lt;code&gt;lo&lt;/code&gt; 网口上）。可是，大家都是在一个网段的，如果没有什么措施的话，那一开始来自客户端的目的地址为 &lt;code&gt;VIP&lt;/code&gt; 的 IP 报文就不知道要由谁来处理了。所以，在真实服务器上都要把 &lt;code&gt;lo&lt;/code&gt; 这个网卡的 ARP 广播与响应功能给禁掉，让客户端不知道真实服务器也有 &lt;code&gt;VIP&lt;/code&gt; 这个地址。而负载机则是通过真实服务器的真实地址（非 &lt;code&gt;VIP&lt;/code&gt; ）得知它的 MAC 地址，进而进行转发的。&lt;/p&gt;

&lt;p&gt;而当真实服务器需要往回发报文的时候，因为与客户端之间并不像 NAT 那样不在同一网段，也没有被负载机隔来，所以回应报文就通过正常途径直接到了客户端的手（网口？）中。&lt;/p&gt;

&lt;p&gt;这样一来，相比 NAT 模式而言，其额外的配置工作主要就是 &lt;code&gt;VIP&lt;/code&gt; 从地址的配置以及 ARP 相关功能的禁用了。让我们一步一步来吧。首先是负载机的 &lt;code&gt;VIP&lt;/code&gt; 配置（真实地址的配置就跟正常的一样，不写了）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ifconfig eth0:0 192.168.1.110 broadcast 192.168.1.110 netmask 255.255.255.255
$ sudo route add -host 192.168.1.110 eth0:0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是真实服务器的 &lt;code&gt;VIP&lt;/code&gt; 配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ifconfig lo:0 192.168.1.110 broadcast 192.168.1.110 netmask 255.255.255.255
$ sudo route add -host 192.168.1.110 eth0:0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与负载机唯一不同的就是要把地址配到 &lt;code&gt;lo&lt;/code&gt; 上。接下来是禁掉这个网卡的 ARP 相关的功能（这里就用不了 &lt;code&gt;sudo&lt;/code&gt; 了，必须直接用 &lt;code&gt;root&lt;/code&gt; 用户，不知道为嘛）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# echo 1 &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_ignore
# echo 2 &amp;gt; /proc/sys/net/ipv4/conf/lo/arp_announce
# echo 1 &amp;gt; /proc/sys/net/ipv4/conf/all/arp_ignore
# echo 2 &amp;gt; /proc/sys/net/ipv4/conf/all/arp_announce
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然更好的办法是修改 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 文件，然后执行 &lt;code&gt;sysctl -p&lt;/code&gt; 命令来使修改生效。这样做的好处是配置被保存下来了，下次开机还有效，而且也可以用 &lt;code&gt;sudo&lt;/code&gt; 来做。&lt;/p&gt;

&lt;p&gt;地址配完了，最后就是 ipvsadm 本身的配置了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ipvsadm -A -t 192.168.1.110:22 -s rr
$ sudo ipvsadm -a -t 192.168.1.110:22 -r 192.168.1.2:22 -g
$ sudo ipvsadm -a -t 192.168.1.110:22 -r 192.168.1.3:22 -g
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，跟 NAT 模式唯一的不同就是 &lt;code&gt;-g&lt;/code&gt; 选项，表示 DR 模式。因为是默认选项，所以不写 &lt;code&gt;-g&lt;/code&gt; 也可以。&lt;/p&gt;

&lt;p&gt;TCP 服务的话这样就可以了，可是 UDP 服务却还有一些问题需要解决。正如上面所说，服务端发给客户端的回包是不经过负载的，这样的话，如果这个服务程序没有绑定到特定网卡的话，这个回包的源地址默认就是服务器本身的真实地址（如 &lt;code&gt;192.168.1.2&lt;/code&gt; ）了，而这样的回包一般是不会被客户端所接受的，因为客户端当初可是往 &lt;code&gt;VIP&lt;/code&gt; 这个地址发的请求包。而最通用的解决方法就是将该服务显式绑定到 &lt;code&gt;VIP&lt;/code&gt; 这个地址上，强迫其回包的源地址为 &lt;code&gt;VIP&lt;/code&gt; ，而这正是客户端所希望看到的。&lt;/p&gt;

&lt;p&gt;由上可知，DR 模式相对 NAT 模式而言，对真实服务器来说就是侵入式的配置方式，增加了不少配置工作和限制，而其性能方面的优势据说在现在也大大降低了。因此一般应用的话，直接用 NAT 模式就可以了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>总结一下学到的 LVS 相关知识（ NAT 模式）</title>
      <link>https://glacjay.info/post/2011-03-12/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-nat-%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 12 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-03-12/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AD%A6%E5%88%B0%E7%9A%84-lvs-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86-nat-%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;LVS，即 Linux Virtual Server 的简称，是 Linux 下用来实现负载均衡的一个项目。它支持三种负载模式，分别为 NAT 、 DR 以及 TUN 。&lt;/p&gt;

&lt;p&gt;注意，我这里讲的都是针对的 2.6 的内核， 2.4 、 2.2 、 2.0 版内核的实现方法和配置方法都各有不一样的地方。还好我不需要维护历史遗留系统（擦汗）。&lt;/p&gt;

&lt;p&gt;首先是最简单的 NAT 模式。这种模式跟普通的 NAT 防火墙的原理差不多，只不过它会根据指定的分配策略，为每一个新的客户端连接选择一个不同的真实服务，而不是像 NAT 防火墙那样只映射到后台的同一个真实服务。&lt;/p&gt;

&lt;p&gt;这种模式下最常用的部署方式为，负载均衡机器上分别启用两块网卡，一块外网，一块内网。当然一块网卡也可以，然后在这块网卡上配两个地址。这里假设外网地址为 &lt;code&gt;192.168.0.1&lt;/code&gt; ，内网地址为 &lt;code&gt;192.168.1.1&lt;/code&gt; 。两个真实服务器的地址分别为 &lt;code&gt;192.168.1.2&lt;/code&gt; 以及 &lt;code&gt;192.168.1.3&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;这样，要对两台服务器的 SSH 服务进行负载均衡的话，负载机器上要执行的命令如下（当然你得先安装 &lt;code&gt;ipvsadm&lt;/code&gt; 这个命令才行。负载功能的实现还是在内核中做的，跟 &lt;code&gt;iptables&lt;/code&gt; 一样）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ sudo ipvsadm -A -t 192.168.0.1:22 -s rr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-A&lt;/code&gt; 表示增加一个新的负载均衡服务，一台负载均衡器上可以同时对多个服务进行负载； &lt;code&gt;-t&lt;/code&gt; 表示这是一个 TCP 服务； &lt;code&gt;-s rr&lt;/code&gt; 表示选择 Round Robin 分配策略。 Round Robin 是最简单的一种分配策略，表示在每台真实服务器间进行轮流选择；其他还有最少连接等策略。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ipvsadm -a -t 192.168.0.1:22 -r 192.168.1.2:22 -m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-a&lt;/code&gt; 表示为指定的负载服务增加一个新的真实服务； &lt;code&gt;-t&lt;/code&gt; 同上； &lt;code&gt;-r&lt;/code&gt; 指定真实服务的地址和端口； &lt;code&gt;-m&lt;/code&gt; 则表示这个真实服务采用的是 NAT 模式的负载均衡。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ipvsadm -a -t 192.168.0.1:22 -r 192.168.1.3:22 -m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样负载均衡服务就配置好了。当然，记得还要打开系统的 IP 转发功能，不管你用的是哪种负载均衡。真实服务器上则还需要配置路由规则，把回给客户端的路由通过 &lt;code&gt;192.168.1.1&lt;/code&gt; 这个网关进行发送（不指定网关地址，只指定网口是不行的）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo route add -net 192.168.0.0/24 gw 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种模式的优点，当然就在于配置简单啦，跟配置 NAT 防火墙基本相同，缺点是有对网络报文的额外处理（替换目的地址）的开销。不过据说 2.6 的内核其开销已经很小了。&lt;/p&gt;

&lt;p&gt;用如下命令可以查看当前的负载状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ipvsadm -l -n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一点要说的是，当负载的是 UDP 服务（如 OpenVPN ）时，建立起来的连接会显示在“非活动连接”那一栏，不知道为什么。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>发布一个寻找局域网内主机的小工具</title>
      <link>https://glacjay.info/post/2011-03-05/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E5%AF%BB%E6%89%BE%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sat, 05 Mar 2011 22:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-03-05/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E5%AF%BB%E6%89%BE%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;p&gt;在工作中，经常需要远程登录到机房中的设备上进行调试与开发，走的是工作局域网。由于这些设备的地址也是动态获取的，因此在遇到一些意外事故，如网线松了、网络不稳定之类的，这些地址可能就变了。每当这时，我们就得跑到机房，给设备连上显示器（我们连 KVM 都没有，命苦啊），查看 IP ，然后再跑回去重新连。太麻烦了。&lt;/p&gt;

&lt;p&gt;我知道有支持动态地址的 DNS 服务，可是我们没权限操作 DNS 服务器，而且设备也都是不固定的，没必要惊动网络管理员（好吧，我甚至都不知道谁是网络管理员，作为三年的“老”员工，我面壁去了。好吧，其实我就是想写写程序练练手），所以我就写了个小程序，用来查找一台特定设备的 IP 地址。&lt;/p&gt;

&lt;p&gt;原理其实很简单啦。客户端（也就是我的笔记本）发个 UDP 广播报文，里面有要找的主机的名字。服务端呢，启动时则指定一个主机名字。当服务端收到一个 UDP 广播报文，并且发现找的就是自己呢，就返回一个 &lt;code&gt;bingo&lt;/code&gt; 报文。这样，客户端就知道这个主机的 IP 地址啦。&lt;/p&gt;

&lt;p&gt;现在用的服务端口是 &lt;code&gt;5460&lt;/code&gt; （取自某本网络小说 :-），应该没有哪个知名服务用这个端口吧。当然，因为这个工具确实太简单了，所以就没有考虑冲突的情况啦。请大家在使用的时候，给主机取个有个性的名字哟。&lt;/p&gt;

&lt;p&gt;我通过这个程序学到的新知识就是，要发送 UDP 的广播报文，只是指定一个全 &lt;code&gt;1&lt;/code&gt; 的地址是不够的，还要设置 socket 选项 &lt;code&gt;SO_BROADCAST&lt;/code&gt; （我继续面壁去了）。&lt;/p&gt;

&lt;p&gt;下面是代码（好撑篇幅啊，又没人给我稿费的说）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;

#define PORT 5460

static char *progname;
static int sock;

static void usage(void)
{
    fprintf(stderr,
            &amp;quot;Usage: %s options\n&amp;quot;
            &amp;quot;where options must be one of:\n&amp;quot;
            &amp;quot;  -s         Running as a  named server.\n&amp;quot;
            &amp;quot;  -c         Asking for &#39;s address.\n&amp;quot;,
            progname);
    exit(1);
}

static int udp_socket(void)
{
    int sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (sock == -1) {
        fprintf(stderr, &amp;quot;Cannot open a new socket: %s\n&amp;quot;, strerror(errno));
        exit(1);
    }
    return sock;
}

static void server(const char *name)
{
    struct sockaddr_in listen_addr;

    listen_addr.sin_family = AF_INET;
    listen_addr.sin_addr.s_addr = INADDR_ANY;
    listen_addr.sin_port = htons(PORT);

    if (bind(sock, (struct sockaddr *) &amp;amp;listen_addr,
             sizeof(listen_addr)) == -1)
    {
        fprintf(stderr, &amp;quot;Cannot bind to the UDP port %d: %s\n&amp;quot;,
                PORT, strerror(errno));
        exit(1);
    }

    while (1) {
        char buf[BUFSIZ+1];
        struct sockaddr_in addr;
        int addrlen = sizeof(addr);
        int received;

        received = recvfrom(sock, buf, sizeof(buf)-1, 0,
                            (struct sockaddr *) &amp;amp;addr, (socklen_t *) &amp;amp;addrlen);
        if (received == -1)
            continue;

        buf[received] = 0;
        if (strcmp(buf, name) == 0)
            sendto(sock, &amp;quot;bingo&amp;quot;, 5, 0, (struct sockaddr *) &amp;amp;addr, addrlen);
    }
}

static void *waiton_response(void *arg)
{
    char *name = (char *) arg;

    while (1) {
        char buf[BUFSIZ+1];
        struct sockaddr_in addr;
        socklen_t addrlen = sizeof(addr);
        int received;

        received = recvfrom(sock, buf, sizeof(buf)-1, 0,
                            (struct sockaddr *) &amp;amp;addr, &amp;amp;addrlen);
        if (received == -1)
            continue;
        buf[received] = 0;
        if (strcmp(buf, &amp;quot;bingo&amp;quot;) == 0) {
            printf(&amp;quot;Got. %s&#39;s address is %s.\n&amp;quot;,
                   name, inet_ntoa(addr.sin_addr));
            exit(0);
        }
    }

    return NULL;
}

static void client(const char *name)
{
    int bcast = 1;
    pthread_t tid;
    pthread_attr_t attr;
    struct sockaddr_in addr;
    int i;

    setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &amp;amp;bcast, sizeof(bcast));

    pthread_attr_init(&amp;amp;attr);
    pthread_attr_setdetachstate(&amp;amp;attr, PTHREAD_CREATE_DETACHED);

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = 0xffffffff;
    addr.sin_port = htons(PORT);

    for (i = 0; i &amp;lt; 6; i++) {
        printf(&amp;quot;Searching...\n&amp;quot;);

        sendto(sock, name, strlen(name), 0,
               (struct sockaddr *) &amp;amp;addr, sizeof(addr));
        if (i == 0)
            pthread_create(&amp;amp;tid, &amp;amp;attr, waiton_response, (void *) name);
        sleep(5);
    }

    printf(&amp;quot;Cannot find the machine.\n&amp;quot;);
    pthread_attr_destroy(&amp;amp;attr);
}

int main(int argc, char **argv)
{
    progname = argv[0];
    sock = udp_socket();

    if (argc != 3)
        usage();
    if (strcmp(argv[1], &amp;quot;-s&amp;quot;) == 0)
        server(argv[2]);
    else if (strcmp(argv[1], &amp;quot;-c&amp;quot;) == 0)
        client(argv[2]);
    else
        usage();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PS. 最近 gist.github.com 好像不是很给力，用它贴代码的话，不翻墙就看不到，只好直接贴这里了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux 下有关环境变量与换行符的一个小问题</title>
      <link>https://glacjay.info/post/2011-03-05/linux-%E4%B8%8B%E6%9C%89%E5%85%B3%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 05 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2011-03-05/linux-%E4%B8%8B%E6%9C%89%E5%85%B3%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%AC%A6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;最近在工作中，老是遇到一个莫名其妙的问题。我有一个用来设置一些环境变量的脚本，结果经常发现这个脚本设过的环境变量乱七八糟的，像 PATH 这种，就是之前的值跟后面添加的值重叠在了一起。直到后来才发现，原来是换行符搞的鬼。&lt;/p&gt;

&lt;p&gt;这样说还不太清楚，上代码吧。编辑文本文件 &lt;code&gt;test.sh&lt;/code&gt; 如下，记得以 DOS 换行符的模式来保存：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Save this file using DOS&#39;s CR/LF.

export VAR1=blahblahblah
export VAR2=hello
export VAR1=$VAR1:$VAR2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，执行一下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ . ./test.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来使环境变量生效，并看一下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ echo $VAR1
:helloahblah
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，Shell 看到的还不是这个样子，而是会把多出来的那个 CR 回车符也看作是路径（或者其他什么值）的一部分，最后当然也会导致所作的设置不生效啦。&lt;/p&gt;

&lt;p&gt;至于为什么会变成这种换行符，我倒是还没有搞明白，因为我的源文件确实是 Unix 风格的换行符。也许是因为是在 Windows 下用 ClearCase 来进行源码控制的关系？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 Python 操作虚拟网卡</title>
      <link>https://glacjay.info/post/2010-09-18/%E7%94%A8-python-%E6%93%8D%E4%BD%9C%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/</link>
      <pubDate>Sat, 18 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>https://glacjay.info/post/2010-09-18/%E7%94%A8-python-%E6%93%8D%E4%BD%9C%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1/</guid>
      <description>&lt;p&gt;在我的 &lt;a href=&#34;https://glacjay.info/post/2009-12-19/%E5%88%A9%E7%94%A8-xmpp-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0-vpn/&#34;&gt;XTunnel&lt;/a&gt; 项目中，已经用 Python 作过这种相对底层的工作了（这说明 Python 果然还是非常强大的，上下层通吃啊），不过那边目前还是只实现了 Linux 的版本。后来我又陆陆续续地把 Windows 以及 Mac 下的操作方法给搞通了，今天就来总结一下。&lt;/p&gt;

&lt;p&gt;在 Linux 内核中，特别是在现在的发行版中，应该都已经有了 &lt;code&gt;TUN/TAP&lt;/code&gt; 虚拟网卡的驱动程序，看一下有没有 &lt;code&gt;/dev/net/tun&lt;/code&gt; 这个文件就可以知道了。如果没有，就执行一下 &lt;code&gt;sudo modprobe tun&lt;/code&gt; 这个命令吧。如果还是没有，那就 Google 之吧。下面上代码：&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/glacjay/585369.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;简而言之，就是首先打开对应的设备文件，然后通过 &lt;code&gt;ioctl&lt;/code&gt; 系统调用告诉它我们想要的网卡类型和名称，同时还可以告诉它我们想以普通用户的身份来对它进行操作。之后通过 &lt;code&gt;ifconfig&lt;/code&gt; 命令将新建的网卡拉起来，就可以开始读写了。&lt;/p&gt;

&lt;p&gt;当你以 root 身份运行这个脚本的时候，可以 &lt;code&gt;ping&lt;/code&gt; 一下 &lt;code&gt;192.168.7.2&lt;/code&gt; 这个地址试试，看看是不是能 &lt;code&gt;ping&lt;/code&gt; 得通。&lt;/p&gt;

&lt;p&gt;下面的代码则在 Mac 环境中实现了同样的功能（不过还没有设置用户身份的功能）：&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/glacjay/586860.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;当然要运行上面的代码，你首先要到&lt;a href=&#34;http://tuntaposx.sourceforge.net/&#34;&gt;这里&lt;/a&gt;下载并安装 Mac 下的 &lt;code&gt;TUN/TAP&lt;/code&gt; 设备驱动程序才行。安装之后，在系统的 &lt;code&gt;/dev&lt;/code&gt; 目录中就会分别有 16 个 &lt;code&gt;/dev/tunX&lt;/code&gt; 以及 &lt;code&gt;/dev/tapX&lt;/code&gt; （ &lt;code&gt;X&lt;/code&gt; 表示网卡序号）字符设备文件，分别对应于 &lt;code&gt;16&lt;/code&gt; 个同名的 &lt;code&gt;TUN/TAP&lt;/code&gt; 虚拟网卡。当然，在运行这个脚本之前，你是看不到这些网卡的。不不，用 &lt;code&gt;ifconfig -a&lt;/code&gt; 也不行。&lt;/p&gt;

&lt;p&gt;因为与 Linux 下的驱动的实现方法不同，这里是用的文件名来标识网卡类型与名称，所以就不需要 Linux 版本中的第一个 &lt;code&gt;ioctl&lt;/code&gt; 调用了。&lt;/p&gt;

&lt;p&gt;也不记得一开始是在哪边看到的一个讲 &lt;code&gt;TUN/TAP&lt;/code&gt; 编程的文章，说要实现对 &lt;code&gt;ping&lt;/code&gt; 报文的处理，只要简单地将读到的 IP 报文中的源地址与目的地址对换一下，再写回去就可以了。在 Linux 系统中也确实是如此，因此我也就没有深究。直到后来才发现，同样的招数在 Mac 下居然没用。于是赶紧上网翻 ICMP 的报文格式，改报文中的 &lt;code&gt;type&lt;/code&gt; 码，并重新计算 &lt;code&gt;checksum&lt;/code&gt; ，这才搞定。这时也才发现，用 Python 来操作原始的字节流还是没有 C 这种底层语言直观啊。&lt;/p&gt;

&lt;p&gt;可是 Linux 下为什么不需要这么麻烦呢？于是回去抓了抓包，这才发现，相对于 Mac 下的一问（ &lt;code&gt;ping&lt;/code&gt; 命令）一答（ Python 脚本），在 Linux 下居然是两问两答，一问是 &lt;code&gt;ping&lt;/code&gt; 命令，一问是我们的那个 Python 脚本。这也不奇怪，我连 &lt;code&gt;ICMP&lt;/code&gt; 中的 &lt;code&gt;type&lt;/code&gt; 码都没改，发过来的是 &lt;code&gt;request&lt;/code&gt; ，那再发出去的当然还是 &lt;code&gt;request&lt;/code&gt; 。至于应答，大概就是 Linux 的 &lt;code&gt;TUN/TAP&lt;/code&gt; 驱动搞的鬼了。&lt;/p&gt;

&lt;p&gt;最后，当然也有 Windows 的实现版本啦，不过代码被我丢到公司的 Windows 工作用机上了，所以，就请您且听下回分解了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Update 2011-04-26:&lt;/strong&gt; Windows 下的实现代码如下：&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/glacjay/586892.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>